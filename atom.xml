<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>梦之彼岸</title>
  
  <subtitle>只有神知道的世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gydjsz.github.io/"/>
  <updated>2019-05-19T08:07:20.997Z</updated>
  <id>https://gydjsz.github.io/</id>
  
  <author>
    <name>gydjsz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数学知识集锦</title>
    <link href="https://gydjsz.github.io/2019/05/19/algorithm/math/"/>
    <id>https://gydjsz.github.io/2019/05/19/algorithm/math/</id>
    <published>2019-05-19T08:07:21.037Z</published>
    <updated>2019-05-19T08:07:20.997Z</updated>
    
    <content type="html"><![CDATA[<ol><li>用一个平面截球而得到球的一部分叫做球缺, 球缺是实体，它的体积公式为：<br>V = π <em> h² </em> (3 * r - h) / 3;<br>r表示球的半径，h表示球缺的高。</li></ol><p>球冠是球面的一部分，是用平面去截球面而得到的一部分, 这个平面截球面所得的圆叫做球冠的底，垂直于截面的球的直径被这截面截得的线段的长叫做球冠的高。<br>球冠的面积公式是S = 2 <em> π </em> r * h。</p><ol start="2"><li>欧拉函数: ϕ(n) 1~n中与n互质的数的个数</li></ol><p>令n = p1^r1 <em> p2^r2…pk^rk<br>则ϕ(n)=n</em>(1-1/p1)<em>(1-1/p2)</em>…*(1-1/pk)<br>其中p1, p2……pn为n的所有质因数，n是不为0的整数。</p><p>欧拉函数是积性函数:</p><ol><li>若m,n互质，ϕ(mn) = ϕ(m) * ϕ(n)</li><li>当n为奇质数时，ϕ(2n) = ϕ(n) </li><li><p>若n为质数, 则 ϕ(n) = n - 1</p></li><li><p>精度较高地求π<br>cos(π) = -1<br>=&gt; π = acos(-1)</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;用一个平面截球而得到球的一部分叫做球缺, 球缺是实体，它的体积公式为：&lt;br&gt;V = π &lt;em&gt; h² &lt;/em&gt; (3 * r - h) / 3;&lt;br&gt;r表示球的半径，h表示球缺的高。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;球冠是球面的一部分，是用平面去截球面而得到
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vim快捷键</title>
    <link href="https://gydjsz.github.io/2019/05/19/LearnVim/VimKeyCut/"/>
    <id>https://gydjsz.github.io/2019/05/19/LearnVim/VimKeyCut/</id>
    <published>2019-05-19T02:53:53.656Z</published>
    <updated>2019-05-19T02:53:53.612Z</updated>
    
    <content type="html"><![CDATA[<p>[参考链接]<a href="https://www.cnblogs.com/jy02414216/archive/2012/10/29/2745001.html" target="_blank" rel="noopener">https://www.cnblogs.com/jy02414216/archive/2012/10/29/2745001.html</a><br>[参考链接]<a href="https://blog.csdn.net/scaleqiao/article/details/45153379" target="_blank" rel="noopener">https://blog.csdn.net/scaleqiao/article/details/45153379</a><br><a id="more"></a></p><font size="3"><strong>VIM光标跳转</strong></font><p>h, j, k, l :左, 下, 上, 右<br>gj :向下移动一行<br>gk :向上移动一行<br>gg :移动到文件首<br>G :移动到文件末尾<br>w :向前移动一个单词,光标停留在下一个单词开头<br>W :向前移动一个单词,光标停留在下一个单词开头,但忽略标点<br>e :向前移动一个单词,光标停留在单词末尾<br>E :移动到单词末尾,如果有标点则移动到标点处<br>( :前移一句<br>) :后移一句<br>{ :前移一段<br>} :后移一段<br>0 :移动到行首<br>$ :移动到行尾<br>n| :移动到第n列<br>nG / ngg :移动到第n行<br>H :光标移动到屏幕顶端<br>M :光标移动到屏幕中间一行<br>L :光标移动到屏幕最底端一行</p><font size="3"><strong>VIM翻屏指令</strong></font><br>ctrl+f :下翻一屏<br>ctrl+b :上翻一屏<br>ctrl+d :下翻半屏<br>ctrl+u :上翻半屏<br>ctrl+e :向下滚动一行<br>ctrl+y :向上滚动一行<br>n% :到文件n%的位置<br>zz :将当前行移动到屏幕中央<br>zt :将当前行移动到屏幕顶端<br>zb :将当前行移动到屏幕底端<br><br><br><font size="3"><strong>VIM分屏指令</strong></font><p>:new (name)，新建一个未命名(文件名为name)的窗口件并分屏， 快捷键，Ctrl+W，然后马上按n键<br>:split (name) / 缩写:sp name 水平分屏，将当前屏分为两个，水平的。   Ctrl + w, s<br>:vsplit (name) / 缩写:vs name 垂直分屏，将当前屏分为两个，垂直的。  Ctrl + w, v<br>:only 取消分屏，取消当前的屏，当前屏指的是光标所在屏。</p><p>关闭当前屏: Ctrl+w，c。</p><p>切换窗口:<br>Ctrl + w, w 后一个<br>Ctrl + w, p 前一个</p><p>Ctrl + w, h 四个方向<br>Ctrl + w, i<br>Ctrl + w, k<br>Ctrl + w, l</p><p>关闭其他窗口:<br>Ctrl + w, o</p><p>载入文件</p><p>:vs  文件路径/文件名      在新的垂直分屏中打开文件</p><p>:sv  文件路径/文件名      在新的水平分屏中打开文件</p><font size="3"><strong>VIM字母转换</strong></font><p>gu:字符转换小写<br>gU:字符转换大写<br>gul / gUl :将光标所在字符转换为小写/大写<br>guh / gUh :将光标左边字符转换为小写/大写</p><font size="3"><strong>VIM复制粘贴</strong></font><p>x :剪切右边字符<br>X :剪切左边字符<br>yy / Y :复制整行文本<br>:m,ny :复制m行到n行的文本<br>v :开始选择文本<br>V :选择当前行的文本<br>dd :删除当前行<br>D :删除光标后面的文本<br>p :在光标之后粘贴<br>P :在光标之前粘贴</p><font size="3"><strong>VIM自带的补全</strong></font><p>C-x C-v :补全vim选项和命令。<br>C-x C-l :整行补全。<br>C-x C-f :自动补全文件路径。弹出菜单后，按C-f循环选择，当然也可以按 C-n和C-p。<br>C-x C-p 和 C-x C-n :用文档中出现过的单词补全当前的词。 直接按C-p和C-n也可以。<br>C-x C-o :编程时可以补全关键字和函数名啊。<br>C-x C-i :根据头文件内关键字补全。<br>C-x C-d :补全宏定义。<br>C-x C-n :按缓冲区中出现过的关键字补全。 直接按C-n或C-p即可。</p><font size="3"><strong>VIM插入模式</strong></font><p>i :在光标处插入<br>I :在行首插入<br>a :在光标后面插入<br>A :在行尾插入<br>o :在下一行插入<br>O :在上一行插入<br>Esc :进入一般模式</p><font size="3"><strong>VIM保存文件</strong></font><br>:w :保存文件但不退出vi<br>:w file :将修改另外保存到file中，不退出vi<br>:w! :强制保存，不退出vi<br>:wq :保存文件并退出vi<br>:wq! :强制保存文件，并退出vi<br>:q :不保存文件，退出vi<br>:q! :不保存文件，强制退出vi<br>:e! :放弃所有修改，从上次保存文件开始再编辑命令历史<br>ZZ :保存文件<br><br><font size="3"><strong>VIM格式化代码</strong></font><br><font size="2"><strong>格式化的核心是= + 位置</strong></font><br>gg=G :格式化整个文档<br>=G   :向下格式化所有行<br>n==  :向下格式化n行<br>n= + 方向: 朝某个方向格式化n行<br>==   :格式化当前行<br>={   :向上格式化代码块<br>=}   :向下格式化代码块<br>mg=ng:格式化m行到n行<br><br><font size="3"><strong>vim插入内容</strong></font><br>:r 文件名 :将文件的内容插入到光标处<br>:r !命令 :将命令的结果插入到光标处<br>:! 命令 :只显示命令的结果不写入<br><br><font size="3"><strong>vim自定义快捷键</strong></font><br>:map 快捷键 操作方式<esc> :快捷键使用Ctrl-v-某字母,使用Ctrl-某字母,可以调出命令<br>:ab 快捷字 想要写入的文字 :当编辑文本出现快捷字之后,按下回车或者空格,快捷字就会变成相要写入的文字<br><br>想要保存快捷键的话,需要在家目录下新建一个.vimrc文件,然后在里面写入map 快捷键 操作方式,<br>ab 快捷字 想要写入的文字,(这里不需要冒号),然后保存就可以了<br><br><font size="3"><strong>vim宏录制</strong></font><br>qa进入宏录制，q退出，@a执行，n@a执行n次<br><br>宏录制是一个非常强大的功能，可以执行相同的操作n次。<br>比如我有一个数字1，我按下qa，按下V选中1，按下y复制1，再按下p，1就被复制到下一行，然后按下Ctrl-a，将1变成2，最后按下q。我的宏就录制好了，首先输入1，然后在一般模式下输入100@a，就有从1到100个数字列出来了。<br><br><font size="3"><strong>插件快捷键</strong></font><ol><li>The-NERD-Commenter</li></ol><p>\ cc 代码注释  \ cu 代码取消注释 \ c 空格键智能添加取消注释, \ ca　在行尾添加注释</p><ol start="2"><li><p>基于缩进或语法进行代码折叠<br>set foldmethod=indent<br>set foldmethod=syntax</p><p>启动 vim 时关闭折叠代码, 操作：za，打开或关闭当前折叠；zM，关闭所有折叠；zR，打开所有折叠。</p></li></ol></esc>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[参考链接]&lt;a href=&quot;https://www.cnblogs.com/jy02414216/archive/2012/10/29/2745001.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/jy02414216/archive/2012/10/29/2745001.html&lt;/a&gt;&lt;br&gt;[参考链接]&lt;a href=&quot;https://blog.csdn.net/scaleqiao/article/details/45153379&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/scaleqiao/article/details/45153379&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>小技巧</title>
    <link href="https://gydjsz.github.io/2019/05/15/StlLearn/fuction/"/>
    <id>https://gydjsz.github.io/2019/05/15/StlLearn/fuction/</id>
    <published>2019-05-15T04:45:57.967Z</published>
    <updated>2019-05-15T04:45:57.939Z</updated>
    
    <content type="html"><![CDATA[<p>//去掉对c输入输出的兼容，加快c++速度<br>std::ios::sync_with_stdio(false);<br>cin.tie(NULL);<br><a id="more"></a></p><ol><li><p>next_permutation(): 按照字典顺序产生区间内元素下一个较大的排列组合<br>prev_permutation(): 按照字典顺序产生区间内元素下一个较小的排列组合</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> perm[] = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;   <span class="comment">//初始化该数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">permutation</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)    <span class="comment">//输出一个排列</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; perm[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">while</span>(next_permutation(perm, perm + <span class="number">3</span>));   <span class="comment">//按照字典序生成排列，若生成完毕，返回false</span></span><br><span class="line"><span class="comment">/*输出 3 1 2</span></span><br><span class="line"><span class="comment">       3 2 1 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>nth_element(a + l, a + k, a + r): 使得ａ这个数组中区间(l, r)内的第ｋ大元素处在第ｋ个位置上, 默认排在k前面的元素都不比它大，排在它后面的元素都不比它小,而左右两边是无序的</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">nth_element(a + <span class="number">1</span>, a + <span class="number">2</span>, a + <span class="number">6</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;    <span class="comment">//第2大是３，输出1 3 7 5 6</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>to_string(): 将数字转化为字符串<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = to_string(<span class="number">123</span>);   <span class="comment">// s = "123"</span></span><br></pre></td></tr></table></figure></li></ol><p>使用stringstream字符串流来实现转换<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;   //头文件sstream</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int 转 string</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss &lt;&lt; n;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">ss &gt;&gt; s;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//s = "123"</span></span><br><span class="line"></span><br><span class="line">ss.clear();   <span class="comment">//同一个stream多次转换应该调用clear()方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//string 转 int</span></span><br><span class="line">s = <span class="string">"2233"</span>;</span><br><span class="line">ss &lt;&lt; s;</span><br><span class="line">ss &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//n = 2233</span></span><br></pre></td></tr></table></figure></p><ol start="4"><li><p>bitset<n> bit(num);  // 将num转化为n位二进制 </n></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bitset</span>&lt;2&gt; b(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出11</span></span><br></pre></td></tr></table></figure></li><li><p>输入一个数字num, 求num的位数<br>#include <cmath></cmath></p><p>len = int(log10(num)) + 1</p></li><li><p>考虑一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。 n个元素的错排数记为D(n) </p></li></ol><p>错排公式:<br>D(n) = (n-1) [D(n-2) + D(n-1)]</p><p>特殊地，D(1) = 0, D(2) = 1.</p><ol start="7"><li>快读板子</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">namespace io &#123;</span><br><span class="line">    const int SIZE = 1e7 + 10;</span><br><span class="line">    char inbuff[SIZE];</span><br><span class="line">    char *l, *r;</span><br><span class="line">    inline void init() &#123;</span><br><span class="line">        l = inbuff;</span><br><span class="line">        r = inbuff + fread(inbuff, 1, SIZE, stdin);</span><br><span class="line">    &#125;</span><br><span class="line">    inline char gc() &#123;</span><br><span class="line">        if (l == r) init();</span><br><span class="line">        return (l != r) ? *(l++) : EOF;</span><br><span class="line">    &#125;</span><br><span class="line">    void read(int &amp;x) &#123;</span><br><span class="line">        x = 0; char ch = gc();</span><br><span class="line">        while(!isdigit(ch)) ch = gc();</span><br><span class="line">        while(isdigit(ch)) x = x * 10 + ch - &apos;0&apos;, ch = gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; using io::read;</span><br></pre></td></tr></table></figure><p>在主程序中 read(x); 即可。</p><ol start="8"><li>lower_bound(begin, end, num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</li></ol><p>upper_bound(begin, end, num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;//去掉对c输入输出的兼容，加快c++速度&lt;br&gt;std::ios::sync_with_stdio(false);&lt;br&gt;cin.tie(NULL);&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>链接收藏</title>
    <link href="https://gydjsz.github.io/2019/05/08/GoodWebsiteCollection/"/>
    <id>https://gydjsz.github.io/2019/05/08/GoodWebsiteCollection/</id>
    <published>2019-05-08T11:12:41.458Z</published>
    <updated>2019-05-08T11:12:41.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a><font size="4">下载链接</font></h1><ol><li>putty下载:&ensp;<a href="https://pan.baidu.com/s/1X_IITIlSP5u_wnKPiOL-oA" target="_blank" rel="noopener">https://pan.baidu.com/s/1X_IITIlSP5u_wnKPiOL-oA</a><br>&ensp;&ensp;&ensp; 提取码：8of8</li></ol><hr><a id="more"></a><ol start="2"><li><p>xshell下载链接：<a href="https://pan.baidu.com/s/1qb_wYdU3S-9s3dpBzIMCoQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1qb_wYdU3S-9s3dpBzIMCoQ</a><br>&ensp;&ensp;&ensp; 提取码：r2x7 </p></li><li><p>xsel下载链接：链接：<a href="https://pan.baidu.com/s/1JY269KghMzMvCLgy1_XlwQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1JY269KghMzMvCLgy1_XlwQ</a><br>&ensp;&ensp;&ensp; 提取码：opml </p></li></ol><h1 id="编程练习"><a href="#编程练习" class="headerlink" title="编程练习"></a><font size="4">编程练习</font></h1><ol><li><p>PTA:&ensp;<a href="https://pintia.cn/" target="_blank" rel="noopener">https://pintia.cn/</a></p></li><li><p>牛客网:&ensp;<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></p></li><li><p>nyoj:&ensp;<a href="http://acm.nyist.edu.cn/JudgeOnline/problemset.php" target="_blank" rel="noopener">http://acm.nyist.edu.cn/JudgeOnline/problemset.php</a></p></li><li><p>LibreOj:&ensp;<a href="https://loj.ac/]" target="_blank" rel="noopener">https://loj.ac/</a></p></li><li><p>TMaD OJ:&ensp;<a href="http://tmad.ctguqmx.com/" target="_blank" rel="noopener">http://tmad.ctguqmx.com/</a></p></li><li><p>编程网站(全):<a href="https://vjudge.net/" target="_blank" rel="noopener">https://vjudge.net/</a></p></li><li><p>leetcode: <a href="https://leetcode-cn.com/" target="_blank" rel="noopener">https://leetcode-cn.com/</a></p></li><li><p>洛谷：<a href="https://www.luogu.org/" target="_blank" rel="noopener">https://www.luogu.org/</a></p></li></ol><hr><h1 id="编程学习"><a href="#编程学习" class="headerlink" title="编程学习"></a><font size="4">编程学习</font></h1><ol><li><p>速学堂:&ensp;<a href="http://www.sxt.cn/" target="_blank" rel="noopener">http://www.sxt.cn/</a></p></li><li><p>菜鸟教程:&ensp;<a href="http://www.runoob.com/" target="_blank" rel="noopener">http://www.runoob.com/</a></p></li><li><p>黑马程序员:&ensp;<a href="http://yun.itheima.com/" target="_blank" rel="noopener">http://yun.itheima.com/</a></p></li></ol><hr><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a><font size="4">博客</font></h1><ol><li><p>简明现代魔法:&ensp;<a href="http://www.nowamagic.net/" target="_blank" rel="noopener">http://www.nowamagic.net/</a></p></li><li><p>CSDN:&ensp;<a href="https://www.csdn.net/" target="_blank" rel="noopener">https://www.csdn.net/</a></p></li><li><p>Exp技术分享博客:&ensp;<a href="http://exp-blog.com/" target="_blank" rel="noopener">http://exp-blog.com/</a></p></li></ol><hr><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a><font size="4">Linux</font></h1><ol><li><p>Linux命令大全:&ensp;<a href="http://man.linuxde.net/" target="_blank" rel="noopener">http://man.linuxde.net/</a></p></li><li><p>鸟哥的Linux私房菜:&ensp;<a href="https://www.kancloud.cn/wizardforcel/vbird-linux-basic-4e/152191" target="_blank" rel="noopener">https://www.kancloud.cn/wizardforcel/vbird-linux-basic-4e/152191</a></p></li></ol><hr><h1 id="工具网站"><a href="#工具网站" class="headerlink" title="工具网站"></a><font size="4">工具网站</font></h1><ol><li><p>在线计算器:&ensp;<a href="http://www.ab126.com/" target="_blank" rel="noopener">http://www.ab126.com/</a></p></li><li><p>图片和base64编码转换:&ensp;<a href="http://www.vgot.net/test/image2base64.php?" target="_blank" rel="noopener">http://www.vgot.net/test/image2base64.php?</a></p></li><li><p>在线vim编辑器学习:&ensp;<a href="http://www.atool.org/vim.php" target="_blank" rel="noopener">http://www.atool.org/vim.php</a></p></li><li><p>二维码在线解析:&ensp;<a href="http://cdn.malu.me/qrdecode/" target="_blank" rel="noopener">http://cdn.malu.me/qrdecode/</a></p></li><li><p>视频下载: <a href="http://weibodang.cn/" target="_blank" rel="noopener">http://weibodang.cn/</a></p></li><li><p>多平台音乐在线播放: <a href="http://music.lkxin.cn/" target="_blank" rel="noopener">http://music.lkxin.cn/</a></p></li><li><p>在线打字网站1: <a href="https://www.typingclub.com/" target="_blank" rel="noopener">https://www.typingclub.com/</a><br>在线打字网站2: <a href="https://www.typing.com/" target="_blank" rel="noopener">https://www.typing.com/</a></p></li><li><p>代码共享：<a href="https://paste.ubuntu.com/" target="_blank" rel="noopener">https://paste.ubuntu.com/</a><br><img src="https://github.com/gydjsz/hexo/blob/master/source/picture/ubuntu.png?raw=true" alt=""></p></li><li><p>工具网站：<a href="http://www.bejson.com/" target="_blank" rel="noopener">http://www.bejson.com/</a></p></li><li><p>图片托管：<a href="https://miao.su/" target="_blank" rel="noopener">https://miao.su/</a></p></li><li><p>多种语言在线编译器：<a href="http://www.dooccn.com/cpp/" target="_blank" rel="noopener">http://www.dooccn.com/cpp/</a></p></li><li><p>多平台音乐免费下载: <a href="https://music.boxmoe.cn/" target="_blank" rel="noopener">https://music.boxmoe.cn/</a> </p></li><li><p>在线工具: <a href="https://tool.lu/" target="_blank" rel="noopener">https://tool.lu/</a></p></li><li><p>百度云不限速: <a href="https://www.baiduwp.com/" target="_blank" rel="noopener">https://www.baiduwp.com/</a></p></li></ol><hr><h1 id="好的技术博文"><a href="#好的技术博文" class="headerlink" title="好的技术博文"></a><font size="4">好的技术博文</font></h1><ol><li>python安装提示No module named setuptools,wget提示ERROR 403: SSL is required<br><a href="https://blog.csdn.net/jiaoshengha/article/details/79384223" target="_blank" rel="noopener">https://blog.csdn.net/jiaoshengha/article/details/79384223</a></li></ol><p>里面提到的链接无法下载的问题,其实直接把链接复制到浏览器中打开就好,若是在终端下就可以使用里面说的方法,使用sudo wget 链接;</p><ol start="2"><li><p>ubuntu中安装eclipse<br><a href="https://blog.csdn.net/wmyan/article/details/78279846" target="_blank" rel="noopener">https://blog.csdn.net/wmyan/article/details/78279846</a></p></li><li><p>ubuntu安装kchmviewer查看jdk-api文档<br><a href="https://blog.csdn.net/qq_32296307/article/details/53064587" target="_blank" rel="noopener">https://blog.csdn.net/qq_32296307/article/details/53064587</a></p></li></ol><p>直接一条命令：sudo apt-get install kchmviewer<br>然后打开文档的时候选择kchmviewer就行了</p><ol start="4"><li><p>git学习<br><a href="https://mp.weixin.qq.com/s/BHJ44cDhnPQrvqdqowwilg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/BHJ44cDhnPQrvqdqowwilg</a></p></li><li><p>shell常用正则表达式<br><a href="https://mp.weixin.qq.com/s/IUrgFLNWnqJOe8yfcb2W6w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/IUrgFLNWnqJOe8yfcb2W6w</a></p></li><li><p>Linux常用命令总结<br><a href="https://mp.weixin.qq.com/s/xtXPUy8qB4YMa5W8HwzoGA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/xtXPUy8qB4YMa5W8HwzoGA</a></p></li><li><p>wget 命令用法详解<br><a href="https://mp.weixin.qq.com/s/iN_fsL98TeR8WsaCeMpVcw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/iN_fsL98TeR8WsaCeMpVcw</a></p></li><li><p>IntelliJ IDEA 教程设置讲解<br><a href="https://mp.weixin.qq.com/s/PbKCoAO1gyEgpsGs_FQ3oQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/PbKCoAO1gyEgpsGs_FQ3oQ</a></p></li><li><p>Ubuntu 18.04 安装、配置和美化<br><a href="https://blog.csdn.net/szhiy/article/details/81385107" target="_blank" rel="noopener">https://blog.csdn.net/szhiy/article/details/81385107</a></p></li><li><p>Ubuntu安装Anaconda navigator 启动图形化界面<br><a href="https://blog.csdn.net/u013550000/article/details/80433402" target="_blank" rel="noopener">https://blog.csdn.net/u013550000/article/details/80433402</a></p></li><li><p>安装、配置Jupyter Notebook快速入门<br><a href="https://www.cnblogs.com/Neo007/p/7501625.html" target="_blank" rel="noopener">https://www.cnblogs.com/Neo007/p/7501625.html</a></p></li><li><p>打开git bash时出现闪退<br><a href="https://blog.csdn.net/qq_34400736/article/details/72627343" target="_blank" rel="noopener">https://blog.csdn.net/qq_34400736/article/details/72627343</a></p></li><li><p>Linux下安装jdk<br><a href="https://www.linuxidc.com/Linux/2015-01/112030.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2015-01/112030.htm</a></p></li><li><p>Linux之间互传文件<br><a href="https://blog.csdn.net/qq_30968657/article/details/72912070" target="_blank" rel="noopener">https://blog.csdn.net/qq_30968657/article/details/72912070</a></p></li><li><p>北大ACM-POJ试题分类<br><a href="http://exp-blog.com/2018/06/28/pid-38/" target="_blank" rel="noopener">http://exp-blog.com/2018/06/28/pid-38/</a></p></li><li><p>git恢复误删的分支<br><a href="https://www.cnblogs.com/xd502djj/p/9319980.html" target="_blank" rel="noopener">https://www.cnblogs.com/xd502djj/p/9319980.html</a></p></li><li><p>三级网络技术指南<br><a href="http://96ea5f9a.wiz03.com/share/s/2mWB-q0kLQ9B2ZqZt31C4U2z0nE7Tm03PAoR28IbN93qLZvQ" target="_blank" rel="noopener">http://96ea5f9a.wiz03.com/share/s/2mWB-q0kLQ9B2ZqZt31C4U2z0nE7Tm03PAoR28IbN93qLZvQ</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;下载链接&quot;&gt;&lt;a href=&quot;#下载链接&quot; class=&quot;headerlink&quot; title=&quot;下载链接&quot;&gt;&lt;/a&gt;&lt;font size=&quot;4&quot;&gt;下载链接&lt;/font&gt;&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;putty下载:&amp;ensp;&lt;a href=&quot;https://pan.baidu.com/s/1X_IITIlSP5u_wnKPiOL-oA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pan.baidu.com/s/1X_IITIlSP5u_wnKPiOL-oA&lt;/a&gt;&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp; 提取码：8of8&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>markdown语法学习</title>
    <link href="https://gydjsz.github.io/2019/05/08/markdown/"/>
    <id>https://gydjsz.github.io/2019/05/08/markdown/</id>
    <published>2019-05-08T06:10:13.758Z</published>
    <updated>2019-05-08T06:10:13.730Z</updated>
    
    <content type="html"><![CDATA[<p>[markdown语法]<a href="https://www.jianshu.com/p/b03a8d7b1719" target="_blank" rel="noopener">https://www.jianshu.com/p/b03a8d7b1719</a><br>[markdown语法]<a href="https://www.appinn.com/markdown/#header" target="_blank" rel="noopener">https://www.appinn.com/markdown/#header</a><br>[markdown缩进]<a href="https://www.cnblogs.com/Flylater/p/6264799.html" target="_blank" rel="noopener">https://www.cnblogs.com/Flylater/p/6264799.html</a><br>[先来一头马克飞象(在线使用markdown)]<a href="https://maxiang.io/" target="_blank" rel="noopener">https://maxiang.io/</a><br>[markdown插入图片]<a href="https://blog.csdn.net/slaughterdevil/article/details/79255933" target="_blank" rel="noopener">https://blog.csdn.net/slaughterdevil/article/details/79255933</a><br>[添加百度云图片链接]<a href="https://jingyan.baidu.com/article/f006222806dfdcfbd3f0c880.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/f006222806dfdcfbd3f0c880.html</a><br><a id="more"></a></p><p>目录：</p><ol><li><a href="#1">插入跳转链接</a></li><li><a href="#2">缩进</a></li><li><a href="#3">插入图片</a></li><li><a href="#4">添加页内跳转</a></li><li><a href="#5">文章摘要显示</a></li></ol><h1 id="1-插入跳转链接"><a href="#1-插入跳转链接" class="headerlink" title=" 1.插入跳转链接"></a><span id="1"> <font size="3">1.插入跳转链接</font></span></h1><p><a href="https://blog.fbzl.org/" target="_blank">https://blog.fbzl.org/“</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;https://blog.fbzl.org/&quot; target=&quot;_blank&quot;&gt;https://blog.fbzl.org/&quot;&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><hr><h1 id="2-缩进"><a href="#2-缩进" class="headerlink" title="2.缩进"></a><span id="2"><font size="3">2.缩进</font></span></h1><p>在每一行开头的时候，先输入下面的代码，然后紧跟着输入文本即可。注意有分号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">半角空格: &amp;ensp;或 &amp;#8194;</span><br><span class="line">全角空格: &amp;emsp;或 &amp;#8195;</span><br><span class="line">不换行空格: &amp;nbsp;或 &amp;#160;</span><br></pre></td></tr></table></figure></p><hr><h1 id="3-插入图片"><a href="#3-插入图片" class="headerlink" title="3.插入图片"></a><span id="3"><font size="3">3.插入图片</font></span></h1><p>首先插入本地图片的地址不是绝对路径,比如说我图片的绝对路径为~/Picture/picture1.jpg<br>我写博客的位置是~/Documents/blog,那么添加的图片路径是相对路径,即从我当前路径开始算起,<br>路径为../Picture/picture1.jpg;</p><p>了解linux的应该知道, “..”表示上一层目录, 可是我使用这种方法,会出现网页中显示不了图片的情况,甚至在一篇文章里面可以显示,但是放在另一篇文章里面就显示不了的情况,所以现在给出其它的方法</p><p>一. <font size="3"><strong>使用base64编码</strong></font><br>图片和base64编码转换网址: <a href="http://www.vgot.net/test/image2base64.php" target="_blank" rel="noopener">http://www.vgot.net/test/image2base64.php</a>?</p><p>因为编码很长,所以可以放在文章的最后面,以下的picture是编码id,可以自己设定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">文章</span><br><span class="line"></span><br><span class="line">插入的图片位置:</span><br><span class="line">![图片说明][picture]</span><br><span class="line"></span><br><span class="line">文章</span><br><span class="line"></span><br><span class="line">文章末尾</span><br><span class="line"></span><br><span class="line">代码区域填写:</span><br><span class="line">[picture]:data:image/png;base64,编码</span><br></pre></td></tr></table></figure></p><p>二. <font size="3"><strong>使用百度云添加图片外链</strong></font></p><ol><li><p>首先上传图片到百度云盘中,存储容量有2T,所以不用担心图片太多,最好是单独创建一个文件夹,将图片保存在里面</p></li><li><p>鼠标右键点击分享,默认加密选项,有效期永久,然后点击确定</p></li><li><p>将链接复制到浏览器中打开,可以看到自己的图片,然后右键点击图片然后复制图片链接,这个就是你的图片外链了</p></li><li><p>在博客中添加图片外链:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片说明](链接)</span><br></pre></td></tr></table></figure></li></ol><p>二. <font size="3"><strong>使用github添加图片外链</strong></font></p><ol><li>先将图片上传到github中</li><li>在github中打开图片，复制图片链接</li></ol><h1 id="4-添加页内跳转"><a href="#4-添加页内跳转" class="headerlink" title="4.添加页内跳转"></a><span id="4"><font size="3">4.添加页内跳转</font></span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[跳转到标题](#1)</span><br><span class="line">&lt;span id=&quot;1&quot;&gt;标题&lt;/span&gt;</span><br></pre></td></tr></table></figure><h1 id="5-文章摘要显示"><a href="#5-文章摘要显示" class="headerlink" title="5.文章摘要显示"></a><span id="5"><font size="3">5.文章摘要显示</font></span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">摘要文字部分</span><br><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[markdown语法]&lt;a href=&quot;https://www.jianshu.com/p/b03a8d7b1719&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/b03a8d7b1719&lt;/a&gt;&lt;br&gt;[markdown语法]&lt;a href=&quot;https://www.appinn.com/markdown/#header&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.appinn.com/markdown/#header&lt;/a&gt;&lt;br&gt;[markdown缩进]&lt;a href=&quot;https://www.cnblogs.com/Flylater/p/6264799.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/Flylater/p/6264799.html&lt;/a&gt;&lt;br&gt;[先来一头马克飞象(在线使用markdown)]&lt;a href=&quot;https://maxiang.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://maxiang.io/&lt;/a&gt;&lt;br&gt;[markdown插入图片]&lt;a href=&quot;https://blog.csdn.net/slaughterdevil/article/details/79255933&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/slaughterdevil/article/details/79255933&lt;/a&gt;&lt;br&gt;[添加百度云图片链接]&lt;a href=&quot;https://jingyan.baidu.com/article/f006222806dfdcfbd3f0c880.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://jingyan.baidu.com/article/f006222806dfdcfbd3f0c880.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>矩阵快速幂</title>
    <link href="https://gydjsz.github.io/2019/04/18/algorithm/6.%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <id>https://gydjsz.github.io/2019/04/18/algorithm/6.矩阵快速幂/</id>
    <published>2019-04-18T06:51:12.729Z</published>
    <updated>2019-04-18T06:51:12.661Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> 利用矩阵快速幂求斐波那切数列</span><br><span class="line"> F[i] = 1 * F[i - 1] + 1 * F[i - 2] </span><br><span class="line"> F[i - 1] = 1 * F[i - 1] + 0 * F[i - 2];</span><br><span class="line"></span><br><span class="line"> -       -    -   -     -        -</span><br><span class="line">|  F[i]  | =| 1 1 | * | F[n - 1] | </span><br><span class="line">|F[i - 1] |  | 1 0 |   | F[n - 2] |</span><br><span class="line"> -       -    -   -     -        - </span><br><span class="line"> -       -    -   - ^(n - 1) -    -</span><br><span class="line">|  F[i]  | =| 1 1 |        | F[1] | </span><br><span class="line">|F[i - 1] |  | 1 0 |   *    | F[0] |</span><br><span class="line"> -       -    -   -          -    - </span><br><span class="line"></span><br><span class="line">      -   -  </span><br><span class="line"> A = | 1 1 |</span><br><span class="line">     | 1 0 |</span><br><span class="line">      -   - </span><br><span class="line"></span><br><span class="line"> 也就是使用矩阵快速幂求出A的n - 1次方，F[1] = 1, F[0] = 0,求得的矩阵为A&apos;(2 * 1)，数列第ｎ个的值为A&apos;[0][0]</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;vec&gt; mat;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//矩阵相乘</span></span><br><span class="line"><span class="function">mat <span class="title">mul</span><span class="params">(mat &amp;A, mat &amp;B)</span></span>&#123;</span><br><span class="line"><span class="comment">//Ｃ默认值为0</span></span><br><span class="line"><span class="function">mat <span class="title">C</span><span class="params">(A.size(), vec(B[<span class="number">0</span>].size()))</span></span>;   <span class="comment">//A.size()是矩阵的行，B[0].size()是矩阵的列, n * m 矩阵　和　m * k矩阵相乘之后，新矩阵为n * k</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.size(); j++)   <span class="comment">//B.size()是矩阵的行，也就是A[0].size()</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; B[<span class="number">0</span>].size(); k++)</span><br><span class="line">C[i][j] += A[i][k] * B[k][j];  <span class="comment">//新矩阵当前值=矩阵A的当前行 * 矩阵B的当前列的和</span></span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速幂</span></span><br><span class="line"><span class="function">mat <span class="title">pow</span><span class="params">(mat A, ll n)</span></span>&#123;</span><br><span class="line"><span class="function">mat <span class="title">B</span><span class="params">(A.size(), vec(A.size()))</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++)</span><br><span class="line">B[i][i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(n &amp; <span class="number">1</span>)</span><br><span class="line">B = mul(B, A);</span><br><span class="line">A = mul(A, A);</span><br><span class="line">n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求斐波那切数列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="function">mat <span class="title">A</span><span class="params">(<span class="number">2</span>, vec(<span class="number">2</span>))</span></span>;</span><br><span class="line">A[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">A[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">A[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">A[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">A = <span class="built_in">pow</span>(A, n - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; A[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/* //求矩阵Ａ× Ｂ</span></span><br><span class="line"><span class="comment">int ax, ay, bx, by;</span></span><br><span class="line"><span class="comment">cin &gt;&gt; ax &gt;&gt; ay &gt;&gt; bx &gt;&gt; by;</span></span><br><span class="line"><span class="comment">//A(M, vec(M))是vector的组合，就是一个vector中的数据是vector&lt;int&gt;,每个vector&lt;int&gt;存储整数值，可以理解为一个二维数组</span></span><br><span class="line"><span class="comment">//vec中存储vec1,vec2,vec3,vec4, 而vec1中存储1, 2, 3, 4</span></span><br><span class="line"><span class="comment">//vec: vec1  vec2  vec3  vec4</span></span><br><span class="line"><span class="comment">//     1     1     1     1</span></span><br><span class="line"><span class="comment">//     2     2     2     2</span></span><br><span class="line"><span class="comment">//     3     3     3     3</span></span><br><span class="line"><span class="comment">//     4     4     4     4</span></span><br><span class="line"><span class="comment">mat A(M, vec(M)), B(M, vec(M));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">for(int i = 0; i &lt; ax; i++)</span></span><br><span class="line"><span class="comment">for(int j = 0; j &lt; ay; j++)</span></span><br><span class="line"><span class="comment">cin &gt;&gt; A[i][j];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">for(int i = 0; i &lt; bx; i++)</span></span><br><span class="line"><span class="comment">for(int j = 0; j &lt; by; j++)</span></span><br><span class="line"><span class="comment">cin &gt;&gt; B[i][j];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">mat C = mul(A, B);</span></span><br><span class="line"><span class="comment">for(int i = 0; i &lt; ax; i++)&#123;</span></span><br><span class="line"><span class="comment">for(int j = 0; j &lt; by; j++)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; C[i][j] &lt;&lt; " ";</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* // 求矩阵Ａ的ｍ次方</span></span><br><span class="line"><span class="comment">int n, m;</span></span><br><span class="line"><span class="comment">cin &gt;&gt; n &gt;&gt; m;   //ｎ为矩阵的阶，ｍ为幂次</span></span><br><span class="line"><span class="comment">mat A(M, vec(M));</span></span><br><span class="line"><span class="comment">for(int i = 0; i &lt; n; i++)</span></span><br><span class="line"><span class="comment">for(int j = 0; j &lt; n; j++)</span></span><br><span class="line"><span class="comment">cin &gt;&gt; A[i][j];</span></span><br><span class="line"><span class="comment">mat B = pow(A, m);</span></span><br><span class="line"><span class="comment">for(int i = 0; i &lt; n; i++)&#123;</span></span><br><span class="line"><span class="comment">for(int j = 0; j &lt; n; j++)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; B[i][j] &lt;&lt; " ";</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//求斐波那切数列</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">Fibonacci(n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; 利用矩阵快速幂求斐波那切数列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; F[i] = 1 * F[i - 1] + 1 * F[i - 2] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; F[i - 1] = 1 * F[i - 1] + 0 * F[i - 2];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; -       -    -   -     -        -&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  F[i]	  | =| 1 1 | * | F[n - 1] | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|F[i - 1] |  | 1 0 |   | F[n - 2] |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; -       -    -   -     -        - &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; -       -    -   - ^(n - 1) -    -&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  F[i]	  | =| 1 1 |        | F[1] | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|F[i - 1] |  | 1 0 |   *    | F[0] |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; -       -    -   -          -    - &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      -   -  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; A = | 1 1 |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     | 1 0 |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      -   - &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 也就是使用矩阵快速幂求出A的n - 1次方，F[1] = 1, F[0] = 0,求得的矩阵为A&amp;apos;(2 * 1)，数列第ｎ个的值为A&amp;apos;[0][0]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://gydjsz.github.io/2019/04/18/algorithm/7.%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>https://gydjsz.github.io/2019/04/18/algorithm/7.并查集/</id>
    <published>2019-04-18T06:47:45.332Z</published>
    <updated>2019-04-18T06:47:45.288Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[SIZE], height[SIZE];   <span class="comment">//father记录每个元素的上级，height记录等级</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;  </span><br><span class="line">father[i] = i;    <span class="comment">//初始时，每个元素的上司是自己</span></span><br><span class="line">height[i] = <span class="number">1</span>;    <span class="comment">//初始等级为1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> father[v] = father[v] == v ? v : find(father[v]);   <span class="comment">//找到元素的最高一级指挥官</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">x = find(x);</span><br><span class="line">y = find(y);</span><br><span class="line"><span class="keyword">if</span>(height[x] &lt; height[y])    <span class="comment">//把等级低的放等级高的下面</span></span><br><span class="line">father[x] =father[y];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">father[y] = x;               <span class="comment">// 如果后者等级高，那么将等级低的归自己管</span></span><br><span class="line"><span class="keyword">if</span>(height[x] == height[y])   <span class="comment">//如果两者等级相等，那么当把同等级的归自己管，而自己等级需+1</span></span><br><span class="line">height[x]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">init(n);   <span class="comment">//初始化等级</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;      <span class="comment">//输入有关联的两个人</span></span><br><span class="line">join(x, y);         <span class="comment">//加入到集合中来 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; find(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>埃氏筛法</title>
    <link href="https://gydjsz.github.io/2019/04/18/algorithm/8.%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%B3%95/"/>
    <id>https://gydjsz.github.io/2019/04/18/algorithm/8.埃氏筛法/</id>
    <published>2019-04-18T06:46:51.090Z</published>
    <updated>2019-04-18T06:46:51.058Z</updated>
    
    <content type="html"><![CDATA[<p> 埃氏筛法：首先用一张表把1～n的所有数表示出来，其中2是最小的素数，将表中所有2的倍数划去，表中剩余的最小数字为3，它不能被更小的数整除，因而它是素数，将3的倍数从表中划去，依次类推，就能枚举n以内的素数, 时间复杂度O(nlognlogn)<br><a id="more"></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[MAXSIZE];   <span class="comment">//存储n以内的素数</span></span><br><span class="line"><span class="keyword">bool</span> is_prime[MAXSIZE];   <span class="comment">//第i个数是否为素数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(is_prime, <span class="literal">true</span>, <span class="keyword">sizeof</span>(is_prime));</span><br><span class="line">is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(is_prime[i])&#123;</span><br><span class="line">prime[p++] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= n; j += i)</span><br><span class="line">is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> m = getPrime(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; prime[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 埃氏筛法：首先用一张表把1～n的所有数表示出来，其中2是最小的素数，将表中所有2的倍数划去，表中剩余的最小数字为3，它不能被更小的数整除，因而它是素数，将3的倍数从表中划去，依次类推，就能枚举n以内的素数, 时间复杂度O(nlognlogn)&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>快速幂</title>
    <link href="https://gydjsz.github.io/2019/04/18/algorithm/5.%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <id>https://gydjsz.github.io/2019/04/18/algorithm/5.快速幂/</id>
    <published>2019-04-18T06:38:38.966Z</published>
    <updated>2019-04-18T06:38:38.930Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x ^ n = ((x^2)^2)...</span><br><span class="line">x ^ n = x^(2^k1) * x^(2^k2)...</span><br><span class="line">x^22 = x^2 * x^4 * x^16</span><br><span class="line">x^21 = x * x^4 * 2^16  //21的二进制为10101，在１处进行res *= x;</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">10000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="function">ll <span class="title">fast_pow1</span><span class="params">(ll x, ll n)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(n &amp; <span class="number">1</span>)   <span class="comment">//n为奇数，如3,二进制为11, 末尾为１，11 &amp; 1 =&gt; 11 &amp; 01 =&gt; 1(true)，res = 1 * x,进行了n &gt;&gt;= 1操作后，最终n变为1, 1 &amp; 1 =&gt; 1, res = 2 * 4 = 8; n为偶数,if操作只有当n = 1时才执行</span></span><br><span class="line">res = res * x % MOD;   <span class="comment">//根据题意是否添加% MOD</span></span><br><span class="line">x = x * x % MOD;    <span class="comment">//根据题意是否添加% MOD</span></span><br><span class="line">n &gt;&gt;= <span class="number">1</span>;   <span class="comment">//右移操作，相当于除２</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function">ll <span class="title">fast_pow2</span><span class="params">(ll x, ll n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">ll res = fast_pow2(x * x, n / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(n &amp; <span class="number">1</span>)</span><br><span class="line">res = res * x;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fast_pow1(x, n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fast_pow2(x, n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;x ^ n = ((x^2)^2)...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x ^ n = x^(2^k1) * x^(2^k2)...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x^22 = x^2 * x^4 * x^16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x^21 = x * x^4 * 2^16  //21的二进制为10101，在１处进行res *= x;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>乘法逆元</title>
    <link href="https://gydjsz.github.io/2019/04/18/algorithm/4.%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"/>
    <id>https://gydjsz.github.io/2019/04/18/algorithm/4.乘法逆元/</id>
    <published>2019-04-18T06:36:41.841Z</published>
    <updated>2019-04-18T06:36:41.793Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* a * x = 1 (mod p)   x称为ａ关于１模p的乘法逆元,求x</span><br><span class="line"> *</span><br><span class="line"> * 方法一：扩展欧拉定理</span><br><span class="line"> * a * x = 1 (mod p)  =&gt; a * x + p * y = 1</span><br><span class="line"> * 利用扩展欧几里得法求得ｘ和ｙ，其中x为a关于１模ｐ乘法逆元</span><br><span class="line"> *</span><br><span class="line"> * 方法二：费马小定理</span><br><span class="line"> * 费马小定理：假如p是质数，且gcd(a,p)=1，那么 a^(p-1)≡ 1（mod p）  (p是质数)</span><br><span class="line"> *    a ^ (p - 1) = 1 (mod p)</span><br><span class="line"> * =&gt; a * a ^ (p - 2) = 1 (mod p)</span><br><span class="line"> * 令x = a^-1, x = a ^ (p - 2)(mod p)</span><br><span class="line"> * 利用快速幂求得x</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展欧几里得</span></span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">x = <span class="number">1</span>; </span><br><span class="line">y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">ll gcd = exgcd(b, a % b, y, x);</span><br><span class="line">y -= a / b * x;</span><br><span class="line"><span class="keyword">return</span> gcd;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll b)</span></span>&#123;</span><br><span class="line">ll d, x, y;</span><br><span class="line">d = exgcd(a, b, x, y);</span><br><span class="line"><span class="keyword">return</span>  d == <span class="number">1</span> ? (x + b) % b : <span class="number">-1</span>;  <span class="comment">//1.负数情况转为正, 2.必须满足互质，否则无逆元</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">powMod</span><span class="params">(ll a, ll b)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b &amp; <span class="number">1</span>)</span><br><span class="line">res = res * a % MOD;</span><br><span class="line">a = a * a % MOD;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll a;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">ll result = powMod(a, MOD - <span class="number">2</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">result = inv(a, MOD);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/* a * x = 1 (mod p)   x称为ａ关于１模p的乘法逆元,求x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 方法一：扩展欧拉定理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * a * x = 1 (mod p)  =&amp;gt; a * x + p * y = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 利用扩展欧几里得法求得ｘ和ｙ，其中x为a关于１模ｐ乘法逆元&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 方法二：费马小定理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 费马小定理：假如p是质数，且gcd(a,p)=1，那么 a^(p-1)≡ 1（mod p）  (p是质数)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *    a ^ (p - 1) = 1 (mod p)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * =&amp;gt; a * a ^ (p - 2) = 1 (mod p)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 令x = a^-1, x = a ^ (p - 2)(mod p)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 利用快速幂求得x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>最大公约数</title>
    <link href="https://gydjsz.github.io/2019/04/18/algorithm/2.%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"/>
    <id>https://gydjsz.github.io/2019/04/18/algorithm/2.最大公约数/</id>
    <published>2019-04-18T05:47:02.577Z</published>
    <updated>2019-04-18T05:47:02.497Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//辗转相除法</span><br><span class="line"> a = 6 b = 4</span><br><span class="line"> a - b * k = n</span><br><span class="line"> a % b = n</span><br><span class="line"> 6 - 4 * 1 = 2   gcd(b, a % b) =&gt; a = 4(b) b = 2(a % b)</span><br><span class="line"> 4 - 2 * 1 = 2   =&gt; a = 2 b = 2</span><br><span class="line"> 2 - 2 * 1 = 0   =&gt; a = 2 b = 0   当ｂ＝０时,得到最大公约数2</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll a, b;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">ll result = gcd(a, b);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//辗转相除法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; a = 6 b = 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; a - b * k = n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; a % b = n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 6 - 4 * 1 = 2   gcd(b, a % b) =&amp;gt; a = 4(b) b = 2(a % b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 4 - 2 * 1 = 2   =&amp;gt; a = 2 b = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 2 - 2 * 1 = 0   =&amp;gt; a = 2 b = 0   当ｂ＝０时,得到最大公约数2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>扩展欧几里得</title>
    <link href="https://gydjsz.github.io/2019/04/18/algorithm/3.%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
    <id>https://gydjsz.github.io/2019/04/18/algorithm/3.扩展欧几里得算法/</id>
    <published>2019-04-18T05:46:52.881Z</published>
    <updated>2019-04-18T05:46:52.841Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">当b = 0时，gcd(a, b) = a, 此时x = 1, y = 0</span><br><span class="line">当a &gt; b时，设a * x1 + b * y1 = gcd(a, b);</span><br><span class="line">             b * x2 + (a % b) * y2 = gcd(b, a % b);</span><br><span class="line">gcd(a, b) = gcd(b, a % b);</span><br><span class="line">所以a * x1 + b * y1 = b * x2 + (a % b) * y2;</span><br><span class="line">=&gt; a * x1 + b * y1 = b * x2 + (a - [a / b] * b) * y2;   []表示取整</span><br><span class="line">=&gt; a * x1 + b * y1 = a * y2 + b * (x2 - [a / b] * y2);</span><br><span class="line">=&gt; x1 = y2,  y1 = x2 - [a / b] * y2</span><br><span class="line"></span><br><span class="line">此时得出x1和y1的值基于x2和y2,因而可以将每次a * x2 + b * y2 = gcd(b, a % b)的x2、y2的值代入求得x1和y1, 多次递归后b = 0，x = 1, y = 0,　最终求得x和y的值，即a * x + b * y = gcd(a, b) 的方程组的解</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>)&#123;   <span class="comment">//当ｂ的值为０时的x = 1, y = 0</span></span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line">y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> gcd = exgcd(b, a % b, y, x);   <span class="comment">//求得最小公约数的值</span></span><br><span class="line"><span class="comment">//将每一次gcd得到的x2 和 y2用公式x1 = y2, y1 = x2 - a / b * y2求得x1和y1</span></span><br><span class="line">y -= a / b * x;</span><br><span class="line"><span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b, x, y;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; exgcd(a, b, x, y) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//最大公约数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//求得的一种解</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;当b = 0时，gcd(a, b) = a, 此时x = 1, y = 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当a &amp;gt; b时，设a * x1 + b * y1 = gcd(a, b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             b * x2 + (a % b) * y2 = gcd(b, a % b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gcd(a, b) = gcd(b, a % b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;所以a * x1 + b * y1 = b * x2 + (a % b) * y2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;=&amp;gt; a * x1 + b * y1 = b * x2 + (a - [a / b] * b) * y2;   []表示取整&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;=&amp;gt; a * x1 + b * y1 = a * y2 + b * (x2 - [a / b] * y2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;=&amp;gt; x1 = y2,  y1 = x2 - [a / b] * y2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;此时得出x1和y1的值基于x2和y2,因而可以将每次a * x2 + b * y2 = gcd(b, a % b)的x2、y2的值代入求得x1和y1, 多次递归后b = 0，x = 1, y = 0,　最终求得x和y的值，即a * x + b * y = gcd(a, b) 的方程组的解&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>枚举n个数的排列</title>
    <link href="https://gydjsz.github.io/2019/04/18/algorithm/1.%E6%9E%9A%E4%B8%BEn%E4%B8%AA%E6%95%B0%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <id>https://gydjsz.github.io/2019/04/18/algorithm/1.枚举n个数的排列/</id>
    <published>2019-04-18T05:43:42.066Z</published>
    <updated>2019-04-18T05:43:42.022Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int swap(int &amp;a, int &amp;b)&#123;   //交换数组中两个元素位置</span><br><span class="line">int t = a;</span><br><span class="line">a = b;</span><br><span class="line">b = t;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int permutation(int k, int n, int perm[])&#123;</span><br><span class="line">if(k == n - 1)&#123;</span><br><span class="line">for(int i = 0; i &lt; n; i++)   //输出一个排列</span><br><span class="line">cout &lt;&lt; perm[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = k; i &lt; n; i++)&#123;</span><br><span class="line">if(i != k &amp;&amp; perm[i] == perm[k]) continue;    //除本身外，如果交换的两个数相同，则跳过</span><br><span class="line">swap(perm[i], perm[k]);   </span><br><span class="line">permutation(k + 1, n, perm);   //递归进行排列</span><br><span class="line">swap(perm[i], perm[k]);        //恢复原来的位置</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">int a[n];</span><br><span class="line">for(int i = 0; i &lt; n; i++)</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">permutation(0, n, a);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vim配置</title>
    <link href="https://gydjsz.github.io/2019/04/18/LearnVim/vimrc/"/>
    <id>https://gydjsz.github.io/2019/04/18/LearnVim/vimrc/</id>
    <published>2019-04-18T05:41:25.201Z</published>
    <updated>2019-04-18T05:41:25.157Z</updated>
    
    <content type="html"><![CDATA[<p>“ —————————– Vundle Start —————————–<br>set nocompatible<br>filetype off<br>set rtp+=~/.vim/bundle/Vundle.vim<br>call vundle#begin()<br>“插件管理<br>Plugin ‘VundleVim/Vundle.vim’<br>“目录树<br>Plugin ‘The-NERD-tree’<br>“代码补全<br>Bundle ‘Valloric/YouCompleteMe’<br>“异步语法检查<br>Plugin ‘w0rp/ale’<br>call vundle#end()<br>filetype plugin indent on<br>“ —————————– Vundle End   —————————–<br><a id="more"></a></p><p>“ 开启语法高亮<br>syntax on</p><p>“ 设置字体<br>set guifont=courier\ 20</p><p>“ 检测文件类型<br>filetype on</p><p>“ 设置取消备份，禁止临时文件生成<br>set nobackup<br>set noswapfile</p><p>“ 设置在Vim中可以使用鼠标，防止终端无法拷贝<br>set mouse=a</p><p>“ 显示当前行号和列号<br>set ruler</p><p>“ 在状态栏显示正在输入的命令<br>set showcmd</p><p>“ 总是显示状态栏(Powerline需要2行)<br>set laststatus=2</p><p>“ 显示行号<br>set number</p><p>“ 设置代码匹配,包括括号匹配情况<br>set showmatch</p><p>“ 设置C/C++方式自动对齐<br>set autoindent<br>set cindent<br>set smartindent</p><p>“ 设置tab宽度<br>set tabstop=4</p><p>“ 设置自动对齐空格数<br>set shiftwidth=4</p><p>“ 按退格键时可以一次删除4个空格<br>set softtabstop=4</p><p>“ 自动补全配置让Vim补全菜单行为跟IDE一致<br>set completeopt=longest,menu</p><p>“ 增强模式中的命令行自动完成操作<br>set wildmenu</p><p>map <f5> :NERDTreeToggle<cr><br>“map <c-n> :NERDTreeToggle<cr><br>“ 显示行号<br>let NERDTreeShowLineNumbers=1<br>let NERDTreeAutoCenter=1<br>“ 是否显示隐藏文件<br>“let NERDTreeShowHidden=1<br>“ 设置宽度<br>let NERDTreeWinSize=30<br>“ 在终端启动vim时，共享NERDTree<br>let g:nerdtree_tabs_open_on_console_startup=1<br>“ 忽略一下文件的显示<br>let NERDTreeIgnore=[‘.pyc’,’~$’,’.swp’]<br>“ 显示书签列表<br>let NERDTreeShowBookmarks=1<br>let NERDTreeWinPos=1</cr></c-n></cr></f5></p><p>“ vim不指定具体文件打开是，自动使用nerdtree<br>“ autocmd StdinReadPre <em> let s:std_in=1<br>“autocmd VimEnter </em> if argc() == 0 &amp;&amp; !exists(“s:std_in”) | NERDTree |endif<br>“ 当vim打开一个目录时，nerdtree自动使用<br> autocmd StdinReadPre <em> let s:std_in=1<br> autocmd VimEnter </em> if argc() == 1 &amp;&amp; isdirectory(argv()[0]) &amp;&amp; !exists(“s:std_in”) | exe ‘NERDTree’ argv()[0] | wincmd p | ene | endif</p><p>“ 寻找全局配置文件<br>let g:ycm_global_ycm_extra_conf = ‘~/.vim/bundle/YouCompleteMe/cpp/ycm/.ycm_extra_conf.py’<br>“ 禁用syntastic来对python检查<br>let g:syntastic_ignore_files=[“.<em>.py$”]<br>“ 使用ctags生成的tags文件<br>let g:ycm_collect_identifiers_from_tag_files = 1<br>“ 开启语义补全<br>“ 修改对C语言的补全快捷键，默认是CTRL+space，修改为ALT+;未测出效果<br>“let g:ycm_key_invoke_completion = ‘&lt;M-;&gt;’<br>“ 设置转到定义处的快捷键为ALT+G，未测出效果<br>“nmap <m-g> :YcmCompleter GoToDefinitionElseDeclaration <c-r>=expand(“<cword>“)<cr><cr><br>“关键字补全<br>let g:ycm_seed_identifiers_with_syntax = 1<br>“ 在接受补全后不分裂出一个窗口显示接受的项<br>set completeopt-=preview<br>“ 让补全行为与一般的IDE一致<br>set completeopt=longest,menu<br>“ 不显示开启vim时检查ycm_extra_conf文件的信息<br>let g:ycm_confirm_extra_conf=0<br>“ 每次重新生成匹配项，禁止缓存匹配项<br>let g:ycm_cache_omnifunc=0<br>“ 在注释中也可以补全<br>let g:ycm_complete_in_comments=1<br>“ 输入第一个字符就开始补全<br>let g:ycm_min_num_of_chars_for_completion=1<br>“ 错误标识符<br>let g:ycm_error_symbol=’&gt;&gt;’<br>“ 警告标识符<br>let g:ycm_warning_symbol=’&gt;</cr></cr></cword></c-r></m-g></em>‘<br>“ 不查询ultisnips提供的代码模板补全，如果需要，设置成1即可<br> let g:ycm_use_ultisnips_completer=1<br>“</p><p>“ale<br>“始终开启标志列<br>let g:ale_sign_column_always = 1<br>let g:ale_set_highlights = 0<br>“自定义error和warning图标<br>let g:ale_sign_error = ‘✗’<br>let g:ale_sign_warning = ‘⚡’<br>“在vim自带的状态栏中整合ale<br>let g:ale_statusline_format = [‘✗ %d’, ‘⚡ %d’, ‘✔ OK’]<br>“显示Linter名称,出错或警告等相关信息<br>let g:ale_echo_msg_error_str = ‘E’<br>let g:ale_echo_msg_warning_str = ‘W’<br>let g:ale_echo_msg_format = ‘[%linter%] %s [%severity%]’<br>“普通模式下，sp前往上一个错误或警告，sn前往下一个错误或警告<br>nmap sp <plug>(ale_previous_wrap)<br>nmap sn <plug>(ale_next_wrap)</plug></plug></p><p>ab sp <a href="#0"><span id=" "></span></a></p><p>set autoindent</p><p>“按下F9进行编译运行<br>map <f9> :call CompileRunGcc() <cr><br>func! CompileRunGcc()<br>    silent exec “w”<br>    “    exec “!clear”<br>    “if &amp;filetype == ‘cpp’<br>    silent exec “!g++ %”<br>    exec “!./a.out”<br>    “elseif &amp;filetype == ‘java’<br>    “    exec “!javac %”<br>    “    exec “!java %&lt;”<br>    “endif<br>endfunc</cr></f9></p><p>imap &lt;c-]&gt; {<cr>}<c-o>O<left><right></right></left></c-o></cr></p><p>map <c-a> ggVG”+y</c-a></p><p>“inoremap ( ()<left><br>“inoremap [ []<left><br>“inoremap { {}<left><br>“inoremap “ “”<left><br>“inoremap ‘ ‘’<left></left></left></left></left></left></p><p>map <f2> :call SetTitle()<cr><br>func SetTitle()<br>let l = 0</cr></f2></p><p>“let l = l + 1 | call setline(l,’Author        :herongwei’)<br>“let l = l + 1 | call setline(l,’Created Time  :’.strftime(‘%c’))<br>“let l = l + 1 | call setline(l,’File Name     :’.expand(‘%’))<br>“let l = l + 1 | call setline(l,’’)</p><p>“let l = l + 1 | call setline(l,’#include <cstdio>‘)<br>let l = l + 1 | call setline(l,’#include <cstring>‘)<br>let l = l + 1 | call setline(l,’#include <iostream>‘)<br>let l = l + 1 | call setline(l,’#include <algorithm>‘)<br>“let l = l + 1 | call setline(l,’#include <vector>‘)<br>“let l = l + 1 | call setline(l,’#include <queue>‘)<br>“let l = l + 1 | call setline(l,’#include <set>‘)<br>“let l = l + 1 | call setline(l,’#include <map>‘)<br>“let l = l + 1 | call setline(l,’#include <cmath>‘)<br>“let l = l + 1 | call setline(l,’#include <cstdlib>‘)<br>“let l = l + 1 | call setline(l,’#include &lt;time.h&gt;’)<br>let l = l + 1 | call setline(l,’using namespace std;’)<br>let l = l + 1 | call setline(l, ‘’)<br>let l = l + 1 | call setline(l,’typedef long long ll;’)<br>let l = l + 1 | call setline(l, ‘’)<br>“let l = l + 1 | call setline(l,’const int maxn  = 1e5+233;’)<br>“let l = l + 1 | call setline(l,’const int MOD   = 1e9+7;’)<br>“let l = l + 1 | call setline(l,’const double eps= 1e-6;’)<br>“let l = l + 1 | call setline(l,’const double pi = acos(-1.0);’)<br>“let l = l + 1 | call setline(l,’int n,m,t,ans,res,tmp;  ‘)<br>let l = l + 1 | call setline(l,’int main(){‘)<br>“let l = l + 1 | call setline(l,’    //freopen(“in.txt”,”r”,stdin);’)<br>“let l = l + 1 | call setline(l,’    //freopen(“out.txt”,”w”,stdout);’)<br>let l = l + 1 | call setline(l,’    ‘)<br>let l = l + 1 | call setline(l,’    return 0;’)<br>let l = l + 1 | call setline(l,’}’)<br>endfunc</cstdlib></cmath></map></set></queue></vector></algorithm></iostream></cstring></cstdio></p><p>“空格键格式化当前行，并跳到下一行<br>imap <cr> <esc> == o</esc></cr></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“ —————————– Vundle Start —————————–&lt;br&gt;set nocompatible&lt;br&gt;filetype off&lt;br&gt;set rtp+=~/.vim/bundle/Vundle.vim&lt;br&gt;call vundle#begin()&lt;br&gt;“插件管理&lt;br&gt;Plugin ‘VundleVim/Vundle.vim’&lt;br&gt;“目录树&lt;br&gt;Plugin ‘The-NERD-tree’&lt;br&gt;“代码补全&lt;br&gt;Bundle ‘Valloric/YouCompleteMe’&lt;br&gt;“异步语法检查&lt;br&gt;Plugin ‘w0rp/ale’&lt;br&gt;call vundle#end()&lt;br&gt;filetype plugin indent on&lt;br&gt;“ —————————– Vundle End   —————————–&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>牛客网43的B题</title>
    <link href="https://gydjsz.github.io/2019/04/09/algorithm/nowcoderPractice43/"/>
    <id>https://gydjsz.github.io/2019/04/09/algorithm/nowcoderPractice43/</id>
    <published>2019-04-09T12:44:27.600Z</published>
    <updated>2019-04-09T12:44:27.564Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/contest/548/B" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/548/B</a><br>来源：牛客网</p><p>题目描述<br>立华奏在学习初中数学的时候遇到了这样一道大水题：<br>“设箱子内有 n 个球，其中给 m 个球打上标记，设一次摸球摸到每一个球的概率均等，求一次摸球摸到打标记的球的概率”<br>“emmm…语言入门题”<br>但是她改了一下询问方式：设最终的答案为 p ,请输出 p 小数点后K1到K2位的所有数字（若不足则用 0 补齐）<br>输入描述:<br>第一行一个整数 T,表示有 T 组数据。<br>接下来每行包含四个整数<br>m, n, K1, K2，<br>意义如「题目描述」所示。<br>输出描述:<br>输出 T 行，每行输出 K 2 − K 1 + 1 K2−K1+1 个数，表示答案。<br>注意同行的数字中间不需要用空格隔开。<br>示例1<br>输入<br>5 2 3 2 3<br>1 7 1 7<br>2 5 1 3<br>12345 54321 3 10<br>12345 54321 100000 100010<br>输出<br>66<br>1428571<br>400<br>72601756<br>78428232175<br>备注: 1&lt;=m&lt;=n&lt;=109, 1&lt;=K1&lt;=K2&lt;=109, 1&lt;=m&lt;=n&lt;=109,1&lt;=K1&lt;=K2&lt;=109 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/548/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/548/B&lt;/a&gt;&lt;br&gt;来源
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库使用笔记</title>
    <link href="https://gydjsz.github.io/2019/04/08/SQL/useSqlServer/"/>
    <id>https://gydjsz.github.io/2019/04/08/SQL/useSqlServer/</id>
    <published>2019-04-08T04:37:17.911Z</published>
    <updated>2019-04-08T04:37:17.871Z</updated>
    
    <content type="html"><![CDATA[<p>停止，启动，重启SQL server服务<br><a id="more"></a></p><p>命令：sudo systemctl stop mssql-server     或  service mssql-server stop</p><p>命令：sudo systemctl start mssql-server    或  service mssql-server start</p><p>命令：sudo systemctl restart mssql-server  或  service mssql-server restart </p><p>移除mssqlserver开机自动启动服务<br>update-rc.d -f mssql-server remove</p><ol><li><p>\ld : 查看所有数据库</p></li><li><p>\lt : 列出所有表</p></li><li><p>use Name : 使用Name数据库</p></li><li><p>CREATE TABLE Student : 创建Student表</p></li><li><p>INSERT INTO Student(Sno, Sage, Ssex) VALUES(1, 10, ‘男’); :插入数据，Student(Sno, Sage, Ssex)，省略括号中的内容，则默认为添加全部值，省略一部分，则为那部分值为空</p></li><li><p>SELECT * FROM INFORMATION_SCHEMA.columns WHERE TABLE_NAME=’表名’ : 获取表的字段名及类型</p></li><li><p>SELECT COLUMN_NAME,DATA_TYPE FROM INFORMATION_SCHEMA.columns WHERE TABLE_NAME=’Student’ : 查询表属性名和类型名</p></li><li><p>ALTER TABLE table_name ADD Sc CHAR(3); : 增加属性Sc<br>ALTER TABLE table_name DROP Sc;         : 删除属性Sc<br>ALTER TABLE table_name ADD COLUMN Sage INT; : 将Sage字符型改为整数<br>ALTER TABLE table_name ADD UNIQUE(Cname);  : 增加Cname必须取唯一值的约束条件</p></li><li><p>SELECT Sage Hello FROM Student; :显示Sage的别名Hello</p></li><li><p>SELECT 2019-Sage FROM Student; : 计算2019 - Sage之后的结果</p></li><li><p>SELECT DISTINCT Sno FROM Student; : 去除重复的行并查询<br>SELECT Sno FROM Student;  =  SELECT ALL Sno FROM Student; : 显示所有查询</p></li><li><p>比较：&lt;&gt; 不等于、!&gt; 不大于、!&lt; 不小于<br>确定范围：BETWEEN a AND b 属性在a~b之间的的元组、NOT BETWEEN a AND b<br>确定集合：IN, NOT IN<br>字符匹配：LIKE, NOT LIKE<br>空值：IS NULL, NOT NULL<br>多重条件：AND, OR, NOT</p></li></ol><ol start="12"><li><p>SELECT Sname FROM Student WHERE Sdept=’CS’; :显示Sdept=’CS’的Sname</p></li><li><p>SELECT Sname FROM Student WHERE Sage IN(‘10’, ‘20’);  :显示年龄为10和20的学生姓名</p></li><li><p>SELECT Sname FROM Student WHERE Sno LIKE’2%3’;  :查找学号以2开头3结尾的学生姓名<br>% :代表任意长度<br>_ :代表任意单个字符</p></li><li><p>SELECT * FROM Student ORDER BY Sno DESC;  :按Sno降序显示Student表(ASC为升序) </p></li><li><p>ALTER TABLE Course ADD FOREIGN KEY(Sno) REFERENCES Student(Sno);  :修改Course中的Sno为Student(Sno)外码</p></li></ol><p>从Excel文件中,导入数据到SQL数据库中,<br>     select * into 表 from<br> OPENROWSET(‘MICROSOFT.JET.OLEDB.4.0’<br> ,’Excel 5.0;HDR=YES;DATABASE=c:\test.xls’,sheet1$)</p><ol start="17"><li><p>YEAR(日期);  :获得日期的年份</p></li><li><p>ORDER BY []  ASC/DESC;  :升序/降序</p></li><li><p>SELECT TOP 10 PERCENT * FROM Student;  :查询前10%的数据</p></li><li><p>DATEDIFF(day, 起始日期, 终止日期);   :获得两时间差</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;停止，启动，重启SQL server服务&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux下的技巧操作</title>
    <link href="https://gydjsz.github.io/2019/03/27/Linux/linuxTip/"/>
    <id>https://gydjsz.github.io/2019/03/27/Linux/linuxTip/</id>
    <published>2019-03-27T11:06:30.496Z</published>
    <updated>2019-03-27T11:06:30.456Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、好用的工具"><a href="#一、好用的工具" class="headerlink" title="一、好用的工具"></a>一、好用的工具</h1><ol><li><p>autojump: 可以记录进入过的目录, 支持直接跳转到想到的目录<br>j path: 进入path目录<br>j: 进入权值最高的目录<br>j -i[权重]: 增加权值<br>j -d[权重]: 减少权值<br>jo path: 打开目录<br>j -s: 显示自动跳转数据库中的条目</p><a id="more"></a></li><li><p>xsel: 建立终端和剪切板之间的通道<br>cat txt | xsel -b -i: 将txt文件中的内容复制到xsel中<br>xsel &gt; txt: 将xsel中的内容复制到txt中<br>xsel -o -i: 查看xsel中的内容</p></li></ol><h1 id="二、一些操作"><a href="#二、一些操作" class="headerlink" title="二、一些操作"></a>二、一些操作</h1><ol><li><p>python版本切换<br>sudo update-alternatives –config python</p></li><li><p>使用清华源，提升pip下载速度<br>Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)</p></li></ol><p>内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure></p><ol start="3"><li>查看服务状态<br>service –status-all  查看所有的服务状态<br>service xx status     查看xx的服务状态</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、好用的工具&quot;&gt;&lt;a href=&quot;#一、好用的工具&quot; class=&quot;headerlink&quot; title=&quot;一、好用的工具&quot;&gt;&lt;/a&gt;一、好用的工具&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;autojump: 可以记录进入过的目录, 支持直接跳转到想到的目录&lt;br&gt;j path: 进入path目录&lt;br&gt;j: 进入权值最高的目录&lt;br&gt;j -i[权重]: 增加权值&lt;br&gt;j -d[权重]: 减少权值&lt;br&gt;jo path: 打开目录&lt;br&gt;j -s: 显示自动跳转数据库中的条目&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第九届蓝桥杯真题题解</title>
    <link href="https://gydjsz.github.io/2019/03/23/algorithm/lqb9/"/>
    <id>https://gydjsz.github.io/2019/03/23/algorithm/lqb9/</id>
    <published>2019-03-23T10:37:59.054Z</published>
    <updated>2019-03-23T10:37:58.806Z</updated>
    
    <content type="html"><![CDATA[<p><span id="0">目录：</span></p><ol><li><a href="#1">第几天</a></li><li><a href="#2">明码</a></li><li><a href="#3">乘积尾零</a></li><li><a href="#4">测试次数</a></li><li><a href="#5">快速排序</a></li><li><a href="#6">递增三元组</a></li><li><a href="#7">螺旋折线</a></li><li><a href="#8">日志统计</a></li><li><a href="#9">全球变暖</a></li><li><a href="#10">乘积最大</a></li></ol><a id="more"></a><p><a href="#0"><span id="1">1. 第几天</span></a> </p><p>2000年的1月1日，是那一年的第1天。<br>那么，2000年的5月4日，是那一年的第几天？</p><p><strong>解：<br>思路：Excel解决: 2000/5/4 - 2000/1/1 + 1 = 125<br>1,3: 31天、2: 29天、4: 30天、5: 4天  =&gt; 31 * 2 + 29 + 30 + 4 = 125</strong></p><p><strong>答案: 125</strong></p><hr><p><a href="#0"><span id="2">2.明码</span></a></p><p>汉字的字形存在于字库中，即便在今天，16点阵的字库也仍然使用广泛。<br>16点阵的字库把每个汉字看成是16x16个像素信息。并把这些信息记录在字节中。</p><p>一个字节可以存储8位信息，用32个字节就可以存一个汉字的字形了。<br>把每个字节转为2进制表示，1表示墨迹，0表示底色。每行2个字节，<br>一共16行，布局是：</p><pre><code>第1字节，第2字节第3字节，第4字节....第31字节, 第32字节</code></pre><p>这道题目是给你一段多个汉字组成的信息，每个汉字用32个字节表示，这里给出了字节作为有符号整数的值。</p><p>题目的要求隐藏在这些信息中。你的任务是复原这些汉字的字形，从中看出题目的要求，并根据要求填写答案。</p><p>这段信息是（一共10个汉字）：<br>4 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 0<br>16 64 16 64 34 68 127 126 66 -124 67 4 66 4 66 -124 126 100 66 36 66 4 66 4 66 4 126 4 66 40 0 16<br>4 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 0<br>0 -128 64 -128 48 -128 17 8 1 -4 2 8 8 80 16 64 32 64 -32 64 32 -96 32 -96 33 16 34 8 36 14 40 4<br>4 0 3 0 1 0 0 4 -1 -2 4 0 4 16 7 -8 4 16 4 16 4 16 8 16 8 16 16 16 32 -96 64 64<br>16 64 20 72 62 -4 73 32 5 16 1 0 63 -8 1 0 -1 -2 0 64 0 80 63 -8 8 64 4 64 1 64 0 -128<br>0 16 63 -8 1 0 1 0 1 0 1 4 -1 -2 1 0 1 0 1 0 1 0 1 0 1 0 1 0 5 0 2 0<br>2 0 2 0 7 -16 8 32 24 64 37 -128 2 -128 12 -128 113 -4 2 8 12 16 18 32 33 -64 1 0 14 0 112 0<br>1 0 1 0 1 0 9 32 9 16 17 12 17 4 33 16 65 16 1 32 1 64 0 -128 1 0 2 0 12 0 112 0<br>0 0 0 0 7 -16 24 24 48 12 56 12 0 56 0 -32 0 -64 0 -128 0 0 0 0 1 -128 3 -64 1 -128 0 0 </p><p>注意：需要提交的是一个整数，不要填写任何多余内容。</p><p><strong>解:<br>思路: 每行两个字节，每一个字节存储一个整数，可以先将整数转化为8位二进制，负数的二进制需要+2^n(这里n为8),然后用除k取余法求得整数对应的二进制，然后1输出 * , 0输出空格,每画完两个整数换行<br>最终输出为 九的九次方等于多少?</strong></p><p>代码1:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;   <span class="comment">//负数的二进制原码为2^n + x</span></span><br><span class="line">n += <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">8</span>], k = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="keyword">while</span>(n != <span class="number">0</span>)&#123;   <span class="comment">//除k取余法,余数最终要倒过来</span></span><br><span class="line">a[k--] = n % <span class="number">2</span>;</span><br><span class="line">n /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;   <span class="comment">//输出图形</span></span><br><span class="line"><span class="keyword">if</span>(a[i] == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"*"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++)&#123;</span><br><span class="line">fun();   <span class="comment">//两个整数为一行，就直接调用两次函数</span></span><br><span class="line">fun();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码2:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">bitset</span>&lt;8&gt; b(n);   <span class="comment">//创建一个数值为n的8位二进制数,从左到右是低位到高位</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = b.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(b[i] == <span class="number">0</span>)    <span class="comment">//直接下标访问</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"*"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++)&#123;</span><br><span class="line">fun();</span><br><span class="line">fun();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>答案: 387420489</strong></p><hr><p><a href="#0"><span id="3">3. 乘积尾零</span></a> </p><p>如下的10行数据，每行有10个整数，请你求出它们的乘积的末尾有多少个零？</p><p>5650 4542 3554 473 946 4114 3871 9073 90 4329<br>2758 7949 6113 5659 5245 7432 3051 4434 6704 3594<br>9937 1173 6866 3397 4759 7557 3070 2287 1453 9899<br>1486 5722 3135 1170 4014 5510 5120 729 2880 9019<br>2049 698 4582 4346 4427 646 9742 7340 1230 7683<br>5693 7015 6887 7381 4172 4341 2909 2027 7355 5649<br>6701 6645 1671 5978 2704 9926 295 3125 3878 6785<br>2066 4247 4800 1578 6652 4616 1113 6205 3264 2915<br>3966 5291 2904 1285 2193 1428 2265 8730 9436 7074<br>689 5510 8243 6114 337 4096 8199 7313 3685 211 </p><p>注意：需要提交的是一个整数，表示末尾零的个数。不要填写任何多余内容。</p><p><strong>解：<br>思路：由于2 * 5 = 10,因此直接求出所有数中2和5的个数，取最小的那个数就是0的个数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求能整除的2的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n % <span class="number">2</span> == <span class="number">0</span>)&#123;   <span class="comment">//不断除以2，直到该数不能被整除，求出的就是2的个数</span></span><br><span class="line">n /= <span class="number">2</span>;</span><br><span class="line">sum1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求能整除的5的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun5</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">n /= <span class="number">5</span>;</span><br><span class="line">sum1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum2 = <span class="number">0</span>, sum5 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">sum2 += fun2(n);</span><br><span class="line">sum5 += fun5(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m = min(sum2, sum5);    <span class="comment">//2和5的个数中最小的那个就是10的个数,也就是末尾为0的个数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#0"><span id="4">4. 测试次数</span></a></p><p>x星球的居民脾气不太好，但好在他们生气的时候唯一的异常举动是：摔手机。<br>各大厂商也就纷纷推出各种耐摔型手机。x星球的质监局规定了手机必须经过耐摔测试，并且评定出一个耐摔指数来，之后才允许上市流通。</p><p>x星球有很多高耸入云的高塔，刚好可以用来做耐摔测试。塔的每一层高度都是一样的，与地球上稍有不同的是，他们的第一层不是地面，而是相当于我们的2楼。</p><p>如果手机从第7层扔下去没摔坏，但第8层摔坏了，则手机耐摔指数=7。<br>特别地，如果手机从第1层扔下去就坏了，则耐摔指数=0。<br>如果到了塔的最高层第n层扔没摔坏，则耐摔指数=n</p><p>为了减少测试次数，从每个厂家抽样3部手机参加测试。</p><p>某次测试的塔高为1000层，如果我们总是采用最佳策略，在最坏的运气下最多需要测试多少次才能确定手机的耐摔指数呢？</p><p>请填写这个最多测试次数。</p><p>注意：需要填写的是一个整数，不要填写任何多余内容。</p><p><strong>解:<br>思路: 这是一道动态规划的题，设dp[i][j]表示i部, 耐摔指数为j的手机的测试次数，经过k次测试能够得出手机的耐摔指数，可以写出状态转移方程dp[i][j] = max(dp[i - 1][k - 1], dp[i][j - k]) + 1。dp[i - 1][k - 1]表示第i部手机摔坏了，这个时候手机数目-1，测试次数k-1，需要从k-1层测试才能保证测出耐摔指数(k - 1次机会，测试1 ~ k - 1层必定测出)，dp[i][j - k]表示第i部手机没有摔坏，这个时候就要测试k + 1 ~ j层，可以转化为测试1 ~ j - k层(这里只是层数的区间和高度无关)，由于是最坏的运气下的测试次数，所以取前面两者的最大测试次数+1就是这一次测试的次数(如果不取最大，那么最坏情况不能满足, +1是因为要加上这一次的测试)，经过最佳策略得出的测试次数应该小于等于每一层都摔手机的这个最大次数, 即取min(dp[i][j], max(dp[i - 1][k - 1], dp[i][j - k]) + 1)</strong></p><p><a href="https://blog.csdn.net/wolinxuebin/article/details/47057707" target="_blank" rel="noopener">N个鸡蛋从M楼层摔</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> phone = <span class="number">3</span>, house = <span class="number">1000</span>;  <span class="comment">//3部手机，1000层楼</span></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">5</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= phone; i++)&#123;   <span class="comment">//初始化dp为最坏的层数，也就是每一层都要试</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= house; j++)&#123;</span><br><span class="line">dp[i][j] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= phone; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= house; j++)&#123;   <span class="comment">//i部手机在j层楼的摔坏指数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; j; k++)    <span class="comment">//测试次数为k </span></span><br><span class="line"><span class="comment">//最优策略：1. 第i部手机摔坏, 假设前面已经求出摔坏指数，则摔坏指数为dp[i - 1][k - 1]; 2. 第i部手机没有摔坏，则摔坏指数为第i部手机在k + 1 ~ j中测试后得出的摔坏指数，k + 1 ~ j可以转化为1 ~ j - k, 即dp[i][j - k]</span></span><br><span class="line">dp[i][j] = min(dp[i][j], max(dp[i - <span class="number">1</span>][k - <span class="number">1</span>], dp[i][j - k]) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[<span class="number">3</span>][<span class="number">1000</span>] &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//由于是在层数增加的情况下在dp[i][j]得出测试次数k，那么无论层数多高，测试次数都是k,这里由于不知道j，取最高层就行</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>答案: 19</strong></p><hr><p><a href="#0"><span id="5">快速排序</span></a> </p><p>以下代码可以从数组a[]中找出第k小的元素。<br>它使用了类似快速排序中的分治算法，期望时间复杂度是O(N)的。<br>请仔细阅读分析源码，填写划线部分缺失的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_select</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = rand() % (r - l + <span class="number">1</span>) + l;</span><br><span class="line"><span class="keyword">int</span> x = a[p];</span><br><span class="line">&#123;<span class="keyword">int</span> t = a[p]; a[p] = a[r]; a[r] = t;&#125;</span><br><span class="line"><span class="keyword">int</span> i = l, j = r;</span><br><span class="line"><span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line"><span class="keyword">while</span>(i &lt; j &amp;&amp; a[i] &lt; x) i++;</span><br><span class="line"><span class="keyword">if</span>(i &lt; j) &#123;</span><br><span class="line">a[j] = a[i];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i &lt; j &amp;&amp; a[j] &gt; x) j--;</span><br><span class="line"><span class="keyword">if</span>(i &lt; j) &#123;</span><br><span class="line">a[i] = a[j];</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a[i] = x;</span><br><span class="line">p = i;</span><br><span class="line"><span class="keyword">if</span>(i - l + <span class="number">1</span> == k) <span class="keyword">return</span> a[i];</span><br><span class="line"><span class="keyword">if</span>(i - l + <span class="number">1</span> &lt; k) <span class="keyword">return</span> quick_select( _____________________________ ); <span class="comment">//填空</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> quick_select(a, l, i - <span class="number">1</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">23</span>, <span class="number">58</span>, <span class="number">16</span>, <span class="number">27</span>, <span class="number">55</span>, <span class="number">13</span>, <span class="number">26</span>, <span class="number">24</span>, <span class="number">12</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, quick_select(a, <span class="number">0</span>, <span class="number">14</span>, <span class="number">5</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解:<br>思路:首先观察代码，rand() % m是随机产生0 ~ m - 1的随机数，l为左边数的下标，r为右边数的下标, r - l + 1是[l, r]这个区间的长度也就是从这个区间从取出一个数a[p]赋值给x, 这里有个{int t = a[p]; a[p] = a[r]; a[r] = t;}交换操作，是因为循环中有两个if，如果没有这个操作，那么赋值操作会覆盖数据，例如1 2 3 4, 假设x = 3, 当a[i] = 3时, 不满足a[i] &lt; x跳出循环, 这个时候进入if，a[j] = 3, j–, 数组a中的数据为1 2 3 3, j = 3, 可以观察到数组中的4丢失了，所以预先把3放在最后就不会出现这种情况 =&gt; 1 2 4 3, 跳出循环时：1 2 4 4, 最后有个a[i] = x =&gt; 1 2 3 4<br>然后中间循环就是熟悉的快速排序的操作，将比x小的放在它左边，比x大的放在它右边，这样即使x左右两边的数是无序的，x也是第i - l + 1大，这样就比较i - l + 1这个下标和下标k的大小，如果相等，那么这个数就是第k小，如果小于k，那么就找[i + 1, r]区间内的第k - (i - l + 1)小(如果假设n = i - l + 1,a[n]是第n小，那么只要再往后找k - n个数，那么就找到了k =&gt; 1 2 n 4 5 k)，就是最终的结果，如果大于k,那么就找[l, i - 1]区间内的第k小</strong></p><p><strong>答案: a, i + 1, r, k - (i - l + 1)</strong></p><hr><p><a href="#0"><span id="6">6. 递增三元组</span></a> </p><p>给定三个整数数组<br>A = [A1, A2, … AN],<br>B = [B1, B2, … BN],<br>C = [C1, C2, … CN]，<br>请你统计有多少个三元组(i, j, k) 满足：</p><ol><li>1 &lt;= i, j, k &lt;= N</li><li>Ai &lt; Bj &lt; Ck</li></ol><p>【输入格式】<br>第一行包含一个整数N。<br>第二行包含N个整数A1, A2, … AN。<br>第三行包含N个整数B1, B2, … BN。<br>第四行包含N个整数C1, C2, … CN。</p><p>对于30%的数据，1 &lt;= N &lt;= 100<br>对于60%的数据，1 &lt;= N &lt;= 1000<br>对于100%的数据，1 &lt;= N &lt;= 100000 0 &lt;= Ai, Bi, Ci &lt;= 100000</p><p>【输出格式】<br>一个整数表示答案</p><p>【样例输入】<br>3<br>1 1 1<br>2 2 2<br>3 3 3</p><p>【样例输出】<br>27</p><p>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 256M<br>CPU消耗  &lt; 1000ms</p><p><strong>解:<br>思路: 先将三个数组中的数据排序，然后用查找a中有多少小于b的数，c中有多少大于b的数，然后求乘积就是b[i]情况下的组合数，最后将所有的组合数求和</strong><br><strong>这里可以用库函数upper__bound(a, a + n, k), (函数为二分查找, 效率logn), 表示从ａ数组中查询第一个大于k的数，并返回其地址，由于a是数组的首地址，我们用upper__bound(a, a + n, k) - a就可以求得小于b[i]的个数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100001</span>], b[<span class="number">100001</span>], c[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line"></span><br><span class="line">ll sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">ll s1 = upper_bound(a, a + n, b[i]) - a;   <span class="comment">//求出a数组中小于b[i]的个数</span></span><br><span class="line">ll s2 = n - (upper_bound(c, c + n, b[i]) - c);   <span class="comment">//求出c数组中大于b[i]的个数</span></span><br><span class="line">sum += s1 * s2;  <span class="comment">//求组合情况数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="#0"><span id="7">螺旋折线</span></a> </p><p>如图</p><p><img src="https://raw.githubusercontent.com/gydjsz/myAlgorithm/dev/lqb/9/9/7/p1.png" width="50%" height="50%"></p><p>所示的螺旋折线经过平面上所有整点恰好一次。<br>对于整点(X, Y)，我们定义它到原点的距离dis(X, Y)是从原点到(X, Y)的螺旋折线段的长度。  </p><p>例如dis(0, 1)=3, dis(-2, -1)=9  </p><p>给出整点坐标(X, Y)，你能计算出dis(X, Y)吗？</p><p>【输入格式】<br>X和Y  </p><p>对于40%的数据，-1000 &lt;= X, Y &lt;= 1000<br>对于70%的数据，-100000 &lt;= X， Y &lt;= 100000<br>对于100%的数据, -1000000000 &lt;= X, Y &lt;= 1000000000  </p><p>【输出格式】<br>输出dis(X, Y)  </p><p>【样例输入】<br>0 1</p><p>【样例输出】<br>3</p><p>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 256M<br>CPU消耗  &lt; 1000ms</p><p><strong>解:<br>思路: 先将左下角的一条边旋转90°，得到<br><img src="https://raw.githubusercontent.com/gydjsz/myAlgorithm/dev/lqb/9/9/1.png" width="50%" height="50%"><br>将输入的x和y比较大小，将大的数n作为最外层正方形的边，起点为(-n, -n), 计算(x, y)和(-n, -n)的距离d1 = x - n, d2 = y - n, 当y &gt; x时，点在左部和上部, 最外层的边数为d1 + d2 (也就是走过的边); 当y &lt; x时，点在右部和下部，最外层的边数为总边数8 * n - (d1 + d2)  (也就是总边减去没有经过的边),内层边为8 * 1, 8 * 2, 8 * 3, 8 * 4… =&gt; 8 * (n * (n - 1) / 2) =&gt; 4 * n * (n - 1), 最后求和sum + d</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll x, y;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">ll n = max(<span class="built_in">abs</span>(x), <span class="built_in">abs</span>(y));   <span class="comment">//求最大的那个值，作为外层正方形的边</span></span><br><span class="line">ll sum = <span class="number">4</span> * n * (n - <span class="number">1</span>);   <span class="comment">//计算内层所有正方形的边长</span></span><br><span class="line">ll tx = -n, ty = -n;    <span class="comment">//得到左下角的那个点</span></span><br><span class="line">ll d = <span class="number">0</span>, d1 = x - tx, d2 = y - ty;</span><br><span class="line"><span class="keyword">if</span>(y &gt; x)    <span class="comment">//在y - x &gt; 0的那一块，直接将x和y的相对距离相加</span></span><br><span class="line">d = d1 + d2;</span><br><span class="line"><span class="keyword">else</span>   <span class="comment">//在y - x &lt;= 0的那一块，直接用总数减去没有走的边</span></span><br><span class="line">d = <span class="number">8</span> * n - d1 - d2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum + d &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//最后求和</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="#0"><span id="8">8. 日志统计</span></a> </p><p>小明维护着一个程序员论坛。现在他收集了一份”点赞”日志，日志共有N行。其中每一行的格式是：</p><p>ts id</p><p>表示在ts时刻编号id的帖子收到一个”赞”。</p><p>现在小明想统计有哪些帖子曾经是”热帖”。如果一个帖子曾在任意一个长度为D的时间段内收到不少于K个赞，小明就认为这个帖子曾是”热帖”。</p><p>具体来说，如果存在某个时刻T满足该帖在[T ,T + D)这段时间内(注意是左闭右开区间)收到不少于K个赞，该帖就曾是”热帖”。</p><p>给定日志，请你帮助小明统计出所有曾是”热帖”的帖子编号。</p><p>【输入格式】<br>第一行包含三个整数N、D和K。<br>以下N行每行一条日志，包含两个整数ts和id。</p><p>对于50%的数据，1 &lt;= K &lt;= N &lt;= 1000<br>对于100%的数据，1 &lt;= K &lt;= N &lt;= 100000 0 &lt;= ts &lt;= 100000 0 &lt;= id &lt;= 100000</p><p>【输出格式】<br>按从小到大的顺序输出热帖id。每个id一行。</p><p>【输入样例】<br>7 10 2<br>0 1<br>0 10<br>10 10<br>10 1<br>9 1<br>100 3<br>100 3</p><p>【输出样例】<br>1<br>3</p><p>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 256M<br>CPU消耗  &lt; 1000ms</p><p><a href="https://blog.csdn.net/qq_34202873/article/details/79835686" target="_blank" rel="noopener">https://blog.csdn.net/qq_34202873/article/details/79835686</a></p><hr><p><a href="#0"><span id="9">全球变暖</span></a> </p><p>你有一张某海域NxN像素的照片，”.”表示海洋、”#”表示陆地，如下所示：</p><p>…….<br>.##….<br>.##….<br>….##.<br>..####.<br>…###.<br>…….</p><p>其中”上下左右”四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有2座岛屿。</p><p>由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。</p><p>例如上图中的海域未来会变成如下样子：</p><p>…….<br>…….<br>…….<br>…….<br>….#..<br>…….<br>…….</p><p>请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。</p><p>【输入格式】<br>第一行包含一个整数N。  (1 &lt;= N &lt;= 1000)<br>以下N行N列代表一张海域照片。</p><p>照片保证第1行、第1列、第N行、第N列的像素都是海洋。</p><p>【输出格式】<br>一个整数表示答案。</p><p>【输入样例】<br>7<br>…….<br>.##….<br>.##….<br>….##.<br>..####.<br>…###.<br>…….</p><p>【输出样例】<br>1</p><p>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 256;M<br>CPU消耗  &lt; 1000ms</p><p><a href="https://blog.csdn.net/holly_Z_P_F/article/details/88727693" target="_blank" rel="noopener">https://blog.csdn.net/holly_Z_P_F/article/details/88727693</a></p><hr><p><a href="#0"><span id="10">乘积最大</span></a> </p><p>给定N个整数A1, A2, … AN。请你从中选出K个数，使其乘积最大。  </p><p>请你求出最大的乘积，由于乘积可能超出整型范围，你只需输出乘积除以1000000009的余数。  </p><p>注意，如果X&lt;0， 我们定义X除以1000000009的余数是负(-X)除以1000000009的余数。<br>即：0-((0-x) % 1000000009)</p><p>【输入格式】<br>第一行包含两个整数N和K。<br>以下N行每行一个整数Ai。  </p><p>对于40%的数据，1 &lt;= K &lt;= N &lt;= 100<br>对于60%的数据，1 &lt;= K &lt;= 1000<br>对于100%的数据，1 &lt;= K &lt;= N &lt;= 100000  -100000 &lt;= Ai &lt;= 100000  </p><p>【输出格式】<br>一个整数，表示答案。</p><p>【输入样例】<br>5 3<br>-100000<br>-10000<br>2<br>100000<br>10000  </p><p>【输出样例】<br>999100009</p><p>再例如：<br>【输入样例】<br>5 3<br>-100000<br>-100000<br>-2<br>-100000<br>-100000</p><p>【输出样例】<br>-999999829</p><p>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 256M<br>CPU消耗  &lt; 1000ms</p><p><a href="https://blog.csdn.net/qq_34202873/article/details/79835790" target="_blank" rel="noopener">https://blog.csdn.net/qq_34202873/article/details/79835790</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;span id=&quot;0&quot;&gt;目录：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;第几天&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2&quot;&gt;明码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3&quot;&gt;乘积尾零&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4&quot;&gt;测试次数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#5&quot;&gt;快速排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#6&quot;&gt;递增三元组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#7&quot;&gt;螺旋折线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#8&quot;&gt;日志统计&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#9&quot;&gt;全球变暖&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#10&quot;&gt;乘积最大&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第六届蓝桥杯真题解析</title>
    <link href="https://gydjsz.github.io/2019/03/20/algorithm/lqb6/"/>
    <id>https://gydjsz.github.io/2019/03/20/algorithm/lqb6/</id>
    <published>2019-03-20T10:53:11.097Z</published>
    <updated>2019-03-20T10:53:11.057Z</updated>
    
    <content type="html"><![CDATA[<ol><li><a href="https://www.ctguqmx.com/article/222" target="_blank" rel="noopener">启明星工作室解析</a></li></ol><p><span id="0">目录：</span></p><ol><li><a href="#1">奖券数目</a></li><li><a href="#2">星系炸弹</a></li><li><a href="#3">三羊献瑞</a></li><li><a href="#4">格子中输出</a></li><li><a href="#5">九数组分数</a></li><li><a href="#6">加法变乘法</a></li><li><a href="#7">牌型种数</a></li><li><a href="#8">移动距离</a></li><li><a href="#9">垒骰子</a></li><li><a href="#10">生命之树</a></li></ol><a id="more"></a><p><a href="#0"><span id="1">1. 奖券数目</span></a></p><p>有些人很迷信数字，比如带“4”的数字，认为和“死”谐音，就觉得不吉利。<br>虽然这些说法纯属无稽之谈，但有时还要迎合大众的需求。某抽奖活动的奖券号码是5位数（10000-99999），要求其中不要出现带“4”的号码，主办单位请你计算一下，如果任何两张奖券不重号，最多可发出奖券多少张。</p><p>请提交该数字（一个整数），不要写任何多余的内容或说明性文字。</p><p><strong>解:<br>思路:后四个数可选0 ~ 9除去4，共9个数，第一个数可选1 ~ 9除去4，共8个数，所有没有4的总数为：<br>8 <em> 9 </em> 9 <em> 9 </em> 9 = 52488</strong></p><p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">10000</span>; i &lt;= <span class="number">99999</span>; i++)&#123;</span><br><span class="line">s = to_string(i);</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; s.length(); j++)</span><br><span class="line"><span class="keyword">if</span>(s[j] == <span class="string">'4'</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(j == s.length())</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>答案: 52488</strong></p><hr><p><a href="#0"><span id="2">2. 星系炸弹</span></a></p><p>在X星系的广袤空间中漂浮着许多X星人造“炸弹”，用来作为宇宙中的路标。每个炸弹都可以设定多少天之后爆炸。比如：阿尔法炸弹2015年1月1日放置，定时为15天，则它在2015年1月16日爆炸。有一个贝塔炸弹，2014年11月9日放置，定时为1000天，请你计算它爆炸的准确日期。请填写该日期，格式为 yyyy-mm-dd  即4位年份2位月份2位日期。比如：2015-02-19  请严格按照格式书写。不能出现其它文字或符号。 </p><p><strong>解：<br>思路：先算完2014年的天数，11月30天，12月31天，那么还剩30 + 31 - 9 = 52天，定时变为1000 - 52 = 948天，2015为365天，2016为366天，2017为365天，算上2015和2016的，定时变为948 - 365 - 366 = 217天，2017年1~6月31,28,31,30,31,30,31共212天，定时变为217 - 212 = 5天，7月再过5天，爆炸，日期为2017-08-05</strong></p><p><strong>答案：2017-08-05</strong></p><hr><p><a href="#0"><span id="3">3. 三羊献瑞</span></a></p><p>观察下面的加法算式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      祥 瑞 生 辉</span><br><span class="line">  +   三 羊 献 瑞</span><br><span class="line">-------------------</span><br><span class="line">   三 羊 生 瑞 气</span><br></pre></td></tr></table></figure></p><p>其中，相同的汉字代表相同的数字，不同的汉字代表不同的数字。</p><p>请你填写“三羊献瑞”所代表的4位数字（答案唯一），不要填写任何多余内容。</p><p><strong>解：<br>思路：先观察这个等式，易得’三’表示的数字为1，因为10进制进位为1，祥所代表的数必定大于７，如果为7，那么7 + 1 = 8，而’瑞’＋’羊’进位不可能为2, ‘祥’所代表的数就为8或者9，如果为８，那么发生进位，’祥’ + ‘三’ = 10,那么’羊’为0，而一个一位数加上０不可能进位，所以’祥’为９，’羊’为０，此时得到祥(9), 三(1), 羊(0),因为’瑞’ + ‘羊’(0) = 生，’瑞’ != ‘羊’，所以发生进位，’瑞’ + 1 = ‘生’, ‘生’ + ‘献’ = ‘瑞’，即’瑞’ + 1 + ‘献’ = ‘瑞’ + 10，’献’ = 9，发生冲突(祥为９)，所以’’辉’＋’瑞’必定发生进位，’献’为８，然后将’瑞’从２开始取，一个个试，’瑞’(2), ‘辉’ 取８或９，矛盾;’瑞’(3),’辉’取７或８或９,矛盾;最终，’瑞’(5),’辉’(7),’生’(4)满足,此时’祥’(9),’瑞’(5),’生’(4),’辉’(7),’三’(1),’羊’(0),’献’(8),’气’(2)</strong></p><p>代码实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">a[i] = i;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="keyword">int</span> a0 = a[<span class="number">0</span>];   <span class="comment">//祥    </span></span><br><span class="line"> <span class="keyword">int</span> a1 = a[<span class="number">1</span>];   <span class="comment">//瑞</span></span><br><span class="line"><span class="keyword">int</span> a2 = a[<span class="number">2</span>];   <span class="comment">//生</span></span><br><span class="line"><span class="keyword">int</span> a3 = a[<span class="number">3</span>];   <span class="comment">//辉</span></span><br><span class="line"><span class="keyword">int</span> a4 = a[<span class="number">4</span>];   <span class="comment">//三</span></span><br><span class="line"><span class="keyword">int</span> a5 = a[<span class="number">5</span>];   <span class="comment">//羊  </span></span><br><span class="line"><span class="keyword">int</span> a6 = a[<span class="number">6</span>];   <span class="comment">//献</span></span><br><span class="line"><span class="keyword">int</span> a7 = a[<span class="number">7</span>];   <span class="comment">//气</span></span><br><span class="line"><span class="keyword">int</span> x1 = a0 * <span class="number">1000</span> + a1 * <span class="number">100</span> + a2 * <span class="number">10</span> + a3;</span><br><span class="line"><span class="keyword">int</span> x2 = a4 * <span class="number">1000</span> + a5 * <span class="number">100</span> + a6 * <span class="number">10</span> + a1;</span><br><span class="line"><span class="keyword">int</span> x3 = a4 * <span class="number">10000</span> + a5 * <span class="number">1000</span> + a2 * <span class="number">100</span> + a1 * <span class="number">10</span> + a7; </span><br><span class="line"><span class="keyword">if</span>(a0 != <span class="number">0</span> &amp;&amp; a4 != <span class="number">0</span> &amp;&amp; x1 + x2 == x3)   <span class="comment">//最高位不能为0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a4 &lt;&lt; a5 &lt;&lt; a6 &lt;&lt; a1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">while</span>(next_permutation(a, a + <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>答案：1085</strong></p><hr><p><a href="#0"><span id="4">4. 格子中输出</span></a></p><p>StringInGrid函数会在一个指定大小的格子中打印指定的字符串。<br>要求字符串在水平、垂直两个方向上都居中。<br>如果字符串太长，就截断。<br>如果不能恰好居中，可以稍稍偏左或者偏上一点。</p><p>下面的程序实现这个逻辑，请填写划线部分缺少的代码。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StringInGrid</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,k;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1000</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(buf, s);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(s)&gt;width<span class="number">-2</span>) buf[width<span class="number">-2</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"+"</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;width<span class="number">-2</span>;i++) <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"+\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>; k&lt;(height<span class="number">-1</span>)/<span class="number">2</span>;k++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"|"</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;width<span class="number">-2</span>;i++) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"|\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"|"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%*s%s%*s"</span>,_____________________________________________);  <span class="comment">//填空</span></span><br><span class="line">          </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"|\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(k=(height<span class="number">-1</span>)/<span class="number">2</span>+<span class="number">1</span>; k&lt;height<span class="number">-1</span>; k++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"|"</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;width<span class="number">-2</span>;i++) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"|\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"+"</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;width<span class="number">-2</span>;i++) <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"+\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">StringInGrid(<span class="number">20</span>,<span class="number">6</span>,<span class="string">"abcd1234"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">对于题目中数据，应该输出：</span><br><span class="line">+------------------+</span><br><span class="line">|                  |</span><br><span class="line">|     abcd1234     |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure><p>注意：只填写缺少的内容，不要书写任何题面已有代码或说明性文字。</p><p>解：<br>思路：观察代码(或者先将要填的地方注释，然后运行一遍程序)结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+------------------+</span><br><span class="line">|                  |</span><br><span class="line">||</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+,</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">发现要填的地方其实是要在恰当的地方输出这个这个字符，框框之类的已经帮我们写好了，</span><br><span class="line">观察printf(&quot;%*s%s%*s&quot;,  ),首先要了解%*s是什么，这个printf(&quot;%*s&quot;, 10, s) 意思是输出字符串s，</span><br><span class="line">但至少占10个位置，不足的在字符串s左边补空格，这里等同于printf(&quot;%10s&quot;, s)  这样就明白了，</span><br><span class="line">%s应该是要输出字符串，%*s是要输出空格，多少空格呢，若要让字符串居中，那么空格个数为</span><br><span class="line">(width - strlen(s) - 2) / 2, 左右两边空格一样，那么就先算出总共有多少空格然后除以２就ｏｋ，所以结果就是</span><br><span class="line">printf(&quot;%*s%s%*s&quot;, (width - strlen(s) - 2) / 2, buf, (width - strlen(s) - 1) / 2); </span><br><span class="line">这里中间为buf,因为题目中说明了超出界限的字符串要去掉，而代码中有buf[width - 2] = 0这个操作，</span><br><span class="line">说明输出的是ｂｕｆ,这里需要注意奇偶性问题，如果width为奇数，那么就要多一个空格，</span><br><span class="line">所以后面的宽度需要加上１再除２,即奇数多１，补上1再除２，就添了１，偶数＋1，除２，1 / 2值为０。</span><br></pre></td></tr></table></figure><p><strong>答案：(width - strlen(s) - 2) / 2, buf, (width - strlen(s) - 1) / 2</strong></p><hr><p><a href="#0"><span id="5">5. 九数组分数</span></a></p><p>1,2,3…9 这九个数字组成一个分数，其值恰好为1/3，如何组法？</p><p>下面的程序实现了该功能，请填写划线部分缺失的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = x[<span class="number">0</span>]*<span class="number">1000</span> + x[<span class="number">1</span>]*<span class="number">100</span> + x[<span class="number">2</span>]*<span class="number">10</span> + x[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> b = x[<span class="number">4</span>]*<span class="number">10000</span> + x[<span class="number">5</span>]*<span class="number">1000</span> + x[<span class="number">6</span>]*<span class="number">100</span> + x[<span class="number">7</span>]*<span class="number">10</span> + x[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a*<span class="number">3</span>==b) <span class="built_in">printf</span>(<span class="string">"%d / %d\n"</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,t;</span><br><span class="line"><span class="keyword">if</span>(k&gt;=<span class="number">9</span>)&#123;</span><br><span class="line">test(x);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=k; i&lt;<span class="number">9</span>; i++)&#123;</span><br><span class="line">&#123;t=x[k]; x[k]=x[i]; x[i]=t;&#125;</span><br><span class="line">f(x,k+<span class="number">1</span>);</span><br><span class="line">_____________________________________________ <span class="comment">// 填空处</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">f(x,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：只填写缺少的内容，不要书写任何题面已有代码或说明性文字。</p><p><strong>解：<br>思路：观察代码，很明显地发现ｆ一个递归函数，从第一个数字开始，不断将数组数字进行交换，然后得出所有的情况，最后调用test()函数测试是否为1 / 3, 在一次递归完成后需要将数组内的数字位置还原，因而结果应该填{t=x[k]; x[k]=x[i]; x[i]=t;},也就是交换一遍之后再重复这个操作便可以还原位置</strong></p><p><strong>答案：{t=x[k]; x[k]=x[i]; x[i]=t;}</strong></p><hr><p><a href="#0"><span id="6">6. 加法变乘法</span></a></p><p>我们都知道：1+2+3+ … + 49 = 1225<br>现在要求你把其中两个不相邻的加号变成乘号，使得结果为2015</p><p>比如：<br>1+2+3+…+10<em>11+12+…+27</em>28+29+…+49 = 2015<br>就是符合要求的答案。</p><p>请你寻找另外一个可能的答案，并把位置靠前的那个乘号左边的数字提交（对于示例，就是提交10）。</p><p>注意：需要你提交的是一个整数，不要填写任何多余的内容。</p><p><strong>解：<br>思路：这题首先想到的就是一个个地试，因为已经告诉了一种情况，那么，左边的数字必然&gt;10,最右边的数字必然小于28,因为如果是&lt;10和大于28,由于后面的数字相乘之后太大，一定是超出2015的，因而只要尝试&gt;10&amp;&amp;&lt;28以内的就ｏｋ，尝试方法举例:<br>若是11 12 和 26 27，那么1125 - 11 - 12 - 26 - 27 + 11 <em> 12 + 26 </em> 27, 多次尝试之后得到16 17 24 25</strong></p><p>也可以写程序：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">49</span>];</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">1225</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">49</span>; i++)</span><br><span class="line">a[i] = i;</span><br><span class="line"><span class="keyword">int</span> i, j, p, q;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>, j = i + <span class="number">1</span>; i &lt;= <span class="number">46</span>; i++, j++)</span><br><span class="line"><span class="keyword">for</span>(p = i + <span class="number">2</span>, q = p + <span class="number">1</span>; p &lt;= <span class="number">48</span>; p++, q++)&#123;</span><br><span class="line"><span class="keyword">if</span>(sum - a[i] - a[j] - a[p] - a[q] + a[i] * a[j] + a[p] * a[q] == <span class="number">2015</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; j &lt;&lt; <span class="string">" "</span> &lt;&lt; p &lt;&lt; <span class="string">" "</span> &lt;&lt; q &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>答案：16</strong></p><hr><p><a href="#0"><span id="7">7. 牌型种数</span></a></p><p>小明被劫持到X赌城，被迫与其他3人玩牌。<br>一副扑克牌（去掉大小王牌，共52张），均匀发给4个人，每个人13张。<br>这时，小明脑子里突然冒出一个问题：<br>如果不考虑花色，只考虑点数，也不考虑自己得到的牌的先后顺序，自己手里能拿到的初始牌型组合一共有多少种呢？</p><p>请填写该整数，不要填写任何多余的内容或说明文字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;   <span class="comment">//count为情况总数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> poker, <span class="keyword">int</span> cnt)</span></span>&#123;   <span class="comment">//poker为点数, cnt为张数</span></span><br><span class="line"><span class="keyword">if</span>(poker &gt; <span class="number">13</span> || cnt &gt; <span class="number">13</span>)  <span class="comment">//点数或者张数大于１３，返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt == <span class="number">13</span>)&#123;     <span class="comment">//当张数满足１３时，算作一种取法</span></span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">dfs(poker + <span class="number">1</span>, cnt + i);   <span class="comment">//点数逐渐加１，取牌张数从０到４</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="#0"><span id="8">8. 移动距离</span></a></p><p>X星球居民小区的楼房全是一样的，并且按矩阵样式排列。其楼房的编号为1,2,3…<br>当排满一行时，从下一行相邻的楼往反方向排号。<br>比如：当小区排号宽度为6时，开始情形如下：</p><p>1  2  3  4  5  6<br>12 11 10 9  8  7<br>13 14 15 …..</p><p>我们的问题是：已知了两个楼号m和n，需要求出它们之间的最短移动距离（不能斜线方向移动）</p><p>输入为3个整数w m n，空格分开，都在1到10000范围内<br>w为排号宽度，m,n为待计算的楼号。<br>要求输出一个整数，表示m n 两楼间最短移动距离。</p><p>例如：<br>用户输入：<br>6 8 2<br>则，程序应该输出：<br>4</p><p>再例如：<br>用户输入：<br>4 7 20<br>则，程序应该输出：<br>5</p><p>资源约定：<br>峰值内存消耗 &lt; 256M<br>CPU消耗  &lt; 1000ms</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="comment">//计算所在行</span></span><br><span class="line"><span class="keyword">return</span> m % w == <span class="number">0</span> ? m / w : m / w + <span class="number">1</span>;   <span class="comment">//如果是中间的点，因为除不尽，所以需要＋１</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> w, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x % <span class="number">2</span> == <span class="number">0</span>)   <span class="comment">//能被２整除，数字从右往左排列</span></span><br><span class="line"><span class="comment">//(x - 1) * w 是上面有多少数字，m - (x - 1) * w是当前的位置,然后用ｗ减去这个位置再＋１，就是当前所在列 </span></span><br><span class="line"><span class="keyword">return</span> w - (m - (x - <span class="number">1</span>) * w) + <span class="number">1</span>;   </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> m - (x - <span class="number">1</span>) * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> w, m, n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; w &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">x1 = getX(w, m);</span><br><span class="line">x2 = getX(w, n);</span><br><span class="line">y1 = getY(x1, w, m);</span><br><span class="line">y2 = getY(x2, w, n);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">abs</span>(x1 - x2) + <span class="built_in">abs</span>(y1 - y2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="#0"><span id="9">9. 垒骰子</span></a></p><p>赌圣atm晚年迷恋上了垒骰子，就是把骰子一个垒在另一个上边，不能歪歪扭扭，要垒成方柱体。<br>经过长期观察，atm 发现了稳定骰子的奥秘：有些数字的面贴着会互相排斥！<br>我们先来规范一下骰子：1 的对面是 4，2 的对面是 5，3 的对面是 6。<br>假设有 m 组互斥现象，每组中的那两个数字的面紧贴在一起，骰子就不能稳定的垒起来。<br>atm想计算一下有多少种不同的可能的垒骰子方式。<br>两种垒骰子方式相同，当且仅当这两种方式中对应高度的骰子的对应数字的朝向都相同。<br>由于方案数可能过多，请输出模 10^9 + 7 的结果。</p><p>不要小看了 atm 的骰子数量哦～</p><p>「输入格式」<br>第一行两个整数 n m<br>n表示骰子数目<br>接下来 m 行，每行两个整数 a b ，表示 a 和 b 数字不能紧贴在一起。</p><p>「输出格式」<br>一行一个数，表示答案模 10^9 + 7 的结果。</p><p>「样例输入」<br>2 1<br>1 2</p><p>「样例输出」<br>544</p><p>「数据范围」<br>对于 30% 的数据：n &lt;= 5<br>对于 60% 的数据：n &lt;= 100<br>对于 100% 的数据：0 &lt; n &lt;= 10^9, m &lt;= 36</p><p>资源约定：<br>峰值内存消耗 &lt; 256M<br>CPU消耗  &lt; 2000ms</p><p><strong>解：<br>思路：矩阵X记录骰子是否选择，选择为０，不选为１，不能相贴合的面就为０，这里可以转化为顶面不满足的就为０，这样比较方便，比如1 2不能紧贴在一起，1的对面为4，2的对面为5, 那么如果1为顶面，那么下一个骰子的顶面就不能为5，这样相比前一个骰子看顶面，后一个骰子看底面的方法简单许多，然后矩阵A1 <em> A2就计算这两个骰子的所有匹配情况，A1[i][j]表示点数为i，顶面为j的方案总数，A2就是新加入的一个骰子，比如我现在前面的骰子的匹配情况是10，那么将每一个点数所代表的方案数再和一个骰子相乘，如果该骰子为０，表示有冲突，那么相乘之后就为０，就不加入进来，如果是１，那么就加入进来，假如情况为1 2 3 1 2 1, 一个骰子为1 1 1 1 0 1, 点数为１时:1 </em> 1 + 1 <em> 1 + 1 </em> 1 + 1 <em> 1 + 1 </em> 0 + 1 <em> 1,点数为２时2 </em> 1 + 1 <em> 1 + 1 </em> 1 + 1 <em> 1 + 2 </em> 0 + 1…就和矩阵相乘是一样的，令X那么先利用矩阵快速幂求An, An = An-1 * X, A1 = E(单位矩阵), An = X ^ (n - 1), 之后再将矩阵内的值全部加起来就是顶面方案的全部情况，最后再乘以4 ^ n,因为有四个面，面可以旋转，这个用快速幂求解，避免爆</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vec;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;vec&gt; mat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//矩阵连乘</span></span><br><span class="line"><span class="function">mat <span class="title">mul</span><span class="params">(mat &amp;A, mat &amp;B)</span></span>&#123;</span><br><span class="line"><span class="function">mat <span class="title">C</span><span class="params">(A.size(), vec(B[<span class="number">0</span>].size()))</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.size(); j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; B[<span class="number">0</span>].size(); k++)</span><br><span class="line">C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD;</span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//矩阵快速幂</span></span><br><span class="line"><span class="function">mat <span class="title">fast_pow1</span><span class="params">(mat &amp;A, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="function">mat <span class="title">B</span><span class="params">(A.size(), vec(A.size()))</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++)</span><br><span class="line">B[i][i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line"><span class="keyword">if</span>(n &amp; <span class="number">1</span>)</span><br><span class="line">B = mul(B, A);</span><br><span class="line">A = mul(A, A);</span><br><span class="line">n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速幂</span></span><br><span class="line"><span class="function">ll <span class="title">fast_pow2</span><span class="params">(ll x, ll n)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line"><span class="keyword">if</span>(n &amp; <span class="number">1</span>)</span><br><span class="line">res = res * x % MOD;</span><br><span class="line">x = x * x % MOD;</span><br><span class="line">n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="function">mat <span class="title">A</span><span class="params">(<span class="number">6</span>, vec(<span class="number">6</span>, <span class="number">1</span>))</span></span>;  <span class="comment">//６行６列，全部值初始化为１</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="comment">/** 从０开始计数,所以a - 1表示当前点,和(b + 2) % 6不相融，</span></span><br><span class="line"><span class="comment">  例如1 2, a - 1 = 0, (b + 2) % 6 = 4, 0为顶面时，下一个骰子的4不能为顶面，相当于１和５,</span></span><br><span class="line"><span class="comment">  当１为顶面时，２不能为底面，2为底面时，5就为顶面**/</span></span><br><span class="line">A[a - <span class="number">1</span>][(b + <span class="number">2</span>) % <span class="number">6</span>] = <span class="number">0</span>;  </span><br><span class="line">A[b - <span class="number">1</span>][(a + <span class="number">2</span>) % <span class="number">6</span>] = <span class="number">0</span>;  <span class="comment">//同理5为顶面时，下一个骰子的1不能为顶面</span></span><br><span class="line">&#125;</span><br><span class="line">mat C = fast_pow1(A, n - <span class="number">1</span>);   <span class="comment">//矩阵快速幂求An = X ^ (n - 1)</span></span><br><span class="line">ll sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; A.size(); j++)</span><br><span class="line">sum = (sum + C[i][j]) % MOD;    <span class="comment">//求矩阵的和</span></span><br><span class="line">sum = sum * fast_pow2(<span class="number">4</span>, n) % MOD;   <span class="comment">//快速幂求sum * (4 ^ n),四个面，ｎ个骰子情况数为4 ^ n</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="#0"><span id="10">10. 生命之树</span></a></p><p>在X森林里，上帝创建了生命之树。</p><p>他给每棵树的每个节点（叶子也称为一个节点）上，都标了一个整数，代表这个点的和谐值。<br>上帝要在这棵树内选出一个非空节点集S，使得对于S中的任意两个点a,b，都存在一个点列 {a, v1, v2, …, vk, b} 使得这个点列中的每个点都是S里面的元素，且序列中相邻两个点间有一条边相连。</p><p>在这个前提下，上帝要使得S中的点所对应的整数的和尽量大。<br>这个最大的和就是上帝给生命之树的评分。</p><p>经过atm的努力，他已经知道了上帝给每棵树上每个节点上的整数。但是由于 atm 不擅长计算，他不知道怎样有效的求评分。他需要你为他写一个程序来计算一棵树的分数。</p><p>「输入格式」<br>第一行一个整数 n 表示这棵树有 n 个节点。<br>第二行 n 个整数，依次表示每个节点的评分。<br>接下来 n-1 行，每行 2 个整数 u, v，表示存在一条 u 到 v 的边。由于这是一棵树，所以是不存在环的。</p><p>「输出格式」<br>输出一行一个数，表示上帝给这棵树的分数。</p><p>「样例输入」<br>5<br>1 -2 -3 4 5<br>4 2<br>3 1<br>1 2<br>2 5</p><p>「样例输出」<br>8</p><p>「数据范围」<br>对于 30% 的数据，n &lt;= 10<br>对于 100% 的数据，0 &lt; n &lt;= 10^5, 每个节点的评分的绝对值不超过 10^6 。</p><p>资源约定：<br>峰值内存消耗 &lt; 256M<br>CPU消耗  &lt; 3000ms</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, dp[MAX][<span class="number">2</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> father)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++)&#123;</span><br><span class="line"><span class="keyword">int</span> u = G[v][i];</span><br><span class="line"><span class="keyword">if</span>(u == father)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">dfs(u, v);</span><br><span class="line">dp[v][<span class="number">0</span>] = max(max(dp[u][<span class="number">0</span>], dp[u][<span class="number">1</span>]), dp[v][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span>(dp[u][<span class="number">1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">dp[v][<span class="number">1</span>] += dp[u][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; dp[i][<span class="number">1</span>];</span><br><span class="line">dp[i][<span class="number">0</span>] = -INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">G[v].push_back(u);</span><br><span class="line">G[u].push_back(v);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; max(dp[<span class="number">1</span>][<span class="number">0</span>], dp[<span class="number">1</span>][<span class="number">1</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ctguqmx.com/article/222&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;启明星工作室解析&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span id=&quot;0&quot;&gt;目录：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;奖券数目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2&quot;&gt;星系炸弹&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3&quot;&gt;三羊献瑞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4&quot;&gt;格子中输出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#5&quot;&gt;九数组分数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#6&quot;&gt;加法变乘法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#7&quot;&gt;牌型种数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#8&quot;&gt;移动距离&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#9&quot;&gt;垒骰子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#10&quot;&gt;生命之树&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第八届蓝桥杯真题解题报告</title>
    <link href="https://gydjsz.github.io/2019/03/19/algorithm/lqb8/"/>
    <id>https://gydjsz.github.io/2019/03/19/algorithm/lqb8/</id>
    <published>2019-03-19T11:18:06.553Z</published>
    <updated>2019-03-19T11:18:06.509Z</updated>
    
    <content type="html"><![CDATA[<p><span id="0">目录：</span></p><ol><li><a href="#1">购物单</a></li><li><a href="#2">等差素数列</a></li><li><a href="#3">承压计算</a></li><li><a href="#4">方格分割</a></li><li><a href="#5">取数位</a></li><li><a href="#6">最大公共子串</a></li><li><a href="#7">日期问题</a></li><li><a href="#8">包子凑数</a></li><li><a href="#9">分巧克力</a></li><li><a href="#10">k倍区间</a><a id="more"></a></li></ol><p><a href="#0"><span id="1">1. 购物单</span></a></p><p>小明刚刚找到工作，老板人很好，只是老板夫人很爱购物。老板忙的时候经常让小明帮忙到商场代为购物。小明很厌烦，但又不好推辞。</p><pre><code>这不，XX大促销又来了！老板夫人开出了长长的购物单，都是有打折优惠的。小明也有个怪癖，不到万不得已，从不刷卡，直接现金搞定。现在小明很心烦，请你帮他计算一下，需要从取款机上取多少现金，才能搞定这次购物。取款机只能提供100元面额的纸币。小明想尽可能少取些现金，够用就行了。你的任务是计算出，小明最少需要取多少现金。</code></pre><p>以下是让人头疼的购物单，为了保护隐私，物品名称被隐藏了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">-----------------</span><br><span class="line">****     180.90       88折</span><br><span class="line">****      10.25       65折</span><br><span class="line">****      56.14        9折</span><br><span class="line">****     104.65        9折</span><br><span class="line">****     100.30       88折</span><br><span class="line">****     297.15        半价</span><br><span class="line">****      26.75       65折</span><br><span class="line">****     130.62        半价</span><br><span class="line">****     240.28       58折</span><br><span class="line">****     270.62        8折</span><br><span class="line">****     115.87       88折</span><br><span class="line">****     247.34       95折</span><br><span class="line">****      73.21        9折</span><br><span class="line">****     101.00        半价</span><br><span class="line">****      79.54        半价</span><br><span class="line">****     278.44        7折</span><br><span class="line">****     199.26        半价</span><br><span class="line">****      12.97        9折</span><br><span class="line">****     166.30       78折</span><br><span class="line">****     125.50       58折</span><br><span class="line">****      84.98        9折</span><br><span class="line">****     113.35       68折</span><br><span class="line">****     166.57        半价</span><br><span class="line">****      42.56        9折</span><br><span class="line">****      81.90       95折</span><br><span class="line">****     131.78        8折</span><br><span class="line">****     255.89       78折</span><br><span class="line">****     109.17        9折</span><br><span class="line">****     146.69       68折</span><br><span class="line">****     139.33       65折</span><br><span class="line">****     141.16       78折</span><br><span class="line">****     154.74        8折</span><br><span class="line">****      59.42        8折</span><br><span class="line">****      85.44       68折</span><br><span class="line">****     293.70       88折</span><br><span class="line">****     261.79       65折</span><br><span class="line">****      11.30       88折</span><br><span class="line">****     268.27       58折</span><br><span class="line">****     128.29       88折</span><br><span class="line">****     251.03        8折</span><br><span class="line">****     208.39       75折</span><br><span class="line">****     128.88       75折</span><br><span class="line">****      62.06        9折</span><br><span class="line">****     225.87       75折</span><br><span class="line">****      12.89       75折</span><br><span class="line">****      34.28       75折</span><br><span class="line">****      62.16       58折</span><br><span class="line">****     129.12        半价</span><br><span class="line">****     218.37        半价</span><br><span class="line">****     289.69        8折</span><br><span class="line">--------------------</span><br></pre></td></tr></table></figure></p><p>需要说明的是，88折指的是按标价的88%计算，而8折是按80%计算，余者类推。<br>特别地，半价是按50%计算。<br>请提交小明要从取款机上提取的金额，单位是元。<br>答案是一个整数，类似4300的样子，结尾必然是00，不要填写任何多余的内容。</p><p>特别提醒：不许携带计算器入场，也不能打开手机。</p><p><strong>解：<br>思路：这题直接代码解决，先将数据处理一下，去除****和’折’字, 然后直接作为数据输入</strong></p><p><a href="https://www.cnblogs.com/ljmzzyk/p/6918364.html" target="_blank" rel="noopener">Excel解决办法</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> value, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> discount;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; value &amp;&amp; value != <span class="number">-1</span>)&#123;   <span class="comment">//输入-1结束</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; discount;</span><br><span class="line"><span class="keyword">if</span>(discount % <span class="number">10</span> == <span class="number">0</span>)    <span class="comment">//如果是8折、9折就换成80、90,便于后面计算</span></span><br><span class="line">discount *= <span class="number">10</span>;</span><br><span class="line">sum += value * discount / <span class="number">100</span>;  <span class="comment">//每一次折扣后的费用都加起来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a = sum / <span class="number">100</span>;   <span class="comment">//取出整百部分</span></span><br><span class="line"><span class="keyword">if</span>(sum - a * <span class="number">100</span> &gt; <span class="number">0</span>)    <span class="comment">//如果费用不是整百，那么a + 1，表示将整百部分+1, 4301=&gt;4400</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (a + <span class="number">1</span>) * <span class="number">100</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a * <span class="number">100</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>答案：9700</strong></p><hr><p><a href="#0"><span id="2">2. 等差素数列</span></a></p><p>2,3,5,7,11,13,….是素数序列。<br>类似：7,37,67,97,127,157 这样完全由素数组成的等差数列，叫等差素数数列。<br>上边的数列公差为30，长度为6。<br>2004年，格林与华人陶哲轩合作证明了：存在任意长度的素数等差数列。<br>这是数论领域一项惊人的成果！<br>有这一理论为基础，请你借助手中的计算机，满怀信心地搜索：<br>长度为10的等差素数列，其公差最小值是多少？<br>注意：需要提交的是一个整数，不要填写任何多余的内容和说明文字。</p><p><strong>解：<br>思路：暴力枚举每一个素数，每次得到一个素数，就从1-1000循环公差, 如果在该公差下的十个数都是素数，那么最小值就是该公差</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sushu</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;    <span class="comment">//求素数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">100000</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(sushu(i))&#123;   <span class="comment">//如果该数是素数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; <span class="number">1000</span>; j += <span class="number">2</span>)&#123;  <span class="comment">//素数的公差不可能为奇数，因为除2外的素数都是奇数，奇数+奇数=偶数</span></span><br><span class="line"><span class="keyword">int</span> p;</span><br><span class="line"><span class="keyword">for</span>(p = <span class="number">0</span>; p &lt; <span class="number">10</span>; p++)   <span class="comment">//在公差为j的情况下，遍历后面的10个数</span></span><br><span class="line"><span class="keyword">if</span>(!sushu(i + j * p))   <span class="comment">//如果某一个不是素数，则跳出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="number">10</span>)&#123;       <span class="comment">//10个数为素数，输出</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>答案：210</strong></p><hr><p><a href="#0"><span id="3">3. 承压计算</span></a></p><p>X星球的高科技实验室中整齐地堆放着某批珍贵金属原料。<br>每块金属原料的外形、尺寸完全一致，但重量不同。<br>金属材料被严格地堆放成金字塔形。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">                             7 </span><br><span class="line">                            5 8 </span><br><span class="line">                           7 8 8 </span><br><span class="line">                          9 2 7 2 </span><br><span class="line">                         8 1 4 9 1 </span><br><span class="line">                        8 1 8 8 4 1 </span><br><span class="line">                       7 9 6 1 4 5 4 </span><br><span class="line">                      5 6 5 5 6 9 5 6 </span><br><span class="line">                     5 5 4 7 9 3 5 5 1 </span><br><span class="line">                    7 5 7 9 7 4 7 3 3 1 </span><br><span class="line">                   4 6 4 5 5 8 8 3 2 4 3 </span><br><span class="line">                  1 1 3 3 1 6 6 5 5 4 4 2 </span><br><span class="line">                 9 9 9 2 1 9 1 9 2 9 5 7 9 </span><br><span class="line">                4 3 3 7 7 9 3 6 1 3 8 8 3 7 </span><br><span class="line">               3 6 8 1 5 3 9 5 8 3 8 1 8 3 3 </span><br><span class="line">              8 3 2 3 3 5 5 8 5 4 2 8 6 7 6 9 </span><br><span class="line">             8 1 8 1 8 4 6 2 2 1 7 9 4 2 3 3 4 </span><br><span class="line">            2 8 4 2 2 9 9 2 8 3 4 9 6 3 9 4 6 9 </span><br><span class="line">           7 9 7 4 9 7 6 6 2 8 9 4 1 8 1 7 2 1 6 </span><br><span class="line">          9 2 8 6 4 2 7 9 5 4 1 2 5 1 7 3 9 8 3 3 </span><br><span class="line">         5 2 1 6 7 9 3 2 8 9 5 5 6 6 6 2 1 8 7 9 9 </span><br><span class="line">        6 7 1 8 8 7 5 3 6 5 4 7 3 4 6 7 8 1 3 2 7 4 </span><br><span class="line">       2 2 6 3 5 3 4 9 2 4 5 7 6 6 3 2 7 2 4 8 5 5 4 </span><br><span class="line">      7 4 4 5 8 3 3 8 1 8 6 3 2 1 6 2 6 4 6 3 8 2 9 6 </span><br><span class="line">     1 2 4 1 3 3 5 3 4 9 6 3 8 6 5 9 1 5 3 2 6 8 8 5 3 </span><br><span class="line">    2 2 7 9 3 3 2 8 6 9 8 4 4 9 5 8 2 6 3 4 8 4 9 3 8 8 </span><br><span class="line">   7 7 7 9 7 5 2 7 9 2 5 1 9 2 6 5 3 9 3 5 7 3 5 4 2 8 9 </span><br><span class="line">  7 7 6 6 8 7 5 5 8 2 4 7 7 4 7 2 6 9 2 1 8 2 9 8 5 7 3 6 </span><br><span class="line"> 5 9 4 5 5 7 5 5 6 3 5 3 9 5 8 9 5 4 1 2 6 1 4 3 5 3 2 4 1 </span><br><span class="line">X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X</span><br></pre></td></tr></table></figure></p><p>其中的数字代表金属块的重量（计量单位较大）。<br>最下一层的X代表30台极高精度的电子秤。</p><p>假设每块原料的重量都十分精确地平均落在下方的两个金属块上，<br>最后，所有的金属块的重量都严格精确地平分落在最底层的电子秤上。<br>电子秤的计量单位很小，所以显示的数字很大。<br>工作人员发现，其中读数最小的电子秤的示数为：2086458231<br>请你推算出：读数最大的电子秤的示数为多少？<br>注意：需要提交的是一个整数，不要填写任何多余的内容。</p><p><strong>解：<br>思路：上面一个数字平均分到它下面的两个数字上，直接用二维数组存下所有数字，然后每一行的数字等于当前的数字加上它上面两个数字的一半</strong><br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1         1</span><br><span class="line"> 2 3    =&gt;  2 3 </span><br><span class="line">4 5 6       4 5 6</span><br></pre></td></tr></table></figure></p><p><strong>当上面的重量落下来的时候，第二行的2就变为2 + 1 / 2 = 2.5, 第三行的4就变为4 + 2.5 / 2<br>一直算到最后一行，取出最大和最小的两个数，那么读数最大的示数应为MAX * 2086458231 / MIN</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> a[<span class="number">31</span>][<span class="number">31</span>];</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">29</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">29</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">29</span>; j++)&#123;</span><br><span class="line">a[i][j] += a[i - <span class="number">1</span>][j - <span class="number">1</span>] / <span class="number">2</span> + a[i - <span class="number">1</span>][j] / <span class="number">2</span>;   <span class="comment">//下面一个数=正上的左边一个数/2+正上面的数/2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> MIN = <span class="number">9999999</span>, MAX = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++)&#123;</span><br><span class="line">a[<span class="number">30</span>][i] = a[<span class="number">29</span>][i - <span class="number">1</span>] / <span class="number">2</span> + a[<span class="number">29</span>][i] / <span class="number">2</span>;   <span class="comment">//求出第30行的X的数字</span></span><br><span class="line">MIN = min(MIN, a[<span class="number">30</span>][i]);    <span class="comment">//求出最小值</span></span><br><span class="line">MAX = max(MAX, a[<span class="number">30</span>][i]);    <span class="comment">//求出最大值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; MAX * <span class="number">2086458231</span> / MIN &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//fixed格式化输出，使其以小数形式输出</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>答案：72665192664</strong></p><hr><p><a href="#0"><span id="4">4. 方格分割</span></a></p><p>6x6的方格，沿着格子的边线剪开成两部分。<br>要求这两部分的形状完全相同。</p><p>如图：<img src="p1" alt="1"> <img src="p2" alt="2"> <img src="p3" alt="3"> 就是可行的分割法。</p><p>试计算：<br>包括这3种分法在内，一共有多少种不同的分割方法。<br>注意：旋转对称的属于同一种分割法。</p><p>请提交该整数，不要填写任何多余的内容或说明文字。</p><p><strong>解：<br>思路：由于剪开的两部分要完全相同，此时其一定关于中心对称，我们可以从(3, 3)开始出发，进行dfs遍历，由于dfs是连续找点的，所以找的格子一定是连在一起的，这就保证了可以分成两部分，在dfs遍历的时候同时对其对称的点作标记，这样旋转之后两部分就完全相同，因为旋转对称属于同一种，最终除以4，就是结果。</strong></p><p>dfs讲解：<a href="https://www.cnblogs.com/OctoptusLian/p/7429645.html" target="_blank" rel="noopener">https://www.cnblogs.com/OctoptusLian/p/7429645.html</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;                    <span class="comment">//存储方式</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[N + <span class="number">1</span>][N + <span class="number">1</span>];          <span class="comment">//存储走过的格子</span></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;                 <span class="comment">//定义行走方式</span></span><br><span class="line">            <span class="number">0</span>, <span class="number">1</span>, </span><br><span class="line">            <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">             <span class="number">0</span>, <span class="number">-1</span>,</span><br><span class="line">             <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">               &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span> || y == <span class="number">0</span> || x == N || y == N)&#123;    <span class="comment">//到达边界返回</span></span><br><span class="line">ans++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> tx = x + d[i][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> ty = y + d[i][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[tx][ty]) <span class="keyword">continue</span>;   <span class="comment">//如果已经走过，那么换一条路</span></span><br><span class="line"><span class="built_in">map</span>[tx][ty] = <span class="number">1</span>;           <span class="comment">//没走过，标记1</span></span><br><span class="line"><span class="built_in">map</span>[N - tx][N - ty] = <span class="number">1</span>;   <span class="comment">//对称的格子标记1</span></span><br><span class="line">dfs(tx, ty);               <span class="comment">//dfs继续遍历</span></span><br><span class="line"><span class="built_in">map</span>[tx][ty] = <span class="number">0</span>;           <span class="comment">//对路径进行还原</span></span><br><span class="line"><span class="built_in">map</span>[N - tx][N - ty] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">map</span>[N / <span class="number">2</span>][N / <span class="number">2</span>] = <span class="number">1</span>;   <span class="comment">//先从(3, 3)点开始走，先标记为1</span></span><br><span class="line">dfs(N / <span class="number">2</span>, N / <span class="number">2</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans / <span class="number">4</span> &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//除以重复的情况</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#0"><span id="5">5. 取数位</span></a></p><p>求1个整数的第k位数字有很多种方法。<br>以下的方法就是一种。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 求x用10进制表示时的数位长度 </span><br><span class="line">int len(int x)&#123;</span><br><span class="line">if(x&lt;10) return 1;</span><br><span class="line">return len(x/10)+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 取x的第k位数字</span><br><span class="line">int f(int x, int k)&#123;</span><br><span class="line">if(len(x)-k==0) return x%10;</span><br><span class="line">return _____________________;  //填空</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int x = 23574;</span><br><span class="line">printf(&quot;%d\n&quot;, f(x,3));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于题目中的测试数据，应该打印5。<br>请仔细分析源码，并补充划线部分所缺少的代码。<br>注意：只提交缺失的代码，不要填写任何已有内容或说明性的文字。</p><p><strong>解：<br>思路：观察代码，len()函数明显是求x的长度，题目中23574的长度为5，f()函数就是求第k位数字，第一个if就是当x的长度和k相等时，返回x % 10, 如果x = 574, k = 3, 那么第k为数字就为x % 10 = 4，这里不满足if的话，就直接return了，可以看出，这是一个递归函数，将x的长度不断减小，最终只剩下k位，最终取模即可，空格处应该填f(x / 10, k)</strong></p><p><strong>答案：f(x / 10, k)</strong></p><hr><p><a href="#0"><span id="6">6. 最大公共子串</span></a></p><p>最大公共子串长度问题就是：<br>求两个串的所有子串中能够匹配上的最大长度是多少。<br>比如：”abcdkkk” 和 “baabcdadabc”，<br>可以找到的最长的公共子串是”abcd”,所以最大公共子串长度为4。<br>下面的程序是采用矩阵法进行求解的，这对串的规模不大的情况还是比较有效的解法。<br>请分析该解法的思路，并补全划线部分缺失的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 256</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s1, <span class="keyword">const</span> <span class="keyword">char</span>* s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"><span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(s1);</span><br><span class="line"><span class="keyword">int</span> len2 = <span class="built_in">strlen</span>(s2);</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*N*N);</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=len1; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=len2; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s1[i<span class="number">-1</span>]==s2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">a[i][j] = __________________________;  <span class="comment">//填空</span></span><br><span class="line"><span class="keyword">if</span>(a[i][j] &gt; max) max = a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f(<span class="string">"abcdkkk"</span>, <span class="string">"baabcdadabc"</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：只提交缺少的代码，不要提交已有的代码和符号。也不要提交说明性文字。</p><p><strong>解：<br>思路：观察代码，两个循环+一个if，循环将s1中的每一个字母和s2中的每一个字母进行比较，s1中的第i个字符和s2中的字符相等，那么就将当前的这一次相等+它前面字符相等个数，由于每行都存储的是相等的字符个数，那么 它前面字符相等个数=a[i - 1][j - 1]</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a b c d k k k</span><br><span class="line">b a a b c d a d a b c</span><br><span class="line">第一次比较a：</span><br><span class="line">0 1 1 0 0 0 1 0 1 0 0</span><br><span class="line">第二次比较b：</span><br><span class="line">1 1 1 2 0 0 1 0 1 2 0</span><br><span class="line">第三次比较c：</span><br><span class="line">1 1 1 2 3 0 1 0 1 2 3</span><br><span class="line">第三次比较d：</span><br><span class="line">1 1 1 2 3 4 1 1 1 2 3</span><br><span class="line">然后比较k...</span><br></pre></td></tr></table></figure></p><p><strong>答案：a[i][j] + a[i - 1][j - 1] + 1</strong></p><hr><p><a href="#0"><span id="7">7. 日期问题</span></a></p><p>小明正在整理一批历史文献。这些历史文献中出现了很多日期。小明知道这些日期都在1960年1月1日至2059年12月31日。令小明头疼的是，这些日期采用的格式非常不统一，有采用年/月/日的，有采用月/日/年的，还有采用日/月/年的。更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。</p><p>比如02/03/04，可能是2002年03月04日、2004年02月03日或2004年03月02日。</p><p>给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？</p><p>输入<br>一个日期，格式是”AA/BB/CC”。  (0 &lt;= A, B, C &lt;= 9)</p><p>输入<br>输出若干个不相同的日期，每个日期一行，格式是”yyyy-MM-dd”。多个日期按从早到晚排列。</p><p>样例输入<br>02/03/04</p><p>样例输出<br>2002-03-04<br>2004-02-03<br>2004-03-02</p><p>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 256M<br>CPU消耗  &lt; 1000ms</p><p><strong>解：<br>思路：首先将输入的字符串转化为年月日的数字，然后用数组存储下题意中的三种排列，对每个情况进行判断，首先年份要在1960 ~ 2059之间，月份在1 ~ 12之间，天数在1 ~ 31之间，注意闰年的2月是29天，4,6,9,11是30天，输出的时候注意前导0，比如2要输出02，这里需要注意去重的问题，如果是输入02/02/02，那么输出为2002-02-02，但是这个情况对于三种排列都满足</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Day</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> year;</span><br><span class="line"><span class="keyword">int</span> month;</span><br><span class="line"><span class="keyword">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(year &lt; <span class="number">1960</span> || year &gt; <span class="number">2059</span> || month &gt;= <span class="number">13</span> || day &gt; <span class="number">31</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span> || year % <span class="number">400</span> == <span class="number">0</span>)&#123;  <span class="comment">//闰年的情况</span></span><br><span class="line"><span class="keyword">if</span>(month == <span class="number">2</span> &amp;&amp; day &gt; <span class="number">29</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span>(month)&#123;   <span class="comment">//对于每一个月，天数不同的情况</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">if</span>(day &gt; <span class="number">28</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line"><span class="keyword">if</span>(day &gt; <span class="number">30</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Day a, Day b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.year == b.year)&#123;   <span class="comment">//年份相等,则比较月份</span></span><br><span class="line"><span class="keyword">if</span>(a.month == b.month)    <span class="comment">//月份相等，则比较天数</span></span><br><span class="line"><span class="keyword">return</span> a.day &lt; b.day;</span><br><span class="line"><span class="keyword">return</span> a.month &lt; b.month;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a.year &lt; b.year;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提取出每个部分的数字</span></span><br><span class="line"><span class="keyword">int</span> a = (s[<span class="number">0</span>] - <span class="string">'0'</span>) * <span class="number">10</span> + (s[<span class="number">1</span>] - <span class="string">'0'</span>);</span><br><span class="line"><span class="keyword">int</span> b = (s[<span class="number">3</span>] - <span class="string">'0'</span>) * <span class="number">10</span> + (s[<span class="number">4</span>] - <span class="string">'0'</span>);</span><br><span class="line"><span class="keyword">int</span> c = (s[<span class="number">6</span>] - <span class="string">'0'</span>) * <span class="number">10</span> + (s[<span class="number">7</span>] - <span class="string">'0'</span>);</span><br><span class="line"><span class="keyword">int</span> m[][<span class="number">3</span>] = &#123;</span><br><span class="line">a, b, c, </span><br><span class="line">c, a, b,</span><br><span class="line">c, b, a&#125;;   <span class="comment">//将三种情况存储在数组中</span></span><br><span class="line">Day d[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> year = <span class="number">1900</span> + m[i][<span class="number">0</span>];   <span class="comment">//年份有19和20两种</span></span><br><span class="line"><span class="keyword">int</span> month = m[i][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> day = m[i][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span>(judge(year, month, day))&#123;   <span class="comment">//如果满足，则加入进来</span></span><br><span class="line">d[k].year = year;</span><br><span class="line">d[k].month = month;</span><br><span class="line">d[k].day = day;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">year = <span class="number">2000</span> + m[i][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(judge(year, month, day))&#123;</span><br><span class="line">d[k].year = year;</span><br><span class="line">d[k].month = month;</span><br><span class="line">d[k].day = day;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(d, d + k, cmp);   <span class="comment">//对日期进行排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line"><span class="comment">//去除和前一个日期重复的</span></span><br><span class="line"><span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; d[i].year == d[i - <span class="number">1</span>].year &amp;&amp; d[i].month == d[i - <span class="number">1</span>].month &amp;&amp; d[i].day == d[i - <span class="number">1</span>].day)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d[i].year &lt;&lt; <span class="string">"-"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setw(<span class="number">2</span>) &lt;&lt; setfill(<span class="string">'0'</span>) &lt;&lt; d[i].month &lt;&lt; <span class="string">"-"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setw(<span class="number">2</span>) &lt;&lt; setfill(<span class="string">'0'</span>) &lt;&lt; d[i].day &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#0"><span id="8">8. 包子凑数</span></a></p><p>小明几乎每天早晨都会在一家包子铺吃早餐。他发现这家包子铺有N种蒸笼，其中第i种蒸笼恰好能放Ai个包子。每种蒸笼都有非常多笼，可以认为是无限笼。</p><p>每当有顾客想买X个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有X个包子。比如一共有3种蒸笼，分别能放3、4和5个包子。当顾客想买11个包子时，大叔就会选2笼3个的再加1笼5个的（也可能选出1笼3个的再加2笼4个的）。</p><p>当然有时包子大叔无论如何也凑不出顾客想买的数量。比如一共有3种蒸笼，分别能放4、5和6个包子。而顾客想买7个包子时，大叔就凑不出来了。</p><p>小明想知道一共有多少种数目是包子大叔凑不出来的。</p><p>输入<br>第一行包含一个整数N。(1 &lt;= N &lt;= 100)<br>以下N行每行包含一个整数Ai。(1 &lt;= Ai &lt;= 100)</p><p>输出<br>一个整数代表答案。如果凑不出的数目有无限多个，输出INF。</p><p>例如，<br>输入：<br>2<br>4<br>5</p><p>程序应该输出：<br>6</p><p>再例如，<br>输入：<br>2<br>4<br>6</p><p>程序应该输出：<br>INF</p><p>样例解释：<br>对于样例1，凑不出的数目包括：1, 2, 3, 6, 7, 11。<br>对于样例2，所有奇数都凑不出来，所以有无限多个。</p><p>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 256M<br>CPU消耗  &lt; 1000ms</p><p><strong>解：<br>思路：由裴蜀定理知：a <em> x + b </em> y = gcd(a, b), 令c = gcd(a, b), 则a <em> x + b </em> y = c, 说明如果想让ａ和ｂ来表示ｃ，那么ｃ一定为ａ和ｂ的最大公约数的倍数。<br>这样就有一个结论：如果数据中含有两个数的最大公约数为１，那么就可以表示１的倍数，除了前面凑不出来的数<br>有两个数４,６, 最大公约数为２, 只能表示２的倍数的数字,不能表示奇数<br>首先标记能表示的数，然后遍历没有被标记的，就是不能表示的数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> b[N];</span><br><span class="line"><span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"> <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> g = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">g = gcd(g, a[i]);   <span class="comment">//如果有两个数a, b，gcd(a, b) = 1, 则g = 1, 那么gcd(g, x) = 1;</span></span><br><span class="line"><span class="keyword">if</span>(g != <span class="number">1</span>)&#123;    <span class="comment">//如果最大公约数没有为１的，那么就有无限个数凑不出来</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"INF"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">1</span>;   <span class="comment">//0个包子，就取0笼</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j + a[i] &lt; N; j++)</span><br><span class="line"><span class="keyword">if</span>(b[j])    <span class="comment">//如果数字为ｊ的能凑，那么j + a[i]也能凑，即在ｊ的基础上+a[i]</span></span><br><span class="line">b[j + a[i]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)   <span class="comment">//遍历Ｎ，看那些没有标记</span></span><br><span class="line"><span class="keyword">if</span>(!b[i])</span><br><span class="line">sum++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="#0"><span id="9">9. 分巧克力</span></a></p><p>儿童节那天有K位小朋友到小明家做客。小明拿出了珍藏的巧克力招待小朋友们。<br>小明一共有N块巧克力，其中第i块是Hi x Wi的方格组成的长方形。</p><p>为了公平起见，小明需要从这 N 块巧克力中切出K块巧克力分给小朋友们。切出的巧克力需要满足：</p><p>1.形状是正方形，边长是整数<br>2.大小相同  </p><p>例如一块6x5的巧克力可以切出6块2x2的巧克力或者2块3x3的巧克力。</p><p>当然小朋友们都希望得到的巧克力尽可能大，你能帮小Hi计算出最大的边长是多少么？</p><p>输入<br>第一行包含两个整数N和K。(1 &lt;= N, K &lt;= 100000)<br>以下N行每行包含两个整数Hi和Wi。(1 &lt;= Hi, Wi &lt;= 100000)<br>输入保证每位小朋友至少能获得一块1x1的巧克力。   </p><p>输出<br>输出切出的正方形巧克力最大可能的边长。</p><p>样例输入：<br>2 10<br>6 5<br>5 6  </p><p>样例输出：<br>2</p><p>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 256M<br>CPU消耗  &lt; 1000ms</p><p><strong>解：<br>思路：这题采用二分法，首先找到最大的边长，作为二分操作中的right，对边长进行二分操作，即mid = (left + right) / 2，如果mid长度满足题意，那么继续增大mid，也就是让left = mid + 1.如何判断mid长度是否满足题意呢，循环遍历巧克力的边长，h / mid, w / mid 得到有多少mid长度的边，两者的乘积就是边长为mid的正方形的个数</strong><br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> __ __ __</span><br><span class="line">|        |   边长为3*3的矩形,假如mid = 2, 那么(3 / 2) * (3 / 2) = 1,可以形成一个2*2的正方形</span><br><span class="line">|        |   相当于在ｈ上有n = h / mid 个mid, ｗ上有m = w / mid个mid, 总共有n * m 个 mid*mid</span><br><span class="line">|__ __ __|</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> h[<span class="number">100000</span>], w[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">sum += (h[i] / b) * (w[i] / b);   <span class="comment">//求出满足边长为mid的正方形的个数</span></span><br><span class="line"><span class="keyword">if</span>(sum &gt;= k)    <span class="comment">//如果已经达到ｋ个了，就返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; h[i] &gt;&gt; w[i];</span><br><span class="line">right = max(right, h[i]);<span class="comment">//找出最大的那个边长</span></span><br><span class="line">right = max(right, w[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;    <span class="comment">//不断二分边长，直到left &lt; right</span></span><br><span class="line"><span class="keyword">if</span>(fun(mid))</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; left &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//输出边长</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="#0"><span id="10">10. k倍区间</span></a></p><p>给定一个长度为N的数列，A1, A2, … AN，如果其中一段连续的子序列Ai, Ai+1, … Aj(i &lt;= j)之和是K的倍数，我们就称这个区间[i, j]是K倍区间。</p><p>你能求出数列中总共有多少个K倍区间吗？</p><p>输入<br>第一行包含两个整数N和K。(1 &lt;= N, K &lt;= 100000)<br>以下N行每行包含一个整数Ai。(1 &lt;= Ai &lt;= 100000)</p><p>输出<br>输出一个整数，代表K倍区间的数目。</p><p>例如，<br>输入：<br>5 2<br>1<br>2<br>3<br>4<br>5</p><p>程序应该输出：<br>6</p><p>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 256M<br>CPU消耗  &lt; 2000ms</p><p><strong>解：<br>思路：首先对数组进行前缀和a[i] + a[i - 1], 那么区间[l, r]的和为a[r] - a[l - 1], 如果(a[r] - a[l - 1]) % k == 0, 那么这个区间就是一个ｋ倍区间<br>(a[r] - a[l - 1]) % k == 0<br>=&gt; a[r] % k == a[l - 1] % k<br>可以看出如果区间两端点对ｋ的模相等，那么这个区间就是一个ｋ倍区间。我们可以在求前缀和的同时直接将这个对ｋ取模之后的数求出来，即a[r] % k, 只要有一个相等的情况我们就存储起来，这个数组记做b[],b数组的下标存储的就是a[r] % k, 对于进行了前缀和取模后的数组a, 只要将里面模数相等的个数全部存储在b数组中，那么对里面的端点进行两两组合，那么就可以得出这个区间[l, r], 组合数为C(n, 2) = n * (n - 1) / 2, 对于a[r] % k刚好为０的情况，只需要这一个端点就满足条件，所以要加上模数为０的总数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;   <span class="comment">//定义long long 避免爆数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">ll a[<span class="number">100001</span>], b[<span class="number">100001</span>];</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));  <span class="comment">//初始化数组为０</span></span><br><span class="line"><span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">a[i] = (a[i] + a[i - <span class="number">1</span>]) % k;   <span class="comment">//a[i] + a[i - 1]为前缀和，这里同时取模，即a[r] % k</span></span><br><span class="line">b[a[i]]++;     <span class="comment">//a[r] % k的个数，满足a[r] % k == a[l - 1] % k的区间[l, r]为k倍区间</span></span><br><span class="line">&#125;</span><br><span class="line">ll sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(b[i])&#123;   <span class="comment">//如果含有点</span></span><br><span class="line">sum += b[i] * (b[i] - <span class="number">1</span>) / <span class="number">2</span>;   <span class="comment">//组合求个数, 每两个点可以组成一个区间</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum +=  b[<span class="number">0</span>];   <span class="comment">//如果模数为0, 表明区间为[0, r], 加上本身的情况</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;span id=&quot;0&quot;&gt;目录：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;购物单&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2&quot;&gt;等差素数列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3&quot;&gt;承压计算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4&quot;&gt;方格分割&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#5&quot;&gt;取数位&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#6&quot;&gt;最大公共子串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#7&quot;&gt;日期问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#8&quot;&gt;包子凑数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#9&quot;&gt;分巧克力&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#10&quot;&gt;k倍区间&lt;/a&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
