{"meta":{"title":"梦之彼岸","subtitle":"只有神知道的世界","description":"这是一个神奇的世界","author":"gydjsz","url":"https://gydjsz.github.io"},"pages":[{"title":"","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"about/index.html","permalink":"https://gydjsz.github.io/about/index.html","excerpt":"","text":"开始搭建博客date: 2018-07-19 10:33:33先建好再说，让我的文章有一个归属，再美化 blog部分问题的修改date: 2018-07-21 20:05:36在blog中修改了search部分，使之搜索跳转到百度，目前还没有在本页面搜索的功能，修改了文章字体显示太大的部分。 有点小问题date: 2018-07-23 13:13:36不知道怎么回事呢，使用了markdown的语法却不能好好插入本地图片，使用外链又不是永久的，只好用base64图片编码，不过blog还是想尽量放一些图片上去，更直观一些。 评论区改善,快来瞧一瞧date: 2018-07-23 15:15:20blog新增评论功能，可以写下你的感想或者问题哦！ 目前已经支持站内搜索blogdate: 2018-07-24 22:30:14右边的搜索框已经更改为站内搜索,快来搜索你感兴趣的blog吧"},{"title":"","date":"2019-01-21T08:29:21.955Z","updated":"2019-01-21T08:29:21.911Z","comments":true,"path":"message/index.html","permalink":"https://gydjsz.github.io/message/index.html","excerpt":"","text":"欢迎在评论区留言。"},{"title":"","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"about/LearnEveryday/day2018_7_21.html","permalink":"https://gydjsz.github.io/about/LearnEveryday/day2018_7_21.html","excerpt":"","text":"在blog中修改了search部分，使之搜索跳转到百度，目前还没有在本页面搜索的功能，以后会添加。"}],"posts":[{"title":"链接收藏","slug":"GoodWebsiteCollection","date":"2019-01-25T15:53:18.257Z","updated":"2019-01-25T15:53:18.225Z","comments":true,"path":"2019/01/25/GoodWebsiteCollection/","link":"","permalink":"https://gydjsz.github.io/2019/01/25/GoodWebsiteCollection/","excerpt":"","text":"下载链接 putty下载:&ensp;https://pan.baidu.com/s/1X_IITIlSP5u_wnKPiOL-oA&ensp;&ensp;&ensp; 提取码：8of8 xshell下载链接：https://pan.baidu.com/s/1qb_wYdU3S-9s3dpBzIMCoQ&ensp;&ensp;&ensp; 提取码：r2x7 xsel下载链接：链接：https://pan.baidu.com/s/1JY269KghMzMvCLgy1_XlwQ&ensp;&ensp;&ensp; 提取码：opml 编程练习 PTA:&ensp;https://pintia.cn/ 牛客网:&ensp;https://www.nowcoder.com/ nyoj:&ensp;http://acm.nyist.edu.cn/JudgeOnline/problemset.php LibreOj:&ensp;https://loj.ac/ TMaD OJ:&ensp;http://tmad.ctguqmx.com/ 编程网站(全):https://vjudge.net/ 编程学习 速学堂:&ensp;http://www.sxt.cn/ 菜鸟教程:&ensp;http://www.runoob.com/ 黑马程序员:&ensp;http://yun.itheima.com/ 博客 简明现代魔法:&ensp;http://www.nowamagic.net/ CSDN:&ensp;https://www.csdn.net/ Exp技术分享博客:&ensp;http://exp-blog.com/ Linux Linux命令大全:&ensp;http://man.linuxde.net/ 鸟哥的Linux私房菜:&ensp;https://www.kancloud.cn/wizardforcel/vbird-linux-basic-4e/152191 工具网站 在线计算器:&ensp;http://www.ab126.com/ 图片和base64编码转换:&ensp;http://www.vgot.net/test/image2base64.php? 在线vim编辑器学习:&ensp;http://www.atool.org/vim.php 二维码在线解析:&ensp;http://cdn.malu.me/qrdecode/ 视频下载: http://weibodang.cn/ 多平台音乐在线播放: http://music.lkxin.cn/ 在线打字网站1: https://www.typingclub.com/在线打字网站2: https://www.typing.com/ 代码共享：https://paste.ubuntu.com/ 工具网站：http://www.bejson.com/ 图片托管：https://miao.su/ 好的技术博文 python安装提示No module named setuptools,wget提示ERROR 403: SSL is requiredhttps://blog.csdn.net/jiaoshengha/article/details/79384223 里面提到的链接无法下载的问题,其实直接把链接复制到浏览器中打开就好,若是在终端下就可以使用里面说的方法,使用sudo wget 链接; ubuntu中安装eclipsehttps://blog.csdn.net/wmyan/article/details/78279846 ubuntu安装kchmviewer查看jdk-api文档https://blog.csdn.net/qq_32296307/article/details/53064587 直接一条命令：sudo apt-get install kchmviewer然后打开文档的时候选择kchmviewer就行了 git学习https://mp.weixin.qq.com/s/BHJ44cDhnPQrvqdqowwilg shell常用正则表达式https://mp.weixin.qq.com/s/IUrgFLNWnqJOe8yfcb2W6w Linux常用命令总结https://mp.weixin.qq.com/s/xtXPUy8qB4YMa5W8HwzoGA wget 命令用法详解https://mp.weixin.qq.com/s/iN_fsL98TeR8WsaCeMpVcw IntelliJ IDEA 教程设置讲解https://mp.weixin.qq.com/s/PbKCoAO1gyEgpsGs_FQ3oQ Ubuntu 18.04 安装、配置和美化https://blog.csdn.net/szhiy/article/details/81385107 Ubuntu安装Anaconda navigator 启动图形化界面https://blog.csdn.net/u013550000/article/details/80433402 安装、配置Jupyter Notebook快速入门https://www.cnblogs.com/Neo007/p/7501625.html 打开git bash时出现闪退https://blog.csdn.net/qq_34400736/article/details/72627343 Linux下安装jdkhttps://www.linuxidc.com/Linux/2015-01/112030.htm Linux之间互传文件https://blog.csdn.net/qq_30968657/article/details/72912070 北大ACM-POJ试题分类http://exp-blog.com/2018/06/28/pid-38/","categories":[],"tags":[]},{"title":"虚拟机与windows 10互传文件","slug":"virtual/virtualOperation","date":"2019-01-21T11:38:23.017Z","updated":"2019-01-21T11:38:22.933Z","comments":true,"path":"2019/01/21/virtual/virtualOperation/","link":"","permalink":"https://gydjsz.github.io/2019/01/21/virtual/virtualOperation/","excerpt":"","text":"在虚拟机设置中找到“选项”，再点击共享文件夹，点击启用，然后在下方的添加里面加入windows 10共享文件的目录 在Ubuntu中，共享文件的路径为 /mnt/hgfs，cd /mnt/hgfs进入之后就可以查看了 出现启用了共享后没有反应的情况时，可以： 输入sudo vmhgfs-fuse .host:/ /mnt/hgfs 启用vmhgfs-fuse模块，然后以root用户进入目录就可以查看文件了。 在/root/.bashrc 中添加命令vmhgfs-fuse .host:/ /mnt/hgfs，每次开机以root用户登陆，就可以直接访问共享文件啦","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/hello-world/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"github搭建自己的博客步骤","slug":"hexoBuild","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/hexoBuild/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/hexoBuild/","excerpt":"","text":"先在github上注册账号，新建一个仓库，仓库名为用户名.github.io 1.安装git：sudo apt-get install git2.git安装完成之后设置基本信息 1)设置用户名：git config –global user.name “用户名” 2)设置用户名邮箱：git config –global user.email “邮箱” 3)查看设置：git config –list 3.添加ssh公钥：ssh-keygen -t rsa -C “email”,输入cat ~/.ssh/if_rsa.pub，将公钥添加到github中，可以输入ssh -T git@github.com，测试是否连接成功4.安装nodejs：curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -sudo apt-get install -y nodejs5.安装npm：sudo apt-get install npm6.安装hexo：sudo npm install hexo-cli -g(npm install)7.初始化hexo：hexo init安装一些插件： npm install hexo-generator-index –save #索引生成器 npm install hexo-generator-archive –save #归档生成器 npm install hexo-generator-category –save #分类生成器 npm install hexo-generator-tag –save #标签生成器 npm install hexo-server –save #本地服务 npm install hexo-deployer-git –save #hexo通过git发布（必装） npm install hexo-renderer-marked@0.2.7--save #渲染器 npm install hexo-renderer-stylus@0.3.0 –save #渲染 8.初始化git：git init9.git clone 仓库，查看clone 地址：git remote -v，为https:// 方式移除https的方式，换成 ssh方式 git remote rm origin， git remote add origin git地址 首先找到一个背景图片放到 hexo（hexo工程文件）-&gt; themes -&gt; next -&gt; source -&gt; images 的路径下；hexo（hexo工程文件）-&gt; themes -&gt; next -&gt; source -&gt; css -&gt; _custom ，找到路径下的custom.styl文件，在文件的最上方加上一代码 body { background:url(/images/backGround.jpg（这是你之前加的背景图片的名字）);} 就完事了。出现 fatal: 不是一个 git 仓库（或者任何父目录）：.git 错误提示时，需要初始化本地仓库：git inithexo new “postName” #新建文章 hexo new page “pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 hexo deploy -g #生成加部署 hexo server -g #生成加预览 命令的简写hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy git中ssh的生成：ssh-keygen -t rsa -C “youremail@example.com“ 从git中删除文件：git rm 文件名 从github上复制仓库中的项目：git clone 仓库地址 将本地仓库同步到远程仓库：git push 在工作区编写文件、通过git add 文件名添加到暂存区、通过git commit -m “提交信息”添加到本地仓库，通过git push同步到远程仓库 如果是私有仓库或者无法关联远程仓库，无法同步，需要输入用户名和密码的，可以： vim .git/config 将 [remote “origin”] url = https://github.com/用户名/仓库名.git 改为 [remote “origin”] url = https://用户名:密码@github.com/用户名/仓库名.git 个人站点 -&gt; 新建仓库 -&gt; 仓库名必须是用户名.github.io 如果无法推送到远程仓库，原因是远程仓库有过变动，需要先将远程仓库同步到本地：git pull，再将本地文件添加到远程仓库：git push 打开hexo博客分类标签出现Cannot GET/xxxx，说明需要初始化子目录，输入hexo new page “categories”, 就会在source文件里面初始化这些目录，并生成一个index文件","categories":[],"tags":[]},{"title":"加快github和firefox扩展页面访问速度","slug":"improveBrowseSpeed","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/improveBrowseSpeed/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/improveBrowseSpeed/","excerpt":"","text":"访问https://www.ipaddress.com，拉下来，找到页面中下方的“IP Address Tools – Quick Links”分别输入github.global.ssl.fastly.net和github.com，查询ip地址修改本地hosts文件 在/etc/hosts中添加以下内容： 151.101.185.194 https://github.global.ssl.fastly.net192.30.253.112 https://github.com 117.18.232.191 mozorg.cdn.mozilla.net117.18.232.191 addons.cdn.mozilla.net","categories":[],"tags":[]},{"title":"markdown语法学习","slug":"markdown","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/markdown/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/markdown/","excerpt":"","text":"[markdown语法]https://www.jianshu.com/p/b03a8d7b1719[markdown语法]https://www.appinn.com/markdown/#header[markdown缩进]https://www.cnblogs.com/Flylater/p/6264799.html[先来一头马克飞象(在线使用markdown)]https://maxiang.io/[markdown插入图片]https://blog.csdn.net/slaughterdevil/article/details/79255933[添加百度云图片链接]https://jingyan.baidu.com/article/f006222806dfdcfbd3f0c880.html 插入跳转链接https://blog.fbzl.org/“1&lt;a href=&quot;https://blog.fbzl.org/&quot; target=&quot;_blank&quot;&gt;https://blog.fbzl.org/&quot;&lt;/a&gt; 缩进在每一行开头的时候，先输入下面的代码，然后紧跟着输入文本即可。注意有分号123半角空格: &amp;ensp;或 &amp;#8194;全角空格: &amp;emsp;或 &amp;#8195;不换行空格: &amp;nbsp;或 &amp;#160; 插入图片首先插入本地图片的地址不是绝对路径,比如说我图片的绝对路径为~/Picture/picture1.jpg我写博客的位置是~/Documents/blog,那么添加的图片路径是相对路径,即从我当前路径开始算起,路径为../Picture/picture1.jpg; 了解linux的应该知道, “..”表示上一层目录, 可是我使用这种方法,会出现网页中显示不了图片的情况,甚至在一篇文章里面可以显示,但是放在另一篇文章里面就显示不了的情况,所以现在给出其它的方法 一. 使用base64编码图片和base64编码转换网址: http://www.vgot.net/test/image2base64.php? 因为编码很长,所以可以放在文章的最后面,以下的picture是编码id,可以自己设定1234567891011文章插入的图片位置:![图片说明][picture]文章文章末尾代码区域填写:[picture]:data:image/png;base64,编码 二. 使用百度云添加图片外链 首先上传图片到百度云盘中,存储容量有2T,所以不用担心图片太多,最好是单独创建一个文件夹,将图片保存在里面 鼠标右键点击分享,默认加密选项,有效期永久,然后点击确定 将链接复制到浏览器中打开,可以看到自己的图片,然后右键点击图片然后复制图片链接,这个就是你的图片外链了 在博客中添加图片外链: 1![图片说明](链接) 二. 使用github添加图片外链 先将图片上传到github中 在github中打开图片，复制图片链接","categories":[],"tags":[]},{"title":"远程登陆linux系统","slug":"Linux/longRange","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/Linux/longRange/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Linux/longRange/","excerpt":"","text":"开通ssh服务sudo apt-get install openssh-server 启用ssh-server服务默认安装之后就开启，可以通过ps -e |grep ssh查看，出现sshd就说明启动了 启动sshserver命令：service ssh start 或者sudo /etc/init.d/ssh start 关闭sshserver命令：service ssh stop 重启sshserver命令：service ssh restart 此时已经可以远程登陆，如果需要直接使用root账号登陆，则需要开通root权限vi /etc/ssh/ssh_dconfig将PermitRootLogin without-password 修改为PermitRootLogin yes 下载putty，输入linux系统的ip，并修改字体大小， 如果是通过linux来远程登陆另一台linux主机，则可以在终端里面输入ssh username@ip 注：查看linux的ip地址可以输入ifconfig","categories":[],"tags":[]},{"title":"设置emacs里面的字体类型","slug":"LearnEmacs/EmacsTypeFace","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/LearnEmacs/EmacsTypeFace/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/LearnEmacs/EmacsTypeFace/","excerpt":"","text":"在Option里面找到Set Default Font，然后选择自己喜欢的字体，打开.emacs文件，输入M-x，在下方输入describe-font， 回车之后再回车，出现如图形式： 复制如图黄色选中的部分，然后在.emacs之中添加： ;;set font family (set-default-font “-bitstream-Courier 10 Pitch-normal-normal-normal--29----m-0-iso10646-“) 就可以永久设置字体","categories":[],"tags":[]},{"title":"在eclipse中使用vim","slug":"LearnVim/vimInEclipse","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/LearnVim/vimInEclipse/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/LearnVim/vimInEclipse/","excerpt":"","text":"参考链接:&ensp;https://blog.csdn.net/wr132/article/details/70232043 在help中找到Install New SoftWare,点击add,输入name和网址 选择viPlugin,之后点击next和accept 3.在eclipse根目录建立文件 viPlugin2.lic ，在其中输入 q1MHdGlxh7nCyn_FpHaVazxTdn1tajjeIABlcgJBc20 这里注意在安装插件过程中eclipse是没有什么反应的,这个时候不要重启,我之前按照教程里面说的选择了accept, next之后几秒种没反应就直接手动restart了,这个时候其实是在下载,最后eclipse会出现警告,点击install anyway,最后eclipse会弹出restart,点击这个就没问题了 5.vim模式的切换快捷键为Ctrl-Alt-v","categories":[],"tags":[]},{"title":"python","slug":"python/learnPython","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/python/learnPython/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/python/learnPython/","excerpt":"","text":"大小写转换12345name = \"hello, world\"name = name.title() #将单词首字母大写print(name) #输出Hello, Worldprint(name.upper()) #输出HELLO, WORLd (将字符串中的所有字母转化为大写)print(name.lower()) #输出hello, world (将字符串中的所有字母转化为小写) 注释123单行: #多行: ''' 注释''' 或者 \"\"\" 注释 \"\"\" 删除末尾的空格12favorite_language = 'python 'favorite_language.rstrip() #删除末尾的空格 将非字符串转化为字符串1str(n) #将非字符串转化为字符串 列表123456789101112list = [] #创建一个空列表list.append('abc') #在列表末尾添加元素list.insert(0, 'abc') #在列表的0位置处添加一个元素del list[1] #删除列表中1位置的元素x = list.pop() #弹出栈顶元素list.remove('abc') #移除第一个出现的元素abclist.sort() #按字母顺序从小到大list.sort(reverse=True) #按与字母顺序相反的顺序排列sorted(list) #字母顺序显示列表，不影响列表内部排序sorted(list, reverse=True) #逆字母顺序显示列表，不影响列表内部排序list.reverse() #反转列表中的元素len(list) #获取列表长度 print输出的格式12输入不换行:print(2233, end = '') 产生数字列表12生成数字列表:numbers = list(range(5)) #range产生[0, 5)的整数 ** #表示乘方运算 最小值、最大值及总和123456numbers = list(range(10))#数字列表中的最小值,最大值以及总和min(numbers) max(numbers)sum(numbers) 列表解析12range(start, stop, step) #从start开始，以stop - 1结束步长为step的整数list = [value for value in range(1, 21, 2)] #1~20以内的奇数.列表解析: 表达式(value) + 循环(for...)) 切片123456789101112131415players = ['charles', 'martina', 'michael', 'florence', 'eli']print(players[0 : 3]) #输出列表中的0~2号元素print(players[:4]) #省略第一个索引，默认为从头开始print(players[2:]) #省略第二个索引，默认为从索引2开始到末尾print(players[-3:]) #从倒数第三个索引开始到末尾所有元素#遍历切片for player in players[:3]: print(player)#复制列表other_players = players[:]#如果是下面这样, 并不能复制列表other_players = players #将other_players关联到players，other_players内容改变对players有效 元组1234dimensions = (200, 50) #使用括号来标识, 元组内的值不能更改,但是可以重新定义dimensions = (400, 100)for dimension in dimensions: print(dimension) 判断特定值是否在列表中123numbers = [1, 2, 3, 4]print(3 in numbers) //Trueprint(56 not in numbers) //True 遍历键值对1234tom = &#123;'name': 'tom', 'age': 34, 'heigh': 150, 'weight': 40&#125;for k, v in tom.items(): print(k + \":\", end = ' ') print(v) 遍历字典12345678910111213favorite_language = &#123; 'jen': 'python', 'sarah': 'c', 'edward': 'ruby', 'phil': 'python',&#125;for key in favorite_language.keys(): #遍历键 print(key)for name in favorite_language.values(): #遍历值 print(name)for k, v in favorite_language.items(): print(k + \" \" v) 嵌套123456789101112131415#字典列表alien_0 = &#123;'color': 'green', 'points': 5&#125;alien_1 = &#123;'color': 'yellow', 'points': 10&#125;alien_2 = &#123;'color': 'red', 'points': 15&#125;aliens = [alien_0, alien_1, alien_2]for alien in aliens: print(alien)#字典中储存列表pizza = &#123; 'crust': 'thick', 'toppings': ['mushrooms', 'extra cheese'],&#125;","categories":[],"tags":[]},{"title":"matlab学习","slug":"matlabLearn/matlab","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/matlabLearn/matlab/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/matlabLearn/matlab/","excerpt":"","text":"clc,clear; 清除命令 close all 清除所有窗口 warning off 关闭警告 fprintf(‘result: %d’, a); 输出a的值 fprintf(fid, format, A) fid输出的位置(如果缺省，则输出在窗口) format(输出内容的类型) %e: 实数 %.3f: 浮点数(保留3位小数) A:输入内容的变量名 disp(a) 显示a的值 disp(‘hello’);disp(‘numstr(12)’) %%numstr()将其他类型的变量转化成字符串形式disp(zeros(m, n)) 顺序结构 判断结构 1234567if 条件 执行内容elseif 条件二 执行内容else 执行内容end 循环结构 1234567891011for i = 1 : m 循环内容endfor i = 1 : 3 : 9 fprintf('%d ', i); 输出1，4，7(步长为3)endwhile(条件) 循环内容end a = mod(45678, 10) 获得45678的余数 n = fix(465 / 10) n的值为46 [m, n] = size(a) 获取a的行、列数a(i, j) 第i行j列的值 函数的自定义function[输出] = fun(n)","categories":[],"tags":[]},{"title":"牛客练习赛34的C、D题题解","slug":"algorithm/nowcoderPractice34","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/algorithm/nowcoderPractice34/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/algorithm/nowcoderPractice34/","excerpt":"","text":"C题123456789101112131415161718192021222324252627题目描述 小w有m条线段，编号为1到m。用这些线段覆盖数轴上的n个点，编号为1到n。第i条线段覆盖数轴上的区间是L[i]，R[i]。覆盖的区间可能会有重叠，而且不保证m条线段一定能覆盖所有n个点。现在小w不小心丢失了一条线段，请问丢失哪条线段，使数轴上没被覆盖到的点的个数尽可能少，请输出丢失的线段的编号和没被覆盖到的点的个数。如果有多条线段符合要求，请输出编号最大线段的编号（编号为1到m）。输入描述:第一行包括两个正整数n，m(1≤n，m≤10^5)。接下来m行，每行包括两个正整数L[i]，R[i](1≤L[i]≤R[i]≤n)。输出描述:输出一行，包括两个整数a b。a表示丢失的线段的编号。b表示丢失了第a条线段后，没被覆盖到的点的个数。输入5 31 34 53 4输出3 0 这里涉及到区间的修改与查询.先了解一下差分区间和前缀和:如果要修改[L, R]区间,可以直接将区间L[i] + k,R[i + 1] - k,然后遍历一遍数组，将前缀和d[i] += d[i - 1]与原数组相加,最后就可以得到修改后的数组。例如0 1 2 3 4 5 0, 我这里想把[2, 4]区间里面的值都加上1，将[1, 3]中的值都加上3,得到的差分区间为0 3 1 0 -3 -1 0,然后遍历数组，将前缀和(0 3 4 4 1 0 0)与原数组相加得到0 4 6 7 5 5 0.这样的好处是只需要一次遍历就能修改所有改变了的值。然后回到这题：首先对输入的区间进行一次差分d[L[i]]++, d[R[i] + 1]–，然后使用前缀和d[i] += d[i - 1]得到更改之后的数组(因为初始数组内的数字全为0)。将数组内值为1的点找出来(因为覆盖的点的个数为1，那么删除该线段之后，该点就没有被覆盖了)，再用一次前缀和，这个前缀和就是便于查找某区间内点的个数为1的数组，同时在遍历的时候记录值为0的点,即线段没覆盖的点cnt，最后用求得的前缀和数组便可以找到区间内覆盖点的数目最少的区间以及个数min, cnt + min就是没被覆盖的点的个数。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 100001;int main()&#123; int L[N], R[N]; int b[N], s[N]; memset(b, 0, sizeof(b)); memset(s, 0, sizeof(s)); int n, m, cnt = 0; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++)&#123; cin &gt;&gt; L[i] &gt;&gt; R[i]; b[L[i]]++; b[R[i] + 1]--; &#125; for(int i = 1; i &lt;= n; i++)&#123; b[i] += b[i - 1]; s[i] = s[i - 1] + (b[i] == 1); cnt += (b[i] == 0); &#125; int now = 0, min = 1000000, ans = 1; for(int i = 1; i &lt;= m; i++)&#123; now = s[R[i]] - s[L[i] - 1]; if(now &lt;= min)&#123; min = now; ans = i; &#125; &#125; cout &lt;&lt; ans &lt;&lt; &quot; &quot; &lt;&lt; min + cnt &lt;&lt; endl; return 0;&#125; D题1234567891011121314151617181920212223题目描述旅行到K国的小w发现K国有着很多物美价廉的商品，他想要买一些商品。结果一掏钱包，包里只剩下n张K国的纸币了，说起来也奇怪，K国纸币并不像其他国家一样都是1元，5元，10元…而是各种奇怪的面值，所以找零就不是很方便。 已知商店里的商品价格都是小于等于m的正整数，如果有可能存在某个商品的价格为x&lt;=m并且x无法在不找零的情况下支付，小w就不能任意购买一件商店中的商品，小w想知道自己在不找零的情况下能否任意购买一件商店中的商品，你能帮帮他么？输入描述:第一行是两个正整数n,m（n&lt;=1000,m&lt;=2^31-1）第二行共n个正整数ai(1&lt;=ai&lt;=2^31-1)，代表小w钱包中K国纸币的面值。输出描述:如果能任意购买商店中的物品，请输出&quot;YES&quot;(不含引号)。如不能任意购买商店中的物品，请输出&quot;NO&quot;（不含引号）。输入4 101 2 3 4输出YES 商品价值和纸币面值&gt;=1,首先将纸币面值排序，第一个数必须为1，否则不能购买商店中的商品,第二个数为1或2，否则不能凑成2; 第三个数为1、2或3，否则不能凑成3，以此类推. 数列{an}满足题意,该数列是从1开始表示一直到最大能表示的数，也就是数列的和Sn， 数列的第一个数为a[0],将后面的数一个个加入到该数列中,加入的条件为 a[i + 1] &lt;= sum + 1，如何理解呢，首先：a[i + 1] 如果大于sum + 1，那么该数列只能表示1~sum和a[i + 1] + {1 ~ sum}，无法表示sum + 1; 如果等于那么a[i + 1]本身就可以 表示sum + 1; 如果小于，a[i + 1] + {1 ~ sum}表示的范围就是{1 ~ sum + a[i + 1]}, a[i + 1]又至少为1，则必定满足。最后判断表示最大数的sum大于等于m，那么就输出YES，否则NO. 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define ll long long int main()&#123; ll n; ll m, a[1001]; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; sort(a + 1, a + n + 1); ll sum = 0; for(int i = 0; i &lt;= n; i++)&#123; sum += a[i]; if(a[i + 1] &gt; sum + 1) break; &#125; if(sum &gt;= m) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[]},{"title":"二分图","slug":"algorithm/bipartiteGraph","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/algorithm/bipartiteGraph/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/algorithm/bipartiteGraph/","excerpt":"","text":"参考连接:https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E5%9B%BE/9089095?fr=aladdinhttps://blog.csdn.net/sixdaycoder/article/details/47720471http://blog.jobbole.com/106084/ 几个概念 二分图二分图又称作二部图，是图论中的一种特殊模型。 设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。 最大匹配问题给定一个二分图G，在G的一个子图M中，M的边集中的任意两条边都不依附于同一个顶点，则称M是一个匹配.选择这样的边数最大的子集称为图的最大匹配问题。 完备匹配(complete matching)是匹配了二分图较小集合（二分图X，Y中小的那个）的所有点的匹配。完美匹配(perfect matching)是匹配了所有点的匹配。 最佳匹配如果二分图的每条边都有一个权（可以是负数），要求一种完备匹配方案，使得所有匹配边的权和最大，记做最佳完美匹配。（特殊的，当所有边的权为1时，就是最大完备匹配问题） 最小顶点覆盖在二分图中寻找一个尽量小的点集，使图中每一条边至少有一个点在该点集中。 最小顶点覆盖 == 最大匹配。 最小路径覆盖在二分图中寻找一个尽量小的边集，使图中每一个点都是该边集中某条边的端点。 最小路径覆盖 == |V| - 最大匹配。 最大独立集在N个点中选出来一个最大点集，使这个点集中的任意两点之间都没有边。 最大独立集 == 顶点数 - 最大匹配。 交替路和增广路 交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。 增广路的定义(也称增广轨或交错轨):从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路. 由增广路的定义可以推出下述三个结论:1) P的路径长度必定为奇数，第一条边和最后一条边都不属于M.2) P经过取反操作可以得到一个更大的匹配M’.3) M为G的最大匹配当且仅当不存在相对于M的增广路径. 匈牙利算法和km算法https://www.cnblogs.com/logosG/p/logos.htmlhttps://blog.csdn.net/ling_wang/article/details/79830980?utm_source=blogxgwz3https://www.cnblogs.com/zhanzhao/p/3895880.htmlhttps://blog.csdn.net/ling_wang/article/details/79830980?utm_source=blogxgwz3","categories":[],"tags":[]},{"title":"How to operate xsel in Linux?","slug":"Linux/xselOperation","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/Linux/xselOperation/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Linux/xselOperation/","excerpt":"","text":"first download xsel in Linux by using this command: sudo apt-get install xselordownload the xsel(the link is in my other blog–Link Collection)modify the ~/.bashrc by vim or emacsFor example: 123vim ~/.bashrcin the last line add: export PATH=&apos;~/XselDirectory/&apos;source ~/.bashrc //make the operation effective Some operationxsel &lt; file //read file content to xselxsel &gt; file //write xsel content to xselxsel // show xsel contentcat file | xsel -b -i //file to xselcat file | xsel -b -a //add file content to xsel last line more content can read README in XselDirectory","categories":[],"tags":[]},{"title":"学习新的emacs快捷键","slug":"LearnEmacs/GoodShortCutkey","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/LearnEmacs/GoodShortCutkey/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/LearnEmacs/GoodShortCutkey/","excerpt":"","text":"emacs对文本执行操作C-x-t: 交换上下两行C-t: 和光标左边的字母交换M-t: 和光标左边的字符串交换C-/: 撤销操作M-/: 单词补全c-u-n / ESC—n + 数字 向上下左右 删除 字母 (重复执行n次后续命令,省略n则执行4次(ps：对光标跳转之类的功能好用，C-y之类的功能无效) emacs光标跳转M-g-g + n(行数): 跳转到第n行M-{: 光标移动到段落开头M-}: 光标移动到段落结尾C-M-n: 跳转到括号结束位置C-M-p: 跳转到括号开始位置 emacs多窗口操作C-x 2: 水平分割C-x 3: 竖直分割C-x 1: 只保留当前窗格C-x 0: 关闭当前窗格C-x o: 切换窗格C-x 4 C-f: 在此窗格打开一个文件C-M-v: 滚动下一个窗格C-x-^: 扩大所在的窗格 emacs缩进C-M-\\: 缩进区域所有行 emacs正则表达式查找和替换C-s: 向下搜索C-r: 向上搜索M-%: 替换C-M-s: 向下使用正则表达式搜索C-M-r: 向上使用正则表达式搜索C-M-%: 使用正则表达式进行替换 如果找到匹配的, 可以按(C-r或C-M-r)/(C-s或C-M-s)继续向上/下搜索","categories":[],"tags":[]},{"title":"终端下emacs鼠标支持","slug":"LearnEmacs/Mouse","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/LearnEmacs/Mouse/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/LearnEmacs/Mouse/","excerpt":"","text":"[参考链接]http://cn-popeye.iteye.com/blog/1164033[参考链接]http://blog.chinaunix.net/uid-20609878-id-1915823.html[参考链接]http://emacser.com/mouse.htmECB模式开启四个窗口，可以浏览目录，源码文件，方法和历史记录，但是默认只支持键盘操作，RET才能打开。 要支持鼠标需如下操作： 1.在 Emacs 中执行“ M-x ecb-customize-most-important ”，找到“ Ecb Primary Secondary Mouse Buttons ”选项 2.将其设为“ Primary: mouse-1, secondary: mouse -2 ” ， 3.点击state，设置成“ Save for Future Sessions ”保存。 在.emacs配置文件中加入(xterm-mouse-mode t), 支持终端鼠标","categories":[],"tags":[]},{"title":"设置emacs在shell中显示","slug":"LearnEmacs/TurnCharacter","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/LearnEmacs/TurnCharacter/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/LearnEmacs/TurnCharacter/","excerpt":"","text":"emacs安装之后在终端里面打开的是图形版，要想在shell里面直接打开就在~/.bashrc里面添加alias emacs=’emacs -nw’注意等号两边没有空格","categories":[],"tags":[]},{"title":"为emacs添加源","slug":"LearnEmacs/addPlug","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/LearnEmacs/addPlug/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/LearnEmacs/addPlug/","excerpt":"","text":"参考链接:https://blog.csdn.net/sjhuangx/article/details/51252522参考链接:https://blog.csdn.net/watanuki2006/article/details/52122427 方法1emacs中输入M-x customize-variable RET package-archives，进入之后可以看到当前的package源，点击下面的INS按钮来插入新的package源，输入一个名字，一个url链接 name：melpaurl：https://melpa.org/packages 清华源:“gnu” . “http://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/&quot;“melpa” . “http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/&quot; 输入list-pakcages, 进入插件管理 i - 选择要安装的包 d - 选择要删除的包 U - 升级已安装的包 x - 执行操作 d - 选择要删除的包 输入 M-x package-refresh-contents，刷新package信息","categories":[],"tags":[]},{"title":"emacs配置","slug":"LearnEmacs/emacs","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/LearnEmacs/emacs/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/LearnEmacs/emacs/","excerpt":"","text":"(require ‘package)(package-initialize)(add-to-list’package-archives ‘(“melpa” . “http://melpa.milkbox.net/packages/&quot;) t)(custom-set-variables ;; custom-set-variables was added by Custom. ;; If you edit it by hand, you could mess it up, so be careful. ;; Your init file should contain only one such instance. ;; If there is more than one, they won’t work right. ‘(custom-safe-themes (quote (“8aebf25556399b58091e533e455dd50a6a9cba958cc4ebb0aab175863c25b9a4” “bffa9739ce0752a37d9b1eee78fc00ba159748f50dc328af4be661484848e476” default))) ‘(display-time-mode t) ‘(package-archives (quote ((“gnu” . “http://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/&quot;) (“melpa” . “http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/&quot;)))) ‘(package-selected-packages (quote (emms emms-bilibili w3m eimp dracula-theme ecb yasnippet-snippets sr-speedbar auto-yasnippet yasnippet-classic-snippets yasnippet electric-spacing spacemacs-theme solarized-theme flymake-cppcheck flycheck-title flycheck-objc-clang flycheck-irony flycheck-color-mode-line flycheck auto-complete-c-headers auto-complete))) ‘(show-paren-mode t))(custom-set-faces ;; custom-set-faces was added by Custom. ;; If you edit it by hand, you could mess it up, so be careful. ;; Your init file should contain only one such instance. ;; If there is more than one, they won’t work right. ‘(default ((t (:family “Ubuntu Mono” :foundry “DAMA” :slant normal :weight normal :height 158 :width normal))))) (global-auto-complete-mode t) ;(global-linum-mode 1) ; always show line numbers;(setq linum-format “%d)”) ;set format(global-linum-mode t) (global-flycheck-mode t) ;;启用时间显示设置，在minibuffer上面的那个杠上(display-time-mode 1);;时间使用24小时制(setq display-time-24hr-format t);;时间显示包括日期和具体时间;(setq display-time t) ;; TAB键的宽度设置为4(setq c-basic-offset 4) ;(load-theme ‘spacemacs-dark t) ;设置Spacemacs-dark主题 (load-theme ‘dracula t) ;(global-hl-line-mode 1) ;设置行号 ;;让Emacs可以直接打开和显示图片。(setq auto-image-file-mode t) (global-set-key (kbd “,”) ;逗号后面自动添加空格 #&apos;(lambda () (interactive) (insert &quot;, &quot;))) ;; 以 y/n代表 yes/no(fset ‘yes-or-no-p ‘y-or-n-p) ;; 语法高亮(global-font-lock-mode t) ;; 显示括号匹配(show-paren-mode t)(setq show-paren-style ‘parentheses) ;; 支持emacs和外部程序的粘贴(setq x-select-enable-clipboard t) ;; 在标题栏提示你目前在什么位置(setq frame-title-format “zhj@%b”) ;; 回车缩进(global-set-key “\\C-m” ‘newline-and-indent)(global-set-key (kbd “C-“) ‘newline) ;(yas-global-mode 1) (add-to-list ‘load-path “~/.emacs.d/plugins/yasnippet”)(require ‘yasnippet)(setq yas/prompt-functions ‘(yas/dropdown-prompt yas/x-prompt yas/completing-prompt yas/ido-prompt yas/no-prompt))(yas/global-mode 1)(yas/minor-mode-on) ; 以minor mode打开，这样才能配合主mode使用 (require ‘auto-yasnippet)(global-set-key (kbd “H-w”) #’aya-create)(global-set-key (kbd “H-y”) #’aya-expand) ;(sr-speedbar-open) (auto-image-file-mode) ;;关闭emacs启动时的画面(setq inhibit-startup-message t) ;; 改变 Emacs 固执的要你回答 yes 的行为。按 y 或空格键表示 yes，n 表示 no(fset ‘yes-or-no-p ‘y-or-n-p) ;;设置emacs GUI下的字体(set-default-font “-bitstream-Courier 10 Pitch-normal-normal-normal--29----m-0-iso10646-1”) (add-to-list ‘load-path “/home/dal/.emacs.d/elpa/ecb-20170728.1221”) ;;;; 各窗口间切换 (global-set-key [M-left] ‘windmove-left) (global-set-key [M-right] ‘windmove-right) (global-set-key [M-up] ‘windmove-up) (global-set-key [M-down] ‘windmove-down) ;; Disable buckets so that history buffer can display more entries;(setq ecb-history-make-buckets ‘never) (defun set-image-mode-mwheel-scroll-function () (setq-local mwheel-scroll-down-function ‘image-scroll-down) (setq-local mwheel-scroll-up-function ‘image-scroll-up)) (add-hook ‘image-mode-hook #’set-image-mode-mwheel-scroll-function) ;;emacs启动的时候自动全屏(add-to-list ‘default-frame-alist ‘(fullscreen . maximized)) ;(require ‘sr-speedbar) //隐藏工具栏, 菜单栏, 滚动条;(tool-bar-mode 0);(menu-bar-mode 0);(scroll-bar-mode 0) (global-auto-revert-mode t) ;(add-hook ‘c-mode-common-hook ( lambda() ( c-set-style “k&amp;r” ) ) ) ;;设置C语言默认格式(add-hook ‘c++-mode-common-hook ( lambda() ( c-set-style “k&amp;r” ) ) ) ;;设置C++语言默认格式 ;(global-set-key [(f8)] ‘loop-alpha) ;;注意这行中的F8 , 可以改成你想要的按键 (setq alpha-list ‘((85 55) (100 100))) (defun loop-alpha () (interactive) (let ((h (car alpha-list))) ((lambda (a ab) (set-frame-parameter (selected-frame) ‘alpha (list a ab)) (add-to-list ‘default-frame-alist (cons ‘alpha (list a ab))) ) (car h) (car (cdr h))) (setq alpha-list (cdr (append alpha-list (list h)))) )) ;打开emacs 之后 按F8 可以在透明 和不透明之间切换… (setq is-alpha nil) (defun transform-window (a ab) (set-frame-parameter (selected-frame) ‘alpha (list a ab)) (add-to-list ‘default-frame-alist (cons ‘alpha (list a ab)))) (global-set-key [(f8)] (lambda() (interactive) (if is-alpha (transform-window 100 100) (transform-window 85 50)) (setq is-alpha (not is-alpha)))) ;; Enable EDE (Project Management) features(global-ede-mode 1) (custom-set-variables‘(semantic-default-submodes (quote (global-semantic-decoration-mode global-semantic-idle-completions-modeglobal-semantic-idle-scheduler-mode global-semanticdb-minor-modeglobal-semantic-idle-summary-mode global-semantic-mru-bookmark-mode)))‘(semantic-idle-scheduler-idle-time 3)) (semantic-mode) ;; smart complitions(require ‘semantic/ia)(setq-mode-local c-mode semanticdb-find-default-throttle‘(project unloaded system recursive))(setq-mode-local c++-mode semanticdb-find-default-throttle‘(project unloaded system recursive)) ;;;; TAGS Menu(defun my-semantic-hook ()(imenu-add-to-menubar “TAGS”)) (add-hook ‘semantic-init-hooks ‘my-semantic-hook) ;;;; Semantic DataBase存储位置(setq semanticdb-default-save-directory(expand-file-name “~/.emacs.d/semanticdb”)) ;; 使用 gnu global 的TAGS。(require ‘semantic/db-global)(semanticdb-enable-gnu-global-databases ‘c-mode)(semanticdb-enable-gnu-global-databases ‘c++-mode) ;;;; 缩进或者补齐;;; hippie-try-expand settings(setq hippie-expand-try-functions-list‘(yas/hippie-try-expandsemantic-ia-complete-symboltry-expand-dabbrevtry-expand-dabbrev-visibletry-expand-dabbrev-all-bufferstry-expand-dabbrev-from-killtry-complete-file-name-partiallytry-complete-file-nametry-expand-all-abbrevs)) (defun indent-or-complete ()“Complete if point is at end of a word, otherwise indent line.”(interactive)(if (looking-at “\\&gt;”)(hippie-expand nil)(indent-for-tab-command))) (defun yyc/indent-key-setup ();”Set tab as key for indent-or-complete”(local-set-key [(tab)] ‘indent-or-complete)) (require ‘cedet) (semantic-mode 1) (global-ede-mode 1) (global-set-key (kbd ““) ‘sr-speedbar-toggle) ;;sr-speedbar按键绑定 ;;;; 自动启动ecb，并且不显示每日提示 (setq ecb-auto-activate t ecb-tip-of-the-day nil)","categories":[],"tags":[]},{"title":"Ubuntu下打开Anaconda图形界面","slug":"anacondaStart","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/anacondaStart/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/anacondaStart/","excerpt":"","text":"在终端下输入anaconda-navigator","categories":[],"tags":[]},{"title":"vim快捷键","slug":"LearnVim/VimKeyCut","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/LearnVim/VimKeyCut/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/LearnVim/VimKeyCut/","excerpt":"","text":"[参考链接]https://www.cnblogs.com/jy02414216/archive/2012/10/29/2745001.html[参考链接]https://blog.csdn.net/scaleqiao/article/details/45153379 VIM光标跳转 h, j, k, l :左, 下, 上, 右gj :向下移动一行gk :向上移动一行gg :移动到文件首G :移动到文件末尾w :向前移动一个单词,光标停留在下一个单词开头W :向前移动一个单词,光标停留在下一个单词开头,但忽略标点e :向前移动一个单词,光标停留在单词末尾E :移动到单词末尾,如果有标点则移动到标点处( :前移一句) :后移一句{ :前移一段} :后移一段0 :移动到行首$ :移动到行尾n| :移动到第n列nG / ngg :移动到第n行H :光标移动到屏幕顶端M :光标移动到屏幕中间一行L :光标移动到屏幕最底端一行 VIM翻屏指令ctrl+f :下翻一屏ctrl+b :上翻一屏ctrl+d :下翻半屏ctrl+u :上翻半屏ctrl+e :向下滚动一行ctrl+y :向上滚动一行n% :到文件n%的位置zz :将当前行移动到屏幕中央zt :将当前行移动到屏幕顶端zb :将当前行移动到屏幕底端VIM分屏指令 :new (name)，新建一个未命名(文件名为name)的窗口件并分屏， 快捷键，Ctrl+W，然后马上按n键:split (name) / 缩写:sp name 水平分屏，将当前屏分为两个，水平的。 Ctrl + w, s:vsplit (name) / 缩写:vs name 垂直分屏，将当前屏分为两个，垂直的。 Ctrl + w, v:only 取消分屏，取消当前的屏，当前屏指的是光标所在屏。 关闭当前屏: Ctrl+w，c。 切换窗口:Ctrl + w, w 后一个Ctrl + w, p 前一个 Ctrl + w, h 四个方向Ctrl + w, iCtrl + w, kCtrl + w, l 关闭其他窗口:Ctrl + w, o 载入文件 :vs 文件路径/文件名 在新的垂直分屏中打开文件 :sv 文件路径/文件名 在新的水平分屏中打开文件 VIM字母转换 gu:字符转换小写gU:字符转换大写gul / gUl :将光标所在字符转换为小写/大写guh / gUh :将光标左边字符转换为小写/大写 VIM复制粘贴 x :剪切右边字符X :剪切左边字符yy / Y :复制整行文本:m,ny :复制m行到n行的文本v :开始选择文本V :选择当前行的文本dd :删除当前行D :删除光标后面的文本p :在光标之后粘贴P :在光标之前粘贴 VIM自带的补全 C-x C-v :补全vim选项和命令。C-x C-l :整行补全。C-x C-f :自动补全文件路径。弹出菜单后，按C-f循环选择，当然也可以按 C-n和C-p。C-x C-p 和 C-x C-n :用文档中出现过的单词补全当前的词。 直接按C-p和C-n也可以。C-x C-o :编程时可以补全关键字和函数名啊。C-x C-i :根据头文件内关键字补全。C-x C-d :补全宏定义。C-x C-n :按缓冲区中出现过的关键字补全。 直接按C-n或C-p即可。 VIM插入模式 i :在光标处插入I :在行首插入a :在光标后面插入A :在行尾插入o :在下一行插入O :在上一行插入Esc :进入一般模式 VIM保存文件:w :保存文件但不退出vi:w file :将修改另外保存到file中，不退出vi:w! :强制保存，不退出vi:wq :保存文件并退出vi:wq! :强制保存文件，并退出vi:q :不保存文件，退出vi:q! :不保存文件，强制退出vi:e! :放弃所有修改，从上次保存文件开始再编辑命令历史ZZ :保存文件 VIM格式化代码 格式化的核心是= + 位置gg=G :格式化整个文档=G :向下格式化所有行n== :向下格式化n行n= + 方向: 朝某个方向格式化n行== :格式化当前行={ :向上格式化代码块=} :向下格式化代码块mg=ng:格式化m行到n行 vim插入内容:r 文件名 :将文件的内容插入到光标处:r !命令 :将命令的结果插入到光标处:! 命令 :只显示命令的结果不写入 vim自定义快捷键:map 快捷键 操作方式 :快捷键使用Ctrl-v-某字母,使用Ctrl-某字母,可以调出命令:ab 快捷字 想要写入的文字 :当编辑文本出现快捷字之后,按下回车或者空格,快捷字就会变成相要写入的文字 想要保存快捷键的话,需要在家目录下新建一个.vimrc文件,然后在里面写入map 快捷键 操作方式,ab 快捷字 想要写入的文字,(这里不需要冒号),然后保存就可以了 vim宏录制qa进入宏录制，q退出，@a执行，n@a执行n次 宏录制是一个非常强大的功能，可以执行相同的操作n次。比如我有一个数字1，我按下qa，按下V选中1，按下y复制1，再按下p，1就被复制到下一行，然后按下Ctrl-a，将1变成2，最后按下q。我的宏就录制好了，首先输入1，然后在一般模式下输入100@a，就有从1到100个数字列出来了。","categories":[],"tags":[]},{"title":"vim配置","slug":"LearnVim/vimrc","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/LearnVim/vimrc/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/LearnVim/vimrc/","excerpt":"","text":"“ 开启语法高亮syntax on “ 设置字体set guifont=courier\\ 20 “ 检测文件类型filetype on “ 设置取消备份，禁止临时文件生成set nobackupset noswapfile “ 设置在Vim中可以使用鼠标，防止终端无法拷贝set mouse=a “ 显示当前行号和列号set ruler “ 在状态栏显示正在输入的命令set showcmd “ 总是显示状态栏(Powerline需要2行)set laststatus=2 “ 显示行号set number “ 设置代码匹配,包括括号匹配情况set showmatch “ 设置C/C++方式自动对齐set autoindentset cindentset smartindent “ 设置tab宽度set tabstop=4 “ 设置自动对齐空格数set shiftwidth=4 “ 按退格键时可以一次删除4个空格set softtabstop=4 “ 自动补全配置让Vim补全菜单行为跟IDE一致set completeopt=longest,menu “ 增强模式中的命令行自动完成操作set wildmenu “ 设置NerdTreemap :NERDTreeMirrormap :NERDTreeToggle colorscheme slate call pathogen#infect()syntax onfiletype plugin indent on “ TagBar 自动生成参数和方法“ Then the F8 key will toggle the Tagbar window.map :TagbarTogglemap :TagbarToggle “syntastic 保存检查代码时候传入参数let g:syntastic_java_javac_args=”-cp ../../lib:../../bin -sourcepath ../../bin -Djava.ext.dirs=../../lib -d ../../bin” “vim-commentary“块模式：v 命令选中需要注释的内容，gc 注释，取消注释也是同样的步骤。“V 命令，选中当前行，gc 注释当前正行内容，这个使用是最方便的，也是最多的。 “bufexplorer“命令模式：\\be 跳转到缓冲区窗口，然后 选择需要的缓冲区回车","categories":[],"tags":[]},{"title":"c++和java在linux下的编译运行","slug":"Linux/Compile","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/Linux/Compile/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Linux/Compile/","excerpt":"","text":"c++的编译运行g++ &ensp;text.cpp -o &ensp;text.out./text.out 如果不加 -o ,则默认为a.outg++ &ensp;text.cpp./a.out java的编译运行javac &ensp;Text.javajava &ensp;Text","categories":[],"tags":[]},{"title":"缩略linux路径","slug":"Linux/CutPathName","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/Linux/CutPathName/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Linux/CutPathName/","excerpt":"","text":"emacs ~/.bashrc 将 if [ “$colovr prompt” = yes ]; then PS1=’${debian chroot:+($debian chroot)}[\\033[01;32m]\\u@\\h[\\033[00m]:[\\033[01;34m]\\w[\\033[00m]\\$ ‘else PS1=’${debian chroot:+($debian chroot)}\\u@\\h:\\w\\$ ‘ 里面的小写w改为大写的W就可以缩略路径名，避免进入的目录多了之后导致路径名太长，可以使用pwd来查看全目录","categories":[],"tags":[]},{"title":"centos7中使用yum安装ntfs-3g","slug":"Linux/Install_Ntfs-3g","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/Linux/Install_Ntfs-3g/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Linux/Install_Ntfs-3g/","excerpt":"","text":"加源wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo 安装yum update;yum install ntfs-3gyum install ntfs-3g","categories":[],"tags":[]},{"title":"设置终端打开的快捷键","slug":"Linux/SetTerminalKey","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/Linux/SetTerminalKey/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Linux/SetTerminalKey/","excerpt":"","text":"打开设置，找到键盘选项，在右边往下拉，找到‘+’，名称填写：Terminal；命令填写：/usr/bin/gnome-terminal;我的快捷键：C-M-t","categories":[],"tags":[]},{"title":"Linux将文件内容输出重定向","slug":"Linux/outputRedirection","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/Linux/outputRedirection/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Linux/outputRedirection/","excerpt":"","text":"将一个文件内容重定向至另一个文件中 1cat hello.cpp &gt; world.cpp 将一个文件中的内容重定向至剪贴板中 123sudo apt install xselcat hello.cpp | xsel -b -i //将hello.cpp内容写入剪贴板中","categories":[],"tags":[]},{"title":"设置root密码","slug":"Linux/setRoot","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/Linux/setRoot/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Linux/setRoot/","excerpt":"","text":"Ubuntu下 su:出现： authentication failure的解决办法执行：sudo passwd root","categories":[],"tags":[]},{"title":"vim中修改颜色配置","slug":"LearnVim/ColorSetting","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/LearnVim/ColorSetting/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/LearnVim/ColorSetting/","excerpt":"","text":"参考链接:&ensp;https://blog.csdn.net/qq_16912257/article/details/77957248 在linux终端中输入cd /usr/share/vim/vim74/colors进入目录然后输入ls查看vim中自带的配色方案 修改~/.vimrc配置在.vimrc中添加colorscheme peachpuffpeachpuff为主题的名字","categories":[],"tags":[]},{"title":"关于JFrame使用setBackground()设置背景色没反应的问题","slug":"Java/setBackground","date":"2019-01-19T10:30:53.948Z","updated":"2019-01-19T10:30:53.948Z","comments":true,"path":"2019/01/19/Java/setBackground/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Java/setBackground/","excerpt":"","text":"参考链接:&ensp;https://zhidao.baidu.com/question/263731760.html参考链接:&ensp;https://blog.csdn.net/qq_34970891/article/details/69665986 原因:JFrame当中会默认使用流式布局管理器(FlowLayout)将整个窗体进行覆盖操作，也就是说设置的颜色确实是存在的，只是被布局管理器给覆盖住了，所以无法看见。 1. 如果直接使用Frame,则修改背景色使用setBackColor(Color.black); 2. 使用JFrame修改背景色 方法一: 调用getContentPane()方法得到一个contentPane容器，然后将其设置为不可见12setBackground(Color.black);getContentPane().setVisible(true); 方法二: 在JFrame当中添加一个面板容器，使得面板容器对窗体形成一个覆盖后，直接设置面板的背景颜色就可以达到相当于对窗体背景颜色进行设置的效果12Container con = getContentPane();con.setBackground(Color.black);","categories":[],"tags":[]},{"title":"java中的消息对话框","slug":"Java/sendMessage","date":"2019-01-19T10:30:53.948Z","updated":"2019-01-19T10:30:53.948Z","comments":true,"path":"2019/01/19/Java/sendMessage/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Java/sendMessage/","excerpt":"","text":"12JOptionPane.showMessageDialog(this, \"当前位置有棋子\"); //弹出对话框,this表示当前对象int result = JOptionPane.showConfirmDialog(this, \"是否退出游戏\"); //弹出对话选择框,是返回0, 否返回1,取消返回2,可以使用int型变量保存,方便判断选择的是哪一个","categories":[],"tags":[]},{"title":"java题库导出","slug":"Java/questionBankExport","date":"2019-01-19T10:30:53.948Z","updated":"2019-01-19T10:30:53.948Z","comments":true,"path":"2019/01/19/Java/questionBankExport/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Java/questionBankExport/","excerpt":"","text":"题库链接: https://pan.baidu.com/s/1QRMfkJWUWN6F-dP5GaQ8jQ &emsp;&emsp;提取码：eus0jd-gui反编译工具链接: https://pan.baidu.com/s/1v0a6asCluIgqeswpR515ww &emsp;&emsp;提取码：308t 该题库软件支持jdk1.8版本 下载完成之后，将jd-gui-1.4.0.jar放置在该软件目录下的jar/bin/中,打开cmd命令行窗口，再执行:java.exe -jar jd-gui-1.4.0.jar，即可打开反编译的软件 通过反编译可以查看Tiku.jar中的内容，发现对象流指向的输出流对象是Problem类,这样我们可以先将题库中的内容提取出来,然后转型为ArrayList,之后就可以通过循环将文件内容输入到文本中。这里为了保持目录的一致性，可以先用数组存储每一个章节题目的位置信息，按照章节来将题库导出，File类中有mkdir()方法，可以创建目录，使用write()方法可以写入内容,由于将题目写入txt文本中之后,格式并不太友好,我这里使用缓冲流，因为里面有newline()方法，可以添加空行。我将ArrayList中的内容遍历，如果是’\\n’则使用newline()添加空行，这样使得文本内容更易于查看. 将Tiku.jar文件导入eclipse中，将如下代码添加到eclipse文本窗口中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import java.io.BufferedWriter;import java.io.EOFException;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileWriter;import java.io.IOException;import java.io.ObjectInputStream;import java.io.Serializable;import java.util.ArrayList;import quesion.data.Problem;/** * @author Administrator * */public class GetData implements Serializable&#123; String readPath; //题库目录 String writePath; //导出目录 String chapter[]; //存储章节信息 String type[]; //存储题目类型 ArrayList&lt;Problem&gt; problems; //problems存储题库内容 File readFile; File writeFile; FileInputStream fis; ObjectInputStream ois; FileWriter fw; BufferedWriter bw; public GetData() &#123; readPath = &quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\java\\\\题库\\\\&quot;; writePath = &quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\data\\\\&quot;; chapter = new String[15]; for(int i = 0; i &lt; 15; i++) chapter[i] = &quot;第&quot; + (i + 1) + &quot;章\\\\&quot;; type = new String[4]; type[0] = &quot;读程题&quot;; type[1] = &quot;判断题&quot;; type[2] = &quot;挑错题&quot;; type[3] = &quot;选择题&quot;; &#125; public void importFile() &#123; File directory; for(int i = 0; i &lt; 15; i++) &#123; for(int j = 0; j &lt; 4; j++) &#123; readFile = new File(readPath + chapter[i] + type[j] + &quot;.data&quot;); //将每一个文件的地址提取出来 directory = new File(writePath + chapter[i]); if(!directory.exists()) //判断目录是否存在，不存在就创建 directory.mkdir(); writeFile = new File(writePath + chapter[i] + type[j] + &quot;.txt&quot;); //文件输出地址 if(readFile.exists()) &#123; //如果读取的文件存在 try &#123; fis = new FileInputStream(readFile); //文件输入流 ois = new ObjectInputStream(fis); //对象输入流 fw = new FileWriter(writeFile); bw = new BufferedWriter(fw); //缓冲流 problems = new ArrayList&lt;Problem&gt;(); problems = (ArrayList&lt;Problem&gt;)(ois.readObject()); //对象输入流使用readObject()方法读取一个对象到程序中 for(Problem p : problems) &#123; //循环遍历problems String s = p.content; //content是题库代码中的题目属性 int flag = 0; //这里实际题库中会出现第一个字符就是&apos;\\n&apos;,我这里使用flag标记，不在第一排输出空行 if(p.content != null) &#123; for(int m = 0; m &lt; s.length(); m++) if(s.charAt(m) == &apos;\\n&apos; &amp;&amp; flag != 0) &#123; bw.newLine(); //添加新的行数 &#125; else &#123; bw.write(s.charAt(m)); flag = 1; &#125; &#125; bw.newLine(); s = p.correctAnswer; //correctAnswer是题库代码中的答案属性 flag = 0; if(p.correctAnswer != null) &#123; for(int m = 0; m &lt; s.length(); m++) if(s.charAt(m) == &apos;\\n&apos; &amp;&amp; flag != 0) &#123; bw.newLine(); &#125; else &#123; bw.write(s.charAt(m)); flag = 1; &#125; &#125; bw.newLine(); &#125; ois.close(); //关闭各个流 fis.close(); bw.close(); &#125; catch (FileNotFoundException e) &#123; &#125; catch (IOException e) &#123; &#125; catch (ClassNotFoundException e) &#123; &#125; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; GetData data = new GetData(); data.importFile(); &#125;&#125;","categories":[],"tags":[]},{"title":"String类","slug":"Java/javaString","date":"2019-01-19T10:30:53.948Z","updated":"2019-01-19T10:30:53.948Z","comments":true,"path":"2019/01/19/Java/javaString/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Java/javaString/","excerpt":"","text":"String类型访问里面的每一个字符可以使用s.charAt(i)1String s = \"hello\"; //s.charAt(0) = h 产生随机数123double b = Math.random(); //产生[0,1)之间的小数int n = (int)(b * 5); //产生[0,5)之间的整数int m = 1 + (int)(b * 6); //产生[1,6]之间的整数 public boolean equals(String s),比较当前String对象字符序列和参数的字符序列是否相等equalsIgnoreCase()方法在比较时会忽略大小写123456String Tom = new String(\"木头人\");String Marry = new String(\"植物人\"); String Jack = new String(\"植物人\"\");System.out.println(Tom.equals(Marry)); //结果为falseSystem.out.println(Jack.equals(Marry)); //结果为true System.out.println(Jack == Marry); //结果为false 由于string对象Marry和Jack存放的是引用,其所在的内存不一样,因而内容相同却不相等 public boolean startsWith(String s)/endsWith(String s)s1.startsWith(s2)&emsp;:判断当前String对象的字符序列前缀是否和参数相同s1.endsWith(s2)&emsp;:判断当前String对象的字符序列后缀是否和参数相同 public int compareTo(String s)s1.compareTo(s2)&emsp; :按照字典序比较s1和s2的字符序列是否相同,相同返回0,s1 &gt; s2返回正值, s1 &lt; s2返回负值 public boolean contains(String s)s1.contains(s2):判断s1中是否包含s2123String Tom = \"students\";System.out.println(Tom.contains(\"stu\")); //值为tureSystem.out.println(Tom.contains(\"ab\")); //值为false public int indexOf(String s) / lastIndexOf(String s)s1.indexOf(s2):从s1中的0位置开始搜索s2,并返回首次出现s2的位置,如果没有找到就返回-1,lastIndexOf()则是从末尾开始搜索indexOf(String str, int startpoint)重载方法,startpoint指定检索的开始位置12345String tom = \"I am a good cat\";tom.indexOf(\"a\"); //值为2tom.indexOf(\"good\", 2); //值为7tom.indexOf(\"a\", 7); //值为13tom.indexOf(\"w\", 2); //值为-1 public String substring(int startpoint)s2 = s1.substring(start); //从start位置开始复制s1中字符串到s2中s2 = s1.substring(start, end) //从start位置开始截至end-1复制s1中字符串到s2中123String s = \"abcdefg\";String s1 = s.substring(0); //s1 = \"abcdefg\";String s2 = s.substring(2, 4); //s2 = \"cd\"; public String trim()去掉字符序列中的前后空格12String s = \" abcd \";System.out.println(s.trim()); //结果为abcd public void getChars(int start, int end, char c[], int offset)将String对象从start到end-1的字符存放到从offset位置开始的c数组中1234String s = \"abcdefg\";char c[] = new char[10];s.getChars(0, 2, c, 0);System.out.println(c); //输出结果为ab public char[] toCharArray()将String中的字符序列全部存放在数组中123String s = \"abcdefghijk\";char c[] = s.toCharArray();System.out.println(c); //输出结果为abcdefghijk public boolean matches(String regex)判断当前字符串是否匹配给定的正则表达式, 是返回true, 否则返回false123String s = \"[1234]?\";String s1 = \"123\";System.out.println(s1.matches(s1)); public String repalceAll(String regex, String replacement)匹配当前对象中字符序列和regex中相同的, 用replacement全部替换123String s = \"hello\";String s1 = \"hello world\";System.out.println(s1.replacement(s, \"welcome to my\")); //结果为welcome to my world","categories":[],"tags":[]},{"title":"java图形库学习","slug":"Java/graphicsLibrary","date":"2019-01-19T10:30:53.948Z","updated":"2019-01-19T10:30:53.948Z","comments":true,"path":"2019/01/19/Java/graphicsLibrary/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Java/graphicsLibrary/","excerpt":"","text":"需要继承JFrame类来画窗口 =&gt; public class Game extends JFrame {}setTitle(String s); //设置窗口标题setLocation(int x, int y); //设置窗口位置setSize(int width, int height); //设置窗口宽和高setVisible(true); //设置窗口可见,默认为flase,这个方法放在setLocation()和setSize后面较好,我放在前面窗口为黑色,本来默认为白色的 paint方法画图定义后自动调用123456789101112public class paint(Graphics g) &#123; Color c = g.getColor(); //记录原来的颜色 Font f = g.getFont(); //记录原来的字体 g.setColor(Color.BLACK); //设置画线的颜色 g.drawLine(int x1, int y1, int x2, int y2); //两点画直线 g.drawRect(int x, int y, int width, int height); //左上角顶点加宽高画矩形 g.fillRect(int x, int y, int width, int height); //画填充矩形 g.setFont(new Font(\"楷体\", Font.BOLD, 40)); //设置字体为楷体,粗体,大小为40 g.drawString(str, int x, int y); //画出str字符串 g.setColor(c); //变回原来的颜色 g.setFont(f); //变回原来的字体&#125; GameUtil工具类导入图片1234567891011121314151617181920212223242526import java.awt.Image;import java.awt.image.BufferedImage;import java.io.IOException;import java.net.URL;import javax.imageio.ImageIO; public class GameUtil &#123; // 工具类最好将构造器私有化。 private GameUtil() &#123; &#125; public static Image getImage(String path) &#123; BufferedImage bi = null; try &#123; URL u = GameUtil.class.getClassLoader().getResource(path); bi = ImageIO.read(u); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return bi; &#125;&#125; 在Game类里面调用GameUtilImage imag = GameUtil.getImage(“images/picture.png”); //我建立的一个images包,用来存储图片,引号里面为图片的路径g.drawImage(imag, x, y, width, height, null); //imag图片,位置,宽高,观察者 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.Image;import javax.swing.JFrame;public class MyGame extends JFrame&#123; Image imag = GameUtil.getImage(\"images/text1.png\"); //指定图片 @Override public void paint(Graphics g) &#123; Color c = g.getColor(); Font f = g.getFont(); g.setColor(Color.BLUE); //设置线体颜色 g.drawLine(100, 100, 650, 100); //直线 g.drawRect(50, 150, 200, 200); //空心矩形 g.fillRect(550, 150, 200, 200); //实体矩形 g.drawOval(300, 150, 200, 200); //圆形 g.setFont(new Font(\"楷体\", Font.BOLD, 90)); //设置字体 g.drawString(\"How are you？\", 100, 100); //写字 g.drawImage(imag, 250, 400, 300, 300, null); //插入图片 g.setColor(c); //线条颜色变为原来的样子 g.setFont(f); //字体变为原来的样子 &#125; public void launchJFrame() &#123; this.setTitle(\"我的游戏\"); //设置窗口标题 this.setSize(800, 800); //设置窗口大小 this.setLocation(100, 100); //设置窗口位置 this.setVisible(true); //设置窗口可见 /*this.addWindowListener(new WindowAdapter() &#123; //叉掉窗口后，结束窗口所在的应用程序 @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); */ this.setDefaultCloseOperation(EXIT_ON_CLOSE); //叉掉窗口后，结束窗口所在的应用程序 &#125; public static void main(String args[]) &#123; MyGame game = new MyGame(); game.launchJFrame(); &#125;&#125; 设置图片的大小public Image getScaledInstance(int width, int height, int hints) &emsp;//hints - 指示用于图像重新取样的算法类型的标志(这句话不知道是什么意思,照着下面的写就对了)12Image img = GameUtil.getImage(\"images/text1.jpg\");img = img.getScaledInstance(width, height, Image.SCALE_DEFAULT); 如果是要获取图片的大小,直接使用getWidth()和getHeight()方法就可以了12width = img.getWidth();height = img.getheight(); 双缓冲技术解决闪烁原理大概是:先将所需要画的东西加载到缓冲区,然后将缓冲区中的内容全部画到屏幕上,这样就可以避免因为屏幕加载的东西太多导致屏幕疯狂闪烁12345678public void paint(Graphics g)&#123; BufferedImage imag = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); //构建缓冲区 Graphics g2 = imag.creatGraphics(); //新建一支画笔,使用这支画笔来将内容画到缓冲区中 g2.drawRect(...); //括号里面的参数就不写了,此处用来说明一些画图操作 g2.drawImag(...); g2.fillOval(...); g.drawImage(imag, x, y, width, height, null); //将内容画到屏幕上&#125;","categories":[],"tags":[]},{"title":"linux终端下实现有道翻译","slug":"Interest/youdao","date":"2019-01-19T10:30:53.948Z","updated":"2019-01-19T10:30:53.948Z","comments":true,"path":"2019/01/19/Interest/youdao/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Interest/youdao/","excerpt":"","text":"[参考链接1]https://blog.csdn.net/jiangxiaoma111/article/details/38461447[参考链接2]https://blog.csdn.net/Naruto_____/article/details/47400003 有道翻译的代码如下先将此代码复制到一个文件里面，并将这个文件放到～/Documents下，命名为youdao.py 版本一123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#! /usr/bin/pythonimport re;import urllib;import urllib2;import sys;def debug(): xml = open(\"word.xml\").read(); print get_text(xml); print get_elements_by_path(xml, \"custom-translation/content\"); #print_translations(xml, False, False);def get_elements_by_path(xml, elem): if type(xml) == type(''): xml = [xml]; if type(elem) == type(''): elem = elem.split('/'); if (len(xml) == 0): return []; elif (len(elem) == 0): return xml; elif (len(elem) == 1): result = []; for item in xml: result += get_elements(item, elem[0]); return result; else: subitems = []; for item in xml: subitems += get_elements(item, elem[0]); return get_elements_by_path(subitems, elem[1:]);textre = re.compile(\"\\!\\[CDATA\\[(.*?)\\]\\]\", re.DOTALL);def get_text(xml): match = re.search(textre, xml); if not match: return xml; return match.group(1);def get_elements(xml, elem): p = re.compile(\"&lt;\" + elem + \"&gt;\" + \"(.*?)&lt;/\" + elem + \"&gt;\", re.DOTALL); it = p.finditer(xml); result = []; for m in it: result.append(m.group(1)); return result;GREEN = \"\\033[1;32m\";DEFAULT = \"\\033[0;49m\";BOLD = \"\\033[1m\";UNDERLINE = \"\\033[4m\";NORMAL = \"\\033[m\";RED = \"\\033[1;31m\"def crawl_xml(queryword): return urllib2.urlopen(\"http://dict.yodao.com/search?keyfrom=dict.python&amp;q=\" + urllib.quote_plus(queryword) + \"&amp;xmlDetail=true&amp;doctype=xml\").read();def print_translations(xml, with_color, detailed): #print xml; original_query = get_elements(xml, \"original-query\"); queryword = get_text(original_query[0]); custom_translations = get_elements(xml, \"custom-translation\"); print BOLD + UNDERLINE + queryword + NORMAL; translated = False; for cus in custom_translations: source = get_elements_by_path(cus, \"source/name\"); print RED + \"Translations from \" + source[0] + DEFAULT; contents = get_elements_by_path(cus, \"translation/content\"); if with_color: for content in contents[0:5]: print GREEN + get_text(content) + DEFAULT; else: for content in contents[0:5]: print get_text(content); translated = True; yodao_translations = get_elements(xml, \"yodao-web-dict\"); printed = False; for trans in yodao_translations: webtrans = get_elements(trans, \"web-translation\"); for web in webtrans[0:5]: if not printed: print RED + \"Translations from yodao:\" + DEFAULT; printed = True; keys = get_elements(web, \"key\"); values = get_elements_by_path(web, \"trans/value\"); summaries = get_elements_by_path(web, \"trans/summary\"); key = keys[0].strip(); value = values[0].strip(); #summary = summaries[0].strip(); #lines = get_elements(summary, \"line\"); if with_color: print BOLD + get_text(key) + \":\\t\" +DEFAULT + GREEN + get_text(value) + NORMAL; #for line in lines: # print GREEN + get_text(line) + DEFAULT; #print get_text(summary) + DEFAULT; else: print get_text(value); #print get_text(summary); #translated = True; #if not detailed: # break def usage(): print \"usage: dict.py word_to_translate\";def main(argv): if len(argv) &lt;= 0: usage(); #debug(); sys.exit(1); xml = crawl_xml(\" \".join(argv)); print_translations(xml, True, False); if __name__ == \"__main__\": main(sys.argv[1:]); 版本二(simply)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/env python# -*- coding:utf-8 -*-# API key：273646050# keyfrom：11pegasus11import jsonimport systry: # py3 from urllib.parse import urlparse, quote, urlencode, unquote from urllib.request import urlopenexcept: # py2 from urllib import urlencode, quote, unquote from urllib2 import urlopendef fetch(query_str=''): query_str = query_str.strip(\"'\").strip('\"').strip() if not query_str: query_str = 'python' print(query_str) query = &#123; 'q': query_str &#125; url = 'http://fanyi.youdao.com/openapi.do?keyfrom=11pegasus11&amp;key=273646050&amp;type=data&amp;doctype=json&amp;version=1.1&amp;' + urlencode(query) response = urlopen(url, timeout=3) html = response.read().decode('utf-8') return htmldef parse(html): d = json.loads(html) try: if d.get('errorCode') == 0: explains = d.get('basic').get('explains') for i in explains: print(i) else: print('无法翻译') except: print('翻译出错，请输入合法单词')def main(): try: s = sys.argv[1] except IndexError: s = 'python' parse(fetch(s))if __name__ == '__main__': main() 创建一个脚本，放在～/下，命名为fy 123456#! /bin/bashwhile [ $# -ne 0 ]do python ~/Documents/youdao.py $1 shiftdone 赋予脚本可执行的权限chmod u+x fy 将该脚本链接到/usr/bin下sudo ln -s ~/fy /usr/bin/fy 输入fy 单词/汉语 就可以翻译了Oh yeah！ 注:这里其实还有一种很神奇的办法,在Linux之中有一种叫做命令别名的东西,即alias 别名=’命令参数’比如说这里使用chmod u+x youdao.py,讲youdao.py变为可执行文件之后,可以使用命令./youdao.py来执行,那么我该怎么做呢,首先vim .bashrc,打开.bashrc文件,将alias fy=’/home/username/./youdao.py’添加到文件的末尾,然后使用source .bashrc来使其生效即可,/home/username/是你的目录名,fy=’/home/username/./youdao.py’的意思是将/home/username/./youdao.py起一个别名,为fy,这样你虽然命令为fy,但其实是后面的那一长串命令的效果","categories":[],"tags":[]},{"title":"c++ 和 java添加环境变量","slug":"Java/environmentVariable","date":"2019-01-19T10:30:53.948Z","updated":"2019-01-19T10:30:53.948Z","comments":true,"path":"2019/01/19/Java/environmentVariable/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Java/environmentVariable/","excerpt":"","text":"1234//MinGW(以下根据自己的目录来)Path: E:\\BaiduNetdiskDownload\\MinGW\\mingw64\\bin INCLUDE: E:\\BaiduNetdiskDownload\\MinGW\\mingw64\\includeLib: E:\\BaiduNetdiskDownload\\MinGW\\mingw64\\libx 1234JAVA_HOME： F:\\Java\\jdk-10.0.2（根据自己的安装目录来）CLASSPATH： .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jarPath：第一个： %JAVA_HOME%\\bin 第二个： %JAVA_HOME%\\jre\\bin","categories":[],"tags":[]},{"title":"java基本数据类型","slug":"Java/dataType","date":"2019-01-19T10:30:53.948Z","updated":"2019-01-19T10:30:53.948Z","comments":true,"path":"2019/01/19/Java/dataType/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Java/dataType/","excerpt":"","text":"char类型转化为小写字母大写为toUpperCase();1char c = input.nextLine().toLowerCase().toCharArray()[0]; float类型常量后面必须要有后缀f或Fdouble类型后面有后缀d或D,但是可以省略1float x = 3.14f; double类型可以进行模运算1double x = 3.0 / 2; //x的值为1.0 数字格式化 123double b = 3.150;NumberFormat nf = NumberFormat.getInstance();nf.format(b); //3.15 将Double转化为Integer类型Double d = 3.7; 12int n = d.inValue(); //double转化为int类型Integer it = Integer.valueOf(n); //int类型转化为double类型 double类型保留小数 123DecimalFormat df = new DecimalFormat(\"0.00\");double b = 3.141;df.format(b);","categories":[],"tags":[]},{"title":"坦克大战","slug":"Java/TankGame","date":"2019-01-19T10:30:53.948Z","updated":"2019-01-19T10:30:53.948Z","comments":true,"path":"2019/01/19/Java/TankGame/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Java/TankGame/","excerpt":"","text":"一、前言：整个坦克大战游戏做的比较匆忙的，里面也有很多的bug，代码也写得比较乱，整理博客的时候也不太好整理，本想优化一下下，可是由于整个项目结构的缘故，只能到这一步了，这次算是有了很多的经验，相信下次再做的时候，应该会好得多。 二、主体介绍游戏结构主要有游戏面板、设置面板、菜单栏、坦克、子弹以及提升属性的物品 玩法规则 我方坦克将敌方坦克打完，就算获胜 敌方坦克将我方坦克击败三次以及基地被摧毁，就算失败 打掉草地以及击败敌方坦克均会掉落物品，捡到后能提升属性值 三、代码实现一、游戏面板 游戏的开始面板将背景的图片，以及文字信息放了上去。这里由于出现了双缓冲技术，就在这里简单地说一下。 “双缓冲技术”的绘图过程如下 在内存中创建与画布一致的缓冲区 在缓冲区画图 将缓冲区位图拷贝到当前画布上 释放内存缓冲区 &emsp;双缓冲即在内存中创建一个与屏幕绘图区域一致的对象，先将图形绘制到内存中的这个对象上，再一次性将这个对象上的图形拷贝到屏幕上，这样能大大加快绘图的速度。 版本一（重写update方法）：重量级中repaint首先调用update方法，update然后再调用paint方法。再轻量级组件中直接调用paint。 12345678910private Image offScreenImage = null; public void update(Graphics g) &#123; if(offScreenImage == null) offScreenImage = this.createImage(500,500);//这是游戏窗口的宽度和高度 Graphics gOff = offScreenImage.getGraphics(); paint(gOff); g.drawImage(offScreenImage, 0, 0, null);&#125; 由于JFrame是轻量级的，因而可以重写paint方法 1234567891011private Image offScreenImage = null;public void paint(Graphics g) &#123; // 在重绘函数中实现双缓冲机制 offScreenImage = this.createImage(WIDTH, HEIGHT); // 获得截取图片的画布 gImage = offScreenImage.getGraphics(); gImage.setColor(gImage.getColor()); gImage.fillRect(0, 0, WIDTH, HEIGHT); // 填充缓冲 super.paint(gImage); //用gImage绘制图形, 代码根据具体情况 g.drawImage(offScreenImage, 0, 0, null); //将缓冲图案绘制在屏幕上 &#125; 这中方式就比较容易理解，而且通用1234567//初始化缓冲区BufferedImage imag = new BufferedImage(Constent.width, Constent.height, BufferedImage.TYPE_INT_RGB);Graphics g1 = imag.getGraphics();public void paint()&#123; g1.drawImage(x, y, width, height, null); g.drawImage(imag, x, y, width, height, null);&#125; 里面有个设置鼠标指针样式一个代码，不过找的指针图片不太好看，就没加上，就先把方法留在里面了。 123Image coursor = GameUtil.getImage(\"TankImage/logo.jpg\"); //设置指针图片//设置鼠标指针样式setCursor(Toolkit.getDefaultToolkit().createCustomCursor(coursor,new Point(0, 0), null)); 点击开始游戏和游戏设置的面板切换这里使用了鼠标监听1234public void mousegCliked(MouseEvent e)&#123; e.getX(); e.getY(); //获得鼠标的坐标&#125; 首先可以获得左上角和右下角的坐标位置，然后可以得到一个范围，只要是在这个范围内，都可以触发鼠标事件。 这里需要注意的是，要将事件监听添加到JFrame中。如果是点击开始游戏，那么触发事件后就可以将初始面板设置为不可见setVisible(false)，然后将它从JFrame中移除，再将新的面板添加进来，并设置其为可见。然后如果是点击游戏设置，那么就直接将该面板设置为可见 二、游戏设置窗口里面使用几个组件： JLabel: 标签 JRadioButton: 单选按钮 JSLider: 滑块 JTextField: 文本框 JButton: 按钮 JComboBox: 下拉菜单 12345678910111213141516jSlider = new JSlider(10, 100, initValue); //设置起始点值，终点值，默认值jsl.setPaintTicks(true); //设置滑块绘制刻度标记jsl.setMajorTickSpacing(10); //设置主刻度标记的间隔jsl.setMinorTickSpacing(2); //设置副刻度标记的间隔//这是修改坦克数量显示的事件处理jSlider.addChangeListener(new ChangeListener() &#123; public void stateChanged(ChangeEvent e) &#123; jTextField.setText(String.valueOf(jSlider.getValue())); &#125;&#125;);jTextField.setEditable(true); //设置文本不可更改jDialog.setModalityType(ModalityType.APPLICATION_MODAL); //设置该窗口打开后将其它窗口锁住 三、坦克大战的主面板 这个是游戏的主体，包含地图的绘制、显示所有坦克的移动和子弹发射的轨迹、物品掉落、游戏信息面板，坦克死亡、基地破坏的判定; 由于所有的地图、坦克、子弹都已经放在了各自的ArrayList容器之中，所以在paint方法之中就只需遍历容器中的每一个值，然后将里面的内容绘制在屏幕上。 1234567ArrayList&lt;Tank&gt; tank;tank = new ArrayList&lt;Tank&gt;;tank.add(tank1); //将坦克添加到容器中tank.add(tank2);Tank t = tank.get(i); //获得第i个坦克tank.remove(i); //移除第i个坦克 设置字体的颜色和样式setFont(new Font(“楷体”, Font.BOLD, 60)); //楷体，粗体，60号setColor(Color.BLACK); //白色 记录游戏的时间startTime = System.currentTimeMillis();setEnd.endTime = System.currentTimeMillis();setEnd.time = setEnd.endTime - setEnd.startTime; 四、菜单功能: 回到主面板、重新开始游戏、暂停游戏、恢复、退出游戏 回到主面板将游戏数据设置为结束的状态，然后将主面板设置为不可见，再移除坦克的键盘监听，新建一个主面板，再添加到JFrame中 重新开始游戏将游戏数据设置为结束的状态，然后初始化主面板 暂停游戏将所有的坦克和子弹，位置、方向不可改变，坦克不可键盘监听，这样线程还在运作，但是事实上所有的物体已经不能移动 恢复就反过来，将一切复原 退出游戏System.exit(0); 五、坦克设置 坦克的属性有坐标、方向、速度、是否存活、生命值、攻击力等这里速度可以直接设置坐标的改变量，然后也可以设置执行线程的时间，线程中有sleep()方法和坦克坐标移动的方法，避免由于线程执行太快而设置了线程暂停的时间，将时间缩短也可以提高速度 坦克的子弹使用了线程，当发射子弹后，就执行线程，线程中每隔一段时间将子弹的坐标改变，以此达到子弹自动运动的效果 在坦克的键盘监听之中，可以将按下的四个方向设置为boolean类型，如果直接按下方向键就进行移动，那么会有卡顿感，因为键盘监听是有延时的，当按下某一个方向的键时，就设置其为true，那么按下的过程中那个方向就一直为true，松开键时，将其设为false 坦克的碰撞检测:碰撞检测的理论是：将两个物体看做矩形，矩形相交就判定为相碰。 123Rectangle r1 = new Rectangle(x1, y1, width, height);Rectangle r2 = new Rectangle(x2, y2, width, height);rl.intersects(r2); //相交为true，否则为false 如果加上位移会相交，那么就刚好到碰不到物体的地方，否则可以移动 坦克的移动使用的是随机数12Random random = new Random();int n = random.nextInt(4); //随机数[0,3) 六、图片的插入这里使用了GameUtil类，使用这个类比较容易添加图片，这个是网上找的，自己不太会写 1234567891011121314151617public class GameUtil &#123; // 工具类最好将构造器私有化。 private GameUtil() &#123; &#125; public static Image getImage(String path) &#123; BufferedImage bi = null; try &#123; URL u = GameUtil.class.getClassLoader().getResource(path); bi = ImageIO.read(u); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return bi; &#125;&#125; 使用方法1Image image = GameUtil.getImage(路径); 最后附上我的源码: git@github.com:gydjsz/TankGame.git","categories":[],"tags":[]}]}