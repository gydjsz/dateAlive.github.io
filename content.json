{"meta":{"title":"梦之彼岸","subtitle":"只有神知道的世界","description":"这是一个神奇的世界","author":"gydjsz","url":"https://gydjsz.github.io"},"pages":[{"title":"","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"about/index.html","permalink":"https://gydjsz.github.io/about/index.html","excerpt":"","text":"开始搭建博客date: 2018-07-19 10:33:33先建好再说，让我的文章有一个归属，再美化 blog部分问题的修改date: 2018-07-21 20:05:36在blog中修改了search部分，使之搜索跳转到百度，目前还没有在本页面搜索的功能，修改了文章字体显示太大的部分。 有点小问题date: 2018-07-23 13:13:36不知道怎么回事呢，使用了markdown的语法却不能好好插入本地图片，使用外链又不是永久的，只好用base64图片编码，不过blog还是想尽量放一些图片上去，更直观一些。 评论区改善,快来瞧一瞧date: 2018-07-23 15:15:20blog新增评论功能，可以写下你的感想或者问题哦！ 目前已经支持站内搜索blogdate: 2018-07-24 22:30:14右边的搜索框已经更改为站内搜索,快来搜索你感兴趣的blog吧"},{"title":"","date":"2019-01-21T08:29:21.955Z","updated":"2019-01-21T08:29:21.911Z","comments":true,"path":"message/index.html","permalink":"https://gydjsz.github.io/message/index.html","excerpt":"","text":"欢迎在评论区留言。"},{"title":"","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"about/LearnEveryday/day2018_7_21.html","permalink":"https://gydjsz.github.io/about/LearnEveryday/day2018_7_21.html","excerpt":"","text":"在blog中修改了search部分，使之搜索跳转到百度，目前还没有在本页面搜索的功能，以后会添加。"}],"posts":[{"title":"java高级技术学习","slug":"Java/springLearn","date":"2019-06-02T07:20:45.999Z","updated":"2019-06-02T07:15:41.844Z","comments":true,"path":"2019/06/02/Java/springLearn/","link":"","permalink":"https://gydjsz.github.io/2019/06/02/Java/springLearn/","excerpt":"目录: Junit单元测试 反射 注解","text":"目录: Junit单元测试 反射 注解 一. Junit单元测试 Junit使用: 定义一个测试类: 测试类名: 被测试类Test =&gt; CalculatorTest 定义测试方法: 可以独立运行 方法名: test测试的方法名 =&gt; testAdd() 返回值: void 参数列表: 空参 给方法加@Test 运行测试方法,通过断言判断结果(正确为绿色,错误为红色) 如果需要资源的申请和释放,可以使用@Before和@After- @Before修饰的方法会在测试方法执行之前被自动执行 - @After修饰的方法会在测试方法执行之后被自动执行 - 无论测试方法的结果正确与否,这两个方法都会被执行 1234567//计算器类public class Calculator &#123; public int add(int a, int b)&#123; return a + b; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041public class CalculatorTest &#123; /** * 初始化方法 * 用于资源申请,所有测试方法在执行之前都会先执行该方法 */ @Before public void init()&#123; System.out.println(\"init...\"); &#125; /** * 测试add方法 */ @Test public void testAdd()&#123; System.out.println(\"testAdd...\"); //创建Calculator对象 Calculator calculator = new Calculator(); //调用add方法 int result = calculator.add(1, 2); //断言:判定结果 (期望值,实际结果) Assert.assertEquals(3, result); &#125; /** * 释放资源方法 * 在所有测试方法执行完后自动执行该方法 */ @After public void close()&#123; System.out.println(\"close...\"); &#125;&#125;/*init...testAdd...close...*/ 二. 反射 获取Class对象的三种方式: Class.forName(“全类名”): 将字节码文件加载进内存,返回Class对象 多用于配置文件,将类名定义在配置文件中.读取文件, 加载类 类名.class: 通过类名的属性class获取 多用于参数的传递 对象.getClass() 多用于对象的获取字节码的方式 同一个字节码文件(*.class)在一次程序运行过程中, 只会被加载一次,不论通过哪一种方式获取的Class对象都是同一个 1234567891011121314151617181920212223242526272829public class GetClassName &#123; public static void main(String[] args) throws Exception &#123; //通过class.forName(\"全类名\")获得class对象 Class cls1 = Class.forName(\"com.github.reflect.demo1.GetClassName\"); System.out.println(cls1); //通过类名.class获得class对象 Class cls2 = GetClassName.class; System.out.println(cls2); //通过对象.getClass()获得class对象 GetClassName getClassName = new GetClassName(); Class cls3 = getClassName.getClass(); System.out.println(cls3); //判断获得的三个class对象是否是同一个 System.out.println(cls1 == cls2); System.out.println(cls2 == cls3); &#125;&#125;/**class com.github.reflect.demo1.GetClassNameclass com.github.reflect.demo1.GetClassNameclass com.github.reflect.demo1.GetClassNametruetrue*/ Class对象功能: 获取功能: 获取成员变量们 Field[] getFields() Field getField(String name); Field[] getDeclaredFields(); Field getDeclaredField(String name); 获取构造方法们 Constructor&lt;?&gt;[] getConstructors(); Constructor getConstructor(类&lt;?&gt;… parameterTypes) Constructor getDeclared(类&lt;?&gt;… parameterTypes) Constructor&lt;?&gt;[] getDeclaredConstructors() 获取成员方法们 Method[] getMethods() Method getMethods(String name, 类&lt;?&gt;… parameterTypes) Method[] getDeclaredMethods() Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes) 获取类名 String getName() 123456789101112131415161718192021222324252627282930313233343536373839404142public class Person &#123; public String name; protected String year; String num; private String sex; public Person() &#123; &#125; public Person(String name, String age) &#123; this.name = name; this.year = age; &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", year='\" + year + '\\'' + \", num='\" + num + '\\'' + \", sex='\" + sex + '\\'' + '&#125;'; &#125; public void eat(String food)&#123; System.out.println(\"Person...eat...\" + food); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getYear() &#123; return year; &#125; public void setYear(String year) &#123; this.year = year; &#125; public String getNum() &#123; return num; &#125; public void setNum(String num) &#123; this.num = num; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142 //获取Person的Class对象 Class personClass = Person.class; //获得所有public修饰的成员变量 Field[] fields = personClass.getFields(); for(Field field : fields)&#123; System.out.println(field); //public java.lang.String com.github.reflect.demo1.Person.name &#125; //获得指定名称的public修饰的成员变量 Field field = personClass.getField(\"name\"); System.out.println(field); //public java.lang.String com.github.reflect.demo1.Person.name//定义一个对象 Person person = new Person(); //获取成员变量name的值 Object n1 = field.get(person); //field为指定名称的name成员变量 System.out.println(n1); //null //设置成员变量name的值 field.set(person, \"张三\"); Object n2 = field.get(person); System.out.println(n2); //张三 //获取所有的成员变量,不考虑修饰符 Field[] declaredFields = personClass.getDeclaredFields(); for(Field declaredField: declaredFields)&#123; System.out.println(declaredField); /** * public java.lang.String com.github.reflect.demo1.Person.name * protected java.lang.String com.github.reflect.demo1.Person.year * java.lang.String com.github.reflect.demo1.Person.num * private java.lang.String com.github.reflect.demo1.Person.sex */ &#125; //获得指定名称的成员变量 Field declaredField = personClass.getDeclaredField(\"sex\"); //忽略访问权限修饰符的安全检查 declaredField.setAccessible(true); //暴力反射 //获取私有成员变量sex的值 Object sex = declaredField.get(person); System.out.println(sex); //null 123456789101112131415//获得所有的构造方法Constructor[] constructors = personClass.getConstructors();for(Constructor constructor : constructors) &#123; System.out.println(constructor); /** * public com.github.reflect.demo1.Person(java.lang.String,java.lang.String) * public com.github.reflect.demo1.Person() */&#125;//获得指定的构造方法Constructor constructor = personClass.getConstructor(String.class, String.class);//创建对象Object o = constructor.newInstance(\"张三\", \"2017\");System.out.println(o); //Person&#123;name='张三', year='2017', num='null', sex='null'&#125; 123456789101112131415//获得指定名称的方法Method method = personClass.getMethod(\"eat\", String.class);method.invoke(person, \"rice\"); //Person...eat...rice//获得所有pubic修饰的方法(包含object方法)Method[] methods = personClass.getMethods();for(Method method1 : methods)&#123; System.out.println(method1); String name = method.getName(); System.out.println(name); //打印方法名&#125;//获取类名String className = personClass.getName();System.out.println(className); 案例: 需求: 写一个框架, 在不改变该类的任何代码的前提下,可以帮我们创建任意类的对象,并且执行其中任意的方法 实现: 配置文件 反射 步骤: 将需要创建对象的全类名和需要执行的方法定义在配置文件中 在程序中加载读取配置文件 使用反射技术来加载类文件进内存 创建对象 执行方法 创建一个Person类和一个Student类 123456789101112131415package com.github.reflect.useReflect;public class Person &#123; public void show()&#123; System.out.println(\"Person...show...\"); &#125;&#125;``` ```javapublic class Student &#123; public void show()&#123; System.out.println(\"Student...show...\"); &#125;&#125; 创建框架类 1234567891011121314151617181920212223242526272829303132public class ReflectTest &#123; //可以创建任意类的对象,执行任意方法 public static void main(String[] args) throws Exception &#123; /* 1.加载配置文件 */ //创建properties对象 Properties pro = new Properties(); //获取class目录下的配置文件 ClassLoader classLoader = ReflectTest.class.getClassLoader(); InputStream is = classLoader.getResourceAsStream(\"pro.properties\"); pro.load(is); /* 2.获取配置文件中定义的数据 */ String className = pro.getProperty(\"className\"); String methodName = pro.getProperty(\"methodName\"); /* 3.加载该类进内存 */ Class cls = Class.forName(className); /* 4.创建对象 */ //获取构造器 Constructor constructor = cls.getConstructor(); //根据构造器, 实例化对象 Object person = constructor.newInstance(); /* 5.获取方法对象 */ Method method = cls.getMethod(methodName); /* 6.执行方法*/ method.invoke(person); &#125;&#125; 在src文件夹下创建一个pro.properties配置文件, 在其中写入全类名(包名.类名)和方法名: 12className=com.github.reflect.useReflect.Person;methodName=show 执行结果: Person…show… 更改配置文件:12className=com.github.reflect.useReflect.Student;methodName=show 结果: Student…show… 三. 注解 分类: 编写文档 代码分析 编译检查 1234567891011121314151617181920/** * 注解javadoc演示 * * @author gydjsz * @version 1.0 * @since 1.8 */public class DocumentAnnotation &#123; /** * 计算两数的和 * @param a 整数 * @param b 整数 * @return 两数的和 */ public int add(int a, int b)&#123; return a + b; &#125;&#125; 打开命令行窗口, 输入javadoc DocumentAnnotation.java, 生成一系列文件打开index.html文件,即可查看书写的文档 jdk中预定义的一些注解: @override: 检测被该注解标注的方法是否是继承自父类(接口)的 @Deprecated: 该注解标注的内容, 表示已过时 @SuppressWarnings: 压制警告(一般传递参数all) 123456789101112131415161718192021222324252627public class PredefinedAnnotation &#123; //检测被该注解标注的方法是否是继承自父类(接口)的 @Override public String toString() &#123; return super.toString(); &#125; //该注解标注的内容, 表示已过时 @Deprecated public void show1()&#123; //有缺陷 &#125; public void show2()&#123; //替代show1方法 &#125; public void demo()&#123; show1(); show2(); &#125; //压制警告 @SuppressWarnings(\"all\") public void neverUsedWarnings()&#123;&#125;&#125; 自定注解 格式: public @interface MyAnno{属性列表; } 本质: 注解本质上是一个接口,该接口默认继承Annotation接口 public interface MyAnno extends java.lang.annotation.Annotation{} 属性: 接口中可以定义的成员方法 属性的返回值类型: 基本数据类型 String 枚举 注解 以上类型的数组 定义了属性,在使用时需要给属性赋值 如果在定义属性时,使用了关键字default给属性默认初始化值,则可以不进行属性的赋值 如果只有一个属性需要赋值,并且该属性的名称是value,则value可以省略,直接定义值 1234567891011121314151617181920public @interface CustomizeAnnotation &#123; String name(); int age(); Person getPerson(); //枚举类型 anno getAnno(); //注解类型 String[] strs();&#125;enum Person&#123; p1, p2;&#125;@interface anno&#123; int value();&#125;//使用注解@CustomizeAnnotation(age = 10, getPerson = Person.p1, getAnno = @anno(1), strs = &#123;\"abc\", \"def\"&#125;) //@anno(value = 1), 注解中只有一个属性且为value, value可以省略class Test&#123;&#125; 元注解: 描述注解的注解 @Target: 描述注解能够作用的位置 TYPE: 可以作用于类上 METHOD: 可以作用于方法上 FIELD: 可以作用于成员变量上 @Retention: 描述注解被保留的阶段 @Retention(RetentionPolicy.SOURCE):当前被描述的注解,不会保留到class字节码文件中 @Retention(RetentionPolicy.CLASS):当前被描述的注解,会保留到class字节码文件中 @Retention(RetentionPolicy.RUNTIME):当前被描述的注解,会保留到class字节码文件中,并被JVM读取到 (一般用这个) @Documented: 描述注解是否被抽取到api文档中 @Inherited: 描述该注解是否被子类继承 12345678910111213141516@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.FIELD&#125;) //可以作用于类,方法,成员变量上@Retention(RetentionPolicy.RUNTIME) //该注解在程序运行时一直有效@Documented //使用该注解,则通过javadoc生成的api文档中含有@MyAnnotation注解public @interface MyAnnotation &#123; int age();&#125;@MyAnnotation(age = 18)public class MyAnnotataionTest &#123; @MyAnnotation(age = 1) public int age; @MyAnnotation(age = 10) public void show()&#123;&#125;&#125; 在程序中使用解析注解:获取注解中定义的属性值 获取注解中定义的位置的对象(Class, Method, Field) 获取指定的注解:getAnnotation(Annotation.Class) 调用注解中的抽象方法来获取注解中的属性值 案例: 利用注解实现一个框架类 123456Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123; String className(); String methodName();&#125; 123456789101112131415161718192021222324252627282930313233/** * 利用注解实现一个框架类 */@MyAnnotation(className = \"com.github.Annotation.demo.Person\", methodName = \"show\")public class ReflectTest &#123; public static void main(String[] args) throws Exception &#123; //获取该类的字节码文件对象 Class&lt;ReflectTest&gt; reflectTestClass = ReflectTest.class; //获取注解对象 //其实就是在内存中生成了一个该注解接口的子类实现对象 MyAnnotation myAnnotation = reflectTestClass.getAnnotation(MyAnnotation.class); /** public class MyAnnotationImp implements MyAnnotation&#123; public String className()&#123; return \"com.github.Annotation.demo.Person\"; &#125; public String methodName()&#123; return \"show\"; &#125; &#125; */ //调用注解对象中定义的抽象方法,获取返回值 String className = myAnnotation.className(); String methodName = myAnnotation.methodName(); Class cls = Class.forName(className); Object o = cls.newInstance(); Method method = cls.getMethod(methodName); method.invoke(o); &#125;&#125; 案例: 通过注解实现对程序的检测,输出异常 123456/** *定义注解 */@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Check &#123;&#125; 123456789101112131415161718192021222324252627/** * 计算器类 */public class Calculator &#123; @Check public void add()&#123; String s = null; s.toString(); System.out.println(\"1 + 0 = \" + (1 + 0)); &#125; @Check public void sub()&#123; System.out.println(\"1 - 0 = \" + (1 - 0)); &#125; @Check public void mul()&#123; System.out.println(\"1 * 0 = \" + (1 * 0)); &#125; @Check public void div()&#123; System.out.println(\"1 / 0 = \" + (1 / 0)); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 简单测试框架 * 当主方法执行后, 会自动检测加了check注解的方法,判断方法是否有异常 */public class TestCheck &#123; public static void main(String[] args) throws IOException &#123; //1. 创建计算器对象 Calculator calculator = new Calculator(); //2. 获取字节码文件对象 Class cls = calculator.getClass(); //3. 获取所有方法 Method[] methods = cls.getMethods(); int number = 0; //出现错误的次数 BufferedWriter bw = new BufferedWriter(new FileWriter(\"bug.txt\")); //4. 判断方法上是否有check注解 for (Method method : methods) &#123; if(method.isAnnotationPresent(Check.class))&#123; //5. 有check注解,执行方法 try &#123; method.invoke(calculator); &#125; catch (Exception e) &#123; //6. 捕获异常 //记录到文件中 number++; bw.write(method.getName() + \"方法出现异常\"); bw.newLine(); //换行 bw.write(\"异常的名称:\" + e.getCause().getClass().getSimpleName()); bw.newLine(); bw.write(\"异常的原因:\" + e.getCause().getMessage()); bw.newLine(); bw.write(\"------------------\"); bw.newLine(); &#125; &#125; &#125; bw.write(\"本次测试一共出现\" + number + \"次异常\"); bw.flush(); //刷新 bw.close(); &#125;&#125; 测试结果:123456789div方法出现异常异常的名称:ArithmeticException异常的原因:/ by zero------------------add方法出现异常异常的名称:NullPointerException异常的原因:null------------------本次测试一共出现2次异常","categories":[],"tags":[]},{"title":"数学知识集锦","slug":"algorithm/math","date":"2019-06-02T07:20:06.162Z","updated":"2019-06-02T07:20:06.162Z","comments":true,"path":"2019/06/02/algorithm/math/","link":"","permalink":"https://gydjsz.github.io/2019/06/02/algorithm/math/","excerpt":"","text":"用一个平面截球而得到球的一部分叫做球缺, 球缺是实体，它的体积公式为：V = π h² (3 * r - h) / 3;r表示球的半径，h表示球缺的高。 球冠是球面的一部分，是用平面去截球面而得到的一部分, 这个平面截球面所得的圆叫做球冠的底，垂直于截面的球的直径被这截面截得的线段的长叫做球冠的高。球冠的面积公式是S = 2 π r * h。 欧拉函数: ϕ(n) 1~n中与n互质的数的个数 令n = p1^r1 p2^r2…pk^rk则ϕ(n)=n(1-1/p1)(1-1/p2)…*(1-1/pk)其中p1, p2……pn为n的所有质因数，n是不为0的整数。 欧拉函数是积性函数: 若m,n互质，ϕ(mn) = ϕ(m) * ϕ(n) 当n为奇质数时，ϕ(2n) = ϕ(n) 若n为质数, 则 ϕ(n) = n - 1","categories":[],"tags":[]},{"title":"乘法逆元","slug":"algorithm/4.乘法逆元","date":"2019-06-02T07:20:06.162Z","updated":"2019-06-02T07:20:06.162Z","comments":true,"path":"2019/06/02/algorithm/4.乘法逆元/","link":"","permalink":"https://gydjsz.github.io/2019/06/02/algorithm/4.乘法逆元/","excerpt":"12345678910111213/* a * x = 1 (mod p) x称为ａ关于１模p的乘法逆元,求x * * 方法一：扩展欧拉定理 * a * x = 1 (mod p) =&gt; a * x + p * y = 1 * 利用扩展欧几里得法求得ｘ和ｙ，其中x为a关于１模ｐ乘法逆元 * * 方法二：费马小定理 * 费马小定理：假如p是质数，且gcd(a,p)=1，那么 a^(p-1)≡ 1（mod p） (p是质数) * a ^ (p - 1) = 1 (mod p) * =&gt; a * a ^ (p - 2) = 1 (mod p) * 令x = a^-1, x = a ^ (p - 2)(mod p) * 利用快速幂求得x */","text":"12345678910111213/* a * x = 1 (mod p) x称为ａ关于１模p的乘法逆元,求x * * 方法一：扩展欧拉定理 * a * x = 1 (mod p) =&gt; a * x + p * y = 1 * 利用扩展欧几里得法求得ｘ和ｙ，其中x为a关于１模ｐ乘法逆元 * * 方法二：费马小定理 * 费马小定理：假如p是质数，且gcd(a,p)=1，那么 a^(p-1)≡ 1（mod p） (p是质数) * a ^ (p - 1) = 1 (mod p) * =&gt; a * a ^ (p - 2) = 1 (mod p) * 令x = a^-1, x = a ^ (p - 2)(mod p) * 利用快速幂求得x */ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std;typedef long long ll;const ll MOD = 1000000007;//扩展欧几里得ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y)&#123; if(b == 0)&#123; x = 1; y = 0; return a; &#125; ll gcd = exgcd(b, a % b, y, x); y -= a / b * x; return gcd;&#125; ll inv(ll a, ll b)&#123; ll d, x, y; d = exgcd(a, b, x, y); return d == 1 ? (x + b) % b : -1; //1.负数情况转为正, 2.必须满足互质，否则无逆元&#125;ll powMod(ll a, ll b)&#123; ll res = 1; while(b)&#123; if(b &amp; 1) res = res * a % MOD; a = a * a % MOD; b &gt;&gt;= 1; &#125; return res;&#125;int main()&#123; ll a; cin &gt;&gt; a; ll result = powMod(a, MOD - 2); cout &lt;&lt; result &lt;&lt; endl; result = inv(a, MOD); cout &lt;&lt; result &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[]},{"title":"扩展欧几里得","slug":"algorithm/3.扩展欧几里得算法","date":"2019-06-02T07:20:06.162Z","updated":"2019-06-02T07:20:06.162Z","comments":true,"path":"2019/06/02/algorithm/3.扩展欧几里得算法/","link":"","permalink":"https://gydjsz.github.io/2019/06/02/algorithm/3.扩展欧几里得算法/","excerpt":"12345678910当b = 0时，gcd(a, b) = a, 此时x = 1, y = 0当a &gt; b时，设a * x1 + b * y1 = gcd(a, b); b * x2 + (a % b) * y2 = gcd(b, a % b);gcd(a, b) = gcd(b, a % b);所以a * x1 + b * y1 = b * x2 + (a % b) * y2;=&gt; a * x1 + b * y1 = b * x2 + (a - [a / b] * b) * y2; []表示取整=&gt; a * x1 + b * y1 = a * y2 + b * (x2 - [a / b] * y2);=&gt; x1 = y2, y1 = x2 - [a / b] * y2此时得出x1和y1的值基于x2和y2,因而可以将每次a * x2 + b * y2 = gcd(b, a % b)的x2、y2的值代入求得x1和y1, 多次递归后b = 0，x = 1, y = 0, 最终求得x和y的值，即a * x + b * y = gcd(a, b) 的方程组的解","text":"12345678910当b = 0时，gcd(a, b) = a, 此时x = 1, y = 0当a &gt; b时，设a * x1 + b * y1 = gcd(a, b); b * x2 + (a % b) * y2 = gcd(b, a % b);gcd(a, b) = gcd(b, a % b);所以a * x1 + b * y1 = b * x2 + (a % b) * y2;=&gt; a * x1 + b * y1 = b * x2 + (a - [a / b] * b) * y2; []表示取整=&gt; a * x1 + b * y1 = a * y2 + b * (x2 - [a / b] * y2);=&gt; x1 = y2, y1 = x2 - [a / b] * y2此时得出x1和y1的值基于x2和y2,因而可以将每次a * x2 + b * y2 = gcd(b, a % b)的x2、y2的值代入求得x1和y1, 多次递归后b = 0，x = 1, y = 0, 最终求得x和y的值，即a * x + b * y = gcd(a, b) 的方程组的解 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int exgcd(int a, int b, int &amp;x, int &amp;y)&#123; if(b == 0)&#123; //当ｂ的值为０时的x = 1, y = 0 x = 1; y = 0; return a; &#125; int gcd = exgcd(b, a % b, y, x); //求得最小公约数的值 //将每一次gcd得到的x2 和 y2用公式x1 = y2, y1 = x2 - a / b * y2求得x1和y1 y -= a / b * x; return gcd;&#125;int main()&#123; int a, b, x, y; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; exgcd(a, b, x, y) &lt;&lt; endl; //最大公约数 cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl; //求得的一种解 return 0;&#125;","categories":[],"tags":[]},{"title":"最大公约数","slug":"algorithm/2.最大公约数","date":"2019-06-02T07:20:06.162Z","updated":"2019-06-02T07:20:06.162Z","comments":true,"path":"2019/06/02/algorithm/2.最大公约数/","link":"","permalink":"https://gydjsz.github.io/2019/06/02/algorithm/2.最大公约数/","excerpt":"1234567//辗转相除法 a = 6 b = 4 a - b * k = n a % b = n 6 - 4 * 1 = 2 gcd(b, a % b) =&gt; a = 4(b) b = 2(a % b) 4 - 2 * 1 = 2 =&gt; a = 2 b = 2 2 - 2 * 1 = 0 =&gt; a = 2 b = 0 当ｂ＝０时,得到最大公约数2","text":"1234567//辗转相除法 a = 6 b = 4 a - b * k = n a % b = n 6 - 4 * 1 = 2 gcd(b, a % b) =&gt; a = 4(b) b = 2(a % b) 4 - 2 * 1 = 2 =&gt; a = 2 b = 2 2 - 2 * 1 = 0 =&gt; a = 2 b = 0 当ｂ＝０时,得到最大公约数2 1234567891011121314151617#include &lt;iostream&gt;using namespace std;typedef long long ll;ll gcd(ll a, ll b)&#123; return b == 0 ? a : gcd(b, a % b);&#125;int main()&#123; ll a, b; cin &gt;&gt; a &gt;&gt; b; ll result = gcd(a, b); cout &lt;&lt; result &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[]},{"title":"并查集","slug":"algorithm/7.并查集","date":"2019-06-02T07:20:06.162Z","updated":"2019-06-02T07:20:06.162Z","comments":true,"path":"2019/06/02/algorithm/7.并查集/","link":"","permalink":"https://gydjsz.github.io/2019/06/02/algorithm/7.并查集/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int SIZE = 100;int father[SIZE], height[SIZE]; //father记录每个元素的上级，height记录等级void init(int n)&#123; for(int i = 0; i &lt; n; i++)&#123; father[i] = i; //初始时，每个元素的上司是自己 height[i] = 1; //初始等级为1 &#125;&#125;int find(int v)&#123; return father[v] = father[v] == v ? v : find(father[v]); //找到元素的最高一级指挥官&#125;void join(int x, int y)&#123; x = find(x); y = find(y); if(height[x] &lt; height[y]) //把等级低的放等级高的下面 father[x] =father[y]; else&#123; father[y] = x; // 如果后者等级高，那么将等级低的归自己管 if(height[x] == height[y]) //如果两者等级相等，那么当把同等级的归自己管，而自己等级需+1 height[x]++; &#125;&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; int x, y; init(n); //初始化等级 for(int i = 1; i &lt;= m; i++)&#123; cin &gt;&gt; x &gt;&gt; y; //输入有关联的两个人 join(x, y); //加入到集合中来 &#125; for(int i = 1; i &lt;= n; i++) cout &lt;&lt; i &lt;&lt; \" \"; cout &lt;&lt; endl; for(int i = 1; i &lt;= n; i++) cout &lt;&lt; find(i) &lt;&lt; \" \"; return 0;&#125;","categories":[],"tags":[]},{"title":"矩阵快速幂","slug":"algorithm/6.矩阵快速幂","date":"2019-06-02T07:20:06.162Z","updated":"2019-06-02T07:20:06.162Z","comments":true,"path":"2019/06/02/algorithm/6.矩阵快速幂/","link":"","permalink":"https://gydjsz.github.io/2019/06/02/algorithm/6.矩阵快速幂/","excerpt":"12345678910111213141516171819 利用矩阵快速幂求斐波那切数列 F[i] = 1 * F[i - 1] + 1 * F[i - 2] F[i - 1] = 1 * F[i - 1] + 0 * F[i - 2]; - - - - - -| F[i] | =| 1 1 | * | F[n - 1] | |F[i - 1] | | 1 0 | | F[n - 2] | - - - - - - - - - - ^(n - 1) - -| F[i] | =| 1 1 | | F[1] | |F[i - 1] | | 1 0 | * | F[0] | - - - - - - - - A = | 1 1 | | 1 0 | - - 也就是使用矩阵快速幂求出A的n - 1次方，F[1] = 1, F[0] = 0,求得的矩阵为A&apos;(2 * 1)，数列第ｎ个的值为A&apos;[0][0]","text":"12345678910111213141516171819 利用矩阵快速幂求斐波那切数列 F[i] = 1 * F[i - 1] + 1 * F[i - 2] F[i - 1] = 1 * F[i - 1] + 0 * F[i - 2]; - - - - - -| F[i] | =| 1 1 | * | F[n - 1] | |F[i - 1] | | 1 0 | | F[n - 2] | - - - - - - - - - - ^(n - 1) - -| F[i] | =| 1 1 | | F[1] | |F[i - 1] | | 1 0 | * | F[0] | - - - - - - - - A = | 1 1 | | 1 0 | - - 也就是使用矩阵快速幂求出A的n - 1次方，F[1] = 1, F[0] = 0,求得的矩阵为A&apos;(2 * 1)，数列第ｎ个的值为A&apos;[0][0] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef vector&lt;int&gt; vec;typedef vector&lt;vec&gt; mat;typedef long long ll;const int M = 100;//矩阵相乘mat mul(mat &amp;A, mat &amp;B)&#123; //Ｃ默认值为0 mat C(A.size(), vec(B[0].size())); //A.size()是矩阵的行，B[0].size()是矩阵的列, n * m 矩阵 和 m * k矩阵相乘之后，新矩阵为n * k for(int i = 0; i &lt; A.size(); i++) for(int j = 0; j &lt; B.size(); j++) //B.size()是矩阵的行，也就是A[0].size() for(int k = 0; k &lt; B[0].size(); k++) C[i][j] += A[i][k] * B[k][j]; //新矩阵当前值=矩阵A的当前行 * 矩阵B的当前列的和 return C;&#125;//快速幂mat pow(mat A, ll n)&#123; mat B(A.size(), vec(A.size())); for(int i = 0; i &lt; A.size(); i++) B[i][i] = 1; while(n &gt; 0)&#123; if(n &amp; 1) B = mul(B, A); A = mul(A, A); n &gt;&gt;= 1; &#125; return B;&#125;//求斐波那切数列int Fibonacci(int n)&#123; mat A(2, vec(2)); A[0][0] = 1; A[0][1] = 1; A[1][0] = 1; A[1][1] = 0; A = pow(A, n - 1); cout &lt;&lt; A[0][0] &lt;&lt; endl;&#125;int main()&#123; /* //求矩阵Ａ× Ｂ int ax, ay, bx, by; cin &gt;&gt; ax &gt;&gt; ay &gt;&gt; bx &gt;&gt; by; //A(M, vec(M))是vector的组合，就是一个vector中的数据是vector&lt;int&gt;,每个vector&lt;int&gt;存储整数值，可以理解为一个二维数组 //vec中存储vec1,vec2,vec3,vec4, 而vec1中存储1, 2, 3, 4 //vec: vec1 vec2 vec3 vec4 // 1 1 1 1 // 2 2 2 2 // 3 3 3 3 // 4 4 4 4 mat A(M, vec(M)), B(M, vec(M)); for(int i = 0; i &lt; ax; i++) for(int j = 0; j &lt; ay; j++) cin &gt;&gt; A[i][j]; for(int i = 0; i &lt; bx; i++) for(int j = 0; j &lt; by; j++) cin &gt;&gt; B[i][j]; mat C = mul(A, B); for(int i = 0; i &lt; ax; i++)&#123; for(int j = 0; j &lt; by; j++) cout &lt;&lt; C[i][j] &lt;&lt; \" \"; cout &lt;&lt; endl; &#125; */ /* // 求矩阵Ａ的ｍ次方 int n, m; cin &gt;&gt; n &gt;&gt; m; //ｎ为矩阵的阶，ｍ为幂次 mat A(M, vec(M)); for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) cin &gt;&gt; A[i][j]; mat B = pow(A, m); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n; j++) cout &lt;&lt; B[i][j] &lt;&lt; \" \"; cout &lt;&lt; endl; &#125; */ //求斐波那切数列 int n; cin &gt;&gt; n; Fibonacci(n); return 0;&#125;","categories":[],"tags":[]},{"title":"埃氏筛法","slug":"algorithm/8.埃氏筛法","date":"2019-06-02T07:20:06.162Z","updated":"2019-06-02T07:20:06.162Z","comments":true,"path":"2019/06/02/algorithm/8.埃氏筛法/","link":"","permalink":"https://gydjsz.github.io/2019/06/02/algorithm/8.埃氏筛法/","excerpt":"埃氏筛法：首先用一张表把1～n的所有数表示出来，其中2是最小的素数，将表中所有2的倍数划去，表中剩余的最小数字为3，它不能被更小的数整除，因而它是素数，将3的倍数从表中划去，依次类推，就能枚举n以内的素数, 时间复杂度O(nlognlogn)","text":"埃氏筛法：首先用一张表把1～n的所有数表示出来，其中2是最小的素数，将表中所有2的倍数划去，表中剩余的最小数字为3，它不能被更小的数整除，因而它是素数，将3的倍数从表中划去，依次类推，就能枚举n以内的素数, 时间复杂度O(nlognlogn) 123456789101112131415161718192021222324252627282930313233#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXSIZE = 100000;int prime[MAXSIZE]; //存储n以内的素数bool is_prime[MAXSIZE]; //第i个数是否为素数int getPrime(int n)&#123; int p = 0; memset(is_prime, true, sizeof(is_prime)); is_prime[0] = is_prime[1] = false; for(int i = 0; i &lt; n; i++)&#123; if(is_prime[i])&#123; prime[p++] = i; for(int j = 2 * i; j &lt;= n; j += i) is_prime[j] = false; &#125; &#125; return p;&#125;int main()&#123; int n; cin &gt;&gt; n; int m = getPrime(n); for(int i = 0; i &lt; m; i++) cout &lt;&lt; prime[i] &lt;&lt; \" \"; return 0;&#125;","categories":[],"tags":[]},{"title":"快速幂","slug":"algorithm/5.快速幂","date":"2019-06-02T07:20:06.162Z","updated":"2019-06-02T07:20:06.162Z","comments":true,"path":"2019/06/02/algorithm/5.快速幂/","link":"","permalink":"https://gydjsz.github.io/2019/06/02/algorithm/5.快速幂/","excerpt":"1234x ^ n = ((x^2)^2)...x ^ n = x^(2^k1) * x^(2^k2)...x^22 = x^2 * x^4 * x^16x^21 = x * x^4 * 2^16 //21的二进制为10101，在１处进行res *= x;","text":"1234x ^ n = ((x^2)^2)...x ^ n = x^(2^k1) * x^(2^k2)...x^22 = x^2 * x^4 * x^16x^21 = x * x^4 * 2^16 //21的二进制为10101，在１处进行res *= x; 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;typedef long long ll;const ll MOD = 10000000007;//非递归ll fast_pow1(ll x, ll n)&#123; ll res = 1; while(n &gt; 0)&#123; if(n &amp; 1) //n为奇数，如3,二进制为11, 末尾为１，11 &amp; 1 =&gt; 11 &amp; 01 =&gt; 1(true)，res = 1 * x,进行了n &gt;&gt;= 1操作后，最终n变为1, 1 &amp; 1 =&gt; 1, res = 2 * 4 = 8; n为偶数,if操作只有当n = 1时才执行 res = res * x % MOD; //根据题意是否添加% MOD x = x * x % MOD; //根据题意是否添加% MOD n &gt;&gt;= 1; //右移操作，相当于除２ &#125; return res;&#125;//递归ll fast_pow2(ll x, ll n)&#123; if(n == 0) return 1; ll res = fast_pow2(x * x, n / 2); if(n &amp; 1) res = res * x; return res;&#125;int main()&#123; int x, n; cin &gt;&gt; x &gt;&gt; n; cout &lt;&lt; fast_pow1(x, n) &lt;&lt; endl; cout &lt;&lt; fast_pow2(x, n) &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[]},{"title":"小技巧","slug":"StlLearn/fuction","date":"2019-06-02T07:20:06.158Z","updated":"2019-06-02T07:20:06.158Z","comments":true,"path":"2019/06/02/StlLearn/fuction/","link":"","permalink":"https://gydjsz.github.io/2019/06/02/StlLearn/fuction/","excerpt":"//去掉对c输入输出的兼容，加快c++速度std::ios::sync_with_stdio(false);cin.tie(NULL);","text":"//去掉对c输入输出的兼容，加快c++速度std::ios::sync_with_stdio(false);cin.tie(NULL); next_permutation(): 按照字典顺序产生区间内元素下一个较大的排列组合prev_permutation(): 按照字典顺序产生区间内元素下一个较小的排列组合 12345678910111213#include &lt;algorithm&gt;int perm[] = &#123;3, 1, 2&#125;; //初始化该数组int permutation(int n)&#123; do&#123; for(int i = 0; i &lt; 3; i++) //输出一个排列 cout &lt;&lt; perm[i] &lt;&lt; \" \"; cout &lt;&lt; endl; &#125;while(next_permutation(perm, perm + 3)); //按照字典序生成排列，若生成完毕，返回false /*输出 3 1 2 3 2 1 */ return 0;&#125; nth_element(a + l, a + k, a + r): 使得ａ这个数组中区间(l, r)内的第ｋ大元素处在第ｋ个位置上, 默认排在k前面的元素都不比它大，排在它后面的元素都不比它小,而左右两边是无序的 123456789#include &lt;algorithm&gt;int kth()&#123; int a[] = &#123;0, 6, 3, 7, 5, 1&#125;; nth_element(a + 1, a + 2, a + 6); for(int i = 1; i &lt; 6; i++) cout &lt;&lt; a[i] &lt;&lt; \" \"; //第2大是３，输出1 3 7 5 6 return 0;&#125; to_string(): 将数字转化为字符串1string s = to_string(123); // s = \"123\" 使用stringstream字符串流来实现转换1234567891011121314151617#include &lt;sstream&gt; //头文件sstream//int 转 stringint n = 123;stringstream ss;ss &lt;&lt; n;string s;ss &gt;&gt; s;cout &lt;&lt; s &lt;&lt; endl; //s = \"123\"ss.clear(); //同一个stream多次转换应该调用clear()方法//string 转 ints = \"2233\";ss &lt;&lt; s;ss &gt;&gt; n;cout &lt;&lt; n &lt;&lt; endl; //n = 2233 bitset bit(num); // 将num转化为n位二进制 1234#include &lt;bitset&gt;bitset&lt;2&gt; b(3);cout &lt;&lt; b &lt;&lt; endl; // 输出11 输入一个数字num, 求num的位数#include len = int(log10(num)) + 1 考虑一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。 n个元素的错排数记为D(n) 错排公式:D(n) = (n-1) [D(n-2) + D(n-1)] 特殊地，D(1) = 0, D(2) = 1. 快读板子 123456789101112131415161718namespace io &#123; const int SIZE = 1e7 + 10; char inbuff[SIZE]; char *l, *r; inline void init() &#123; l = inbuff; r = inbuff + fread(inbuff, 1, SIZE, stdin); &#125; inline char gc() &#123; if (l == r) init(); return (l != r) ? *(l++) : EOF; &#125; void read(int &amp;x) &#123; x = 0; char ch = gc(); while(!isdigit(ch)) ch = gc(); while(isdigit(ch)) x = x * 10 + ch - &apos;0&apos;, ch = gc(); &#125;&#125; using io::read; 在主程序中 read(x); 即可。","categories":[],"tags":[]},{"title":"枚举n个数的排列","slug":"algorithm/1.枚举n个数的排列","date":"2019-06-02T07:20:06.158Z","updated":"2019-06-02T07:20:06.158Z","comments":true,"path":"2019/06/02/algorithm/1.枚举n个数的排列/","link":"","permalink":"https://gydjsz.github.io/2019/06/02/algorithm/1.枚举n个数的排列/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;int swap(int &amp;a, int &amp;b)&#123; //交换数组中两个元素位置 int t = a; a = b; b = t; return 0;&#125;int permutation(int k, int n, int perm[])&#123; if(k == n - 1)&#123; for(int i = 0; i &lt; n; i++) //输出一个排列 cout &lt;&lt; perm[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return 0; &#125; for(int i = k; i &lt; n; i++)&#123; if(i != k &amp;&amp; perm[i] == perm[k]) continue; //除本身外，如果交换的两个数相同，则跳过 swap(perm[i], perm[k]); permutation(k + 1, n, perm); //递归进行排列 swap(perm[i], perm[k]); //恢复原来的位置 &#125; return 0;&#125;int main()&#123; int n; cin &gt;&gt; n; int a[n]; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; permutation(0, n, a); return 0;&#125;","categories":[],"tags":[]},{"title":"Linux下的技巧操作","slug":"Linux/linuxTip","date":"2019-06-02T07:20:06.118Z","updated":"2019-06-02T07:20:06.118Z","comments":true,"path":"2019/06/02/Linux/linuxTip/","link":"","permalink":"https://gydjsz.github.io/2019/06/02/Linux/linuxTip/","excerpt":"一、好用的工具 autojump: 可以记录进入过的目录, 支持直接跳转到想到的目录j path: 进入path目录j: 进入权值最高的目录j -i[权重]: 增加权值j -d[权重]: 减少权值jo path: 打开目录j -s: 显示自动跳转数据库中的条目","text":"一、好用的工具 autojump: 可以记录进入过的目录, 支持直接跳转到想到的目录j path: 进入path目录j: 进入权值最高的目录j -i[权重]: 增加权值j -d[权重]: 减少权值jo path: 打开目录j -s: 显示自动跳转数据库中的条目 xsel: 建立终端和剪切板之间的通道cat txt | xsel -b -i: 将txt文件中的内容复制到xsel中xsel &gt; txt: 将xsel中的内容复制到txt中xsel -o -i: 查看xsel中的内容 二、一些操作 python版本切换sudo update-alternatives –config python 使用清华源，提升pip下载速度Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹) 内容如下：1234[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=mirrors.aliyun.com 查看服务状态service –status-all 查看所有的服务状态service xx status 查看xx的服务状态","categories":[],"tags":[]},{"title":"vim快捷键","slug":"LearnVim/VimKeyCut","date":"2019-06-02T07:20:06.118Z","updated":"2019-06-02T07:20:06.118Z","comments":true,"path":"2019/06/02/LearnVim/VimKeyCut/","link":"","permalink":"https://gydjsz.github.io/2019/06/02/LearnVim/VimKeyCut/","excerpt":"[参考链接]https://www.cnblogs.com/jy02414216/archive/2012/10/29/2745001.html[参考链接]https://blog.csdn.net/scaleqiao/article/details/45153379","text":"[参考链接]https://www.cnblogs.com/jy02414216/archive/2012/10/29/2745001.html[参考链接]https://blog.csdn.net/scaleqiao/article/details/45153379 VIM光标跳转 h, j, k, l :左, 下, 上, 右gj :向下移动一行gk :向上移动一行gg :移动到文件首G :移动到文件末尾w :向前移动一个单词,光标停留在下一个单词开头W :向前移动一个单词,光标停留在下一个单词开头,但忽略标点e :向前移动一个单词,光标停留在单词末尾E :移动到单词末尾,如果有标点则移动到标点处( :前移一句) :后移一句{ :前移一段} :后移一段0 :移动到行首$ :移动到行尾n| :移动到第n列nG / ngg :移动到第n行H :光标移动到屏幕顶端M :光标移动到屏幕中间一行L :光标移动到屏幕最底端一行 VIM翻屏指令ctrl+f :下翻一屏ctrl+b :上翻一屏ctrl+d :下翻半屏ctrl+u :上翻半屏ctrl+e :向下滚动一行ctrl+y :向上滚动一行n% :到文件n%的位置zz :将当前行移动到屏幕中央zt :将当前行移动到屏幕顶端zb :将当前行移动到屏幕底端VIM分屏指令 :new (name)，新建一个未命名(文件名为name)的窗口件并分屏， 快捷键，Ctrl+W，然后马上按n键:split (name) / 缩写:sp name 水平分屏，将当前屏分为两个，水平的。 Ctrl + w, s:vsplit (name) / 缩写:vs name 垂直分屏，将当前屏分为两个，垂直的。 Ctrl + w, v:only 取消分屏，取消当前的屏，当前屏指的是光标所在屏。 关闭当前屏: Ctrl+w，c。 切换窗口:Ctrl + w, w 后一个Ctrl + w, p 前一个 Ctrl + w, h 四个方向Ctrl + w, iCtrl + w, kCtrl + w, l 关闭其他窗口:Ctrl + w, o 载入文件 :vs 文件路径/文件名 在新的垂直分屏中打开文件 :sv 文件路径/文件名 在新的水平分屏中打开文件 VIM字母转换 gu:字符转换小写gU:字符转换大写gul / gUl :将光标所在字符转换为小写/大写guh / gUh :将光标左边字符转换为小写/大写 VIM复制粘贴 x :剪切右边字符X :剪切左边字符yy / Y :复制整行文本:m,ny :复制m行到n行的文本v :开始选择文本V :选择当前行的文本dd :删除当前行D :删除光标后面的文本p :在光标之后粘贴P :在光标之前粘贴 VIM自带的补全 C-x C-v :补全vim选项和命令。C-x C-l :整行补全。C-x C-f :自动补全文件路径。弹出菜单后，按C-f循环选择，当然也可以按 C-n和C-p。C-x C-p 和 C-x C-n :用文档中出现过的单词补全当前的词。 直接按C-p和C-n也可以。C-x C-o :编程时可以补全关键字和函数名啊。C-x C-i :根据头文件内关键字补全。C-x C-d :补全宏定义。C-x C-n :按缓冲区中出现过的关键字补全。 直接按C-n或C-p即可。 VIM插入模式 i :在光标处插入I :在行首插入a :在光标后面插入A :在行尾插入o :在下一行插入O :在上一行插入Esc :进入一般模式 VIM保存文件:w :保存文件但不退出vi:w file :将修改另外保存到file中，不退出vi:w! :强制保存，不退出vi:wq :保存文件并退出vi:wq! :强制保存文件，并退出vi:q :不保存文件，退出vi:q! :不保存文件，强制退出vi:e! :放弃所有修改，从上次保存文件开始再编辑命令历史ZZ :保存文件 VIM格式化代码 格式化的核心是= + 位置gg=G :格式化整个文档=G :向下格式化所有行n== :向下格式化n行n= + 方向: 朝某个方向格式化n行== :格式化当前行={ :向上格式化代码块=} :向下格式化代码块mg=ng:格式化m行到n行 vim插入内容:r 文件名 :将文件的内容插入到光标处:r !命令 :将命令的结果插入到光标处:! 命令 :只显示命令的结果不写入 vim自定义快捷键:map 快捷键 操作方式 :快捷键使用Ctrl-v-某字母,使用Ctrl-某字母,可以调出命令:ab 快捷字 想要写入的文字 :当编辑文本出现快捷字之后,按下回车或者空格,快捷字就会变成相要写入的文字 想要保存快捷键的话,需要在家目录下新建一个.vimrc文件,然后在里面写入map 快捷键 操作方式,ab 快捷字 想要写入的文字,(这里不需要冒号),然后保存就可以了 vim宏录制qa进入宏录制，q退出，@a执行，n@a执行n次 宏录制是一个非常强大的功能，可以执行相同的操作n次。比如我有一个数字1，我按下qa，按下V选中1，按下y复制1，再按下p，1就被复制到下一行，然后按下Ctrl-a，将1变成2，最后按下q。我的宏就录制好了，首先输入1，然后在一般模式下输入100@a，就有从1到100个数字列出来了。","categories":[],"tags":[]},{"title":"链接收藏","slug":"GoodWebsiteCollection","date":"2019-06-02T07:20:06.094Z","updated":"2019-06-02T07:20:06.094Z","comments":true,"path":"2019/06/02/GoodWebsiteCollection/","link":"","permalink":"https://gydjsz.github.io/2019/06/02/GoodWebsiteCollection/","excerpt":"下载链接 putty下载:&ensp;https://pan.baidu.com/s/1X_IITIlSP5u_wnKPiOL-oA&ensp;&ensp;&ensp; 提取码：8of8","text":"下载链接 putty下载:&ensp;https://pan.baidu.com/s/1X_IITIlSP5u_wnKPiOL-oA&ensp;&ensp;&ensp; 提取码：8of8 xshell下载链接：https://pan.baidu.com/s/1qb_wYdU3S-9s3dpBzIMCoQ&ensp;&ensp;&ensp; 提取码：r2x7 xsel下载链接：链接：https://pan.baidu.com/s/1JY269KghMzMvCLgy1_XlwQ&ensp;&ensp;&ensp; 提取码：opml 编程练习 PTA:&ensp;https://pintia.cn/ 牛客网:&ensp;https://www.nowcoder.com/ nyoj:&ensp;http://acm.nyist.edu.cn/JudgeOnline/problemset.php LibreOj:&ensp;https://loj.ac/ TMaD OJ:&ensp;http://tmad.ctguqmx.com/ 编程网站(全):https://vjudge.net/ leetcode: https://leetcode-cn.com/ 洛谷：https://www.luogu.org/ 编程学习 速学堂:&ensp;http://www.sxt.cn/ 菜鸟教程:&ensp;http://www.runoob.com/ 黑马程序员:&ensp;http://yun.itheima.com/ 博客 简明现代魔法:&ensp;http://www.nowamagic.net/ CSDN:&ensp;https://www.csdn.net/ Exp技术分享博客:&ensp;http://exp-blog.com/ Linux Linux命令大全:&ensp;http://man.linuxde.net/ 鸟哥的Linux私房菜:&ensp;https://www.kancloud.cn/wizardforcel/vbird-linux-basic-4e/152191 工具网站 在线计算器:&ensp;http://www.ab126.com/ 图片和base64编码转换:&ensp;http://www.vgot.net/test/image2base64.php? 在线vim编辑器学习:&ensp;http://www.atool.org/vim.php 二维码在线解析:&ensp;http://cdn.malu.me/qrdecode/ 视频下载: http://weibodang.cn/ 多平台音乐在线播放: http://music.lkxin.cn/ 在线打字网站1: https://www.typingclub.com/在线打字网站2: https://www.typing.com/ 代码共享：https://paste.ubuntu.com/ 工具网站：http://www.bejson.com/ 图片托管：https://miao.su/ 多种语言在线编译器：http://www.dooccn.com/cpp/ 多平台音乐免费下载: https://music.boxmoe.cn/ 在线工具: https://tool.lu/ 百度云不限速: https://www.baiduwp.com/ 好的技术博文 python安装提示No module named setuptools,wget提示ERROR 403: SSL is requiredhttps://blog.csdn.net/jiaoshengha/article/details/79384223 里面提到的链接无法下载的问题,其实直接把链接复制到浏览器中打开就好,若是在终端下就可以使用里面说的方法,使用sudo wget 链接; ubuntu中安装eclipsehttps://blog.csdn.net/wmyan/article/details/78279846 ubuntu安装kchmviewer查看jdk-api文档https://blog.csdn.net/qq_32296307/article/details/53064587 直接一条命令：sudo apt-get install kchmviewer然后打开文档的时候选择kchmviewer就行了 git学习https://mp.weixin.qq.com/s/BHJ44cDhnPQrvqdqowwilg shell常用正则表达式https://mp.weixin.qq.com/s/IUrgFLNWnqJOe8yfcb2W6w Linux常用命令总结https://mp.weixin.qq.com/s/xtXPUy8qB4YMa5W8HwzoGA wget 命令用法详解https://mp.weixin.qq.com/s/iN_fsL98TeR8WsaCeMpVcw IntelliJ IDEA 教程设置讲解https://mp.weixin.qq.com/s/PbKCoAO1gyEgpsGs_FQ3oQ Ubuntu 18.04 安装、配置和美化https://blog.csdn.net/szhiy/article/details/81385107 Ubuntu安装Anaconda navigator 启动图形化界面https://blog.csdn.net/u013550000/article/details/80433402 安装、配置Jupyter Notebook快速入门https://www.cnblogs.com/Neo007/p/7501625.html 打开git bash时出现闪退https://blog.csdn.net/qq_34400736/article/details/72627343 Linux下安装jdkhttps://www.linuxidc.com/Linux/2015-01/112030.htm Linux之间互传文件https://blog.csdn.net/qq_30968657/article/details/72912070 北大ACM-POJ试题分类http://exp-blog.com/2018/06/28/pid-38/ git恢复误删的分支https://www.cnblogs.com/xd502djj/p/9319980.html 三级网络技术指南http://96ea5f9a.wiz03.com/share/s/2mWB-q0kLQ9B2ZqZt31C4U2z0nE7Tm03PAoR28IbN93qLZvQ","categories":[],"tags":[]},{"title":"markdown语法学习","slug":"markdown","date":"2019-05-08T06:10:13.758Z","updated":"2019-05-08T06:10:13.730Z","comments":true,"path":"2019/05/08/markdown/","link":"","permalink":"https://gydjsz.github.io/2019/05/08/markdown/","excerpt":"[markdown语法]https://www.jianshu.com/p/b03a8d7b1719[markdown语法]https://www.appinn.com/markdown/#header[markdown缩进]https://www.cnblogs.com/Flylater/p/6264799.html[先来一头马克飞象(在线使用markdown)]https://maxiang.io/[markdown插入图片]https://blog.csdn.net/slaughterdevil/article/details/79255933[添加百度云图片链接]https://jingyan.baidu.com/article/f006222806dfdcfbd3f0c880.html","text":"[markdown语法]https://www.jianshu.com/p/b03a8d7b1719[markdown语法]https://www.appinn.com/markdown/#header[markdown缩进]https://www.cnblogs.com/Flylater/p/6264799.html[先来一头马克飞象(在线使用markdown)]https://maxiang.io/[markdown插入图片]https://blog.csdn.net/slaughterdevil/article/details/79255933[添加百度云图片链接]https://jingyan.baidu.com/article/f006222806dfdcfbd3f0c880.html 目录： 插入跳转链接 缩进 插入图片 添加页内跳转 文章摘要显示 1.插入跳转链接https://blog.fbzl.org/“1&lt;a href=&quot;https://blog.fbzl.org/&quot; target=&quot;_blank&quot;&gt;https://blog.fbzl.org/&quot;&lt;/a&gt; 2.缩进在每一行开头的时候，先输入下面的代码，然后紧跟着输入文本即可。注意有分号123半角空格: &amp;ensp;或 &amp;#8194;全角空格: &amp;emsp;或 &amp;#8195;不换行空格: &amp;nbsp;或 &amp;#160; 3.插入图片首先插入本地图片的地址不是绝对路径,比如说我图片的绝对路径为~/Picture/picture1.jpg我写博客的位置是~/Documents/blog,那么添加的图片路径是相对路径,即从我当前路径开始算起,路径为../Picture/picture1.jpg; 了解linux的应该知道, “..”表示上一层目录, 可是我使用这种方法,会出现网页中显示不了图片的情况,甚至在一篇文章里面可以显示,但是放在另一篇文章里面就显示不了的情况,所以现在给出其它的方法 一. 使用base64编码图片和base64编码转换网址: http://www.vgot.net/test/image2base64.php? 因为编码很长,所以可以放在文章的最后面,以下的picture是编码id,可以自己设定1234567891011文章插入的图片位置:![图片说明][picture]文章文章末尾代码区域填写:[picture]:data:image/png;base64,编码 二. 使用百度云添加图片外链 首先上传图片到百度云盘中,存储容量有2T,所以不用担心图片太多,最好是单独创建一个文件夹,将图片保存在里面 鼠标右键点击分享,默认加密选项,有效期永久,然后点击确定 将链接复制到浏览器中打开,可以看到自己的图片,然后右键点击图片然后复制图片链接,这个就是你的图片外链了 在博客中添加图片外链: 1![图片说明](链接) 二. 使用github添加图片外链 先将图片上传到github中 在github中打开图片，复制图片链接 4.添加页内跳转12[跳转到标题](#1)&lt;span id=&quot;1&quot;&gt;标题&lt;/span&gt; 5.文章摘要显示12摘要文字部分&lt;!--more--&gt;","categories":[],"tags":[]},{"title":"vim配置","slug":"LearnVim/vimrc","date":"2019-04-18T05:41:25.201Z","updated":"2019-04-18T05:41:25.157Z","comments":true,"path":"2019/04/18/LearnVim/vimrc/","link":"","permalink":"https://gydjsz.github.io/2019/04/18/LearnVim/vimrc/","excerpt":"“ —————————– Vundle Start —————————–set nocompatiblefiletype offset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()“插件管理Plugin ‘VundleVim/Vundle.vim’“目录树Plugin ‘The-NERD-tree’“代码补全Bundle ‘Valloric/YouCompleteMe’“异步语法检查Plugin ‘w0rp/ale’call vundle#end()filetype plugin indent on“ —————————– Vundle End —————————–","text":"“ —————————– Vundle Start —————————–set nocompatiblefiletype offset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()“插件管理Plugin ‘VundleVim/Vundle.vim’“目录树Plugin ‘The-NERD-tree’“代码补全Bundle ‘Valloric/YouCompleteMe’“异步语法检查Plugin ‘w0rp/ale’call vundle#end()filetype plugin indent on“ —————————– Vundle End —————————– “ 开启语法高亮syntax on “ 设置字体set guifont=courier\\ 20 “ 检测文件类型filetype on “ 设置取消备份，禁止临时文件生成set nobackupset noswapfile “ 设置在Vim中可以使用鼠标，防止终端无法拷贝set mouse=a “ 显示当前行号和列号set ruler “ 在状态栏显示正在输入的命令set showcmd “ 总是显示状态栏(Powerline需要2行)set laststatus=2 “ 显示行号set number “ 设置代码匹配,包括括号匹配情况set showmatch “ 设置C/C++方式自动对齐set autoindentset cindentset smartindent “ 设置tab宽度set tabstop=4 “ 设置自动对齐空格数set shiftwidth=4 “ 按退格键时可以一次删除4个空格set softtabstop=4 “ 自动补全配置让Vim补全菜单行为跟IDE一致set completeopt=longest,menu “ 增强模式中的命令行自动完成操作set wildmenu map :NERDTreeToggle“map :NERDTreeToggle“ 显示行号let NERDTreeShowLineNumbers=1let NERDTreeAutoCenter=1“ 是否显示隐藏文件“let NERDTreeShowHidden=1“ 设置宽度let NERDTreeWinSize=30“ 在终端启动vim时，共享NERDTreelet g:nerdtree_tabs_open_on_console_startup=1“ 忽略一下文件的显示let NERDTreeIgnore=[‘.pyc’,’~$’,’.swp’]“ 显示书签列表let NERDTreeShowBookmarks=1let NERDTreeWinPos=1 “ vim不指定具体文件打开是，自动使用nerdtree“ autocmd StdinReadPre let s:std_in=1“autocmd VimEnter if argc() == 0 &amp;&amp; !exists(“s:std_in”) | NERDTree |endif“ 当vim打开一个目录时，nerdtree自动使用 autocmd StdinReadPre let s:std_in=1 autocmd VimEnter if argc() == 1 &amp;&amp; isdirectory(argv()[0]) &amp;&amp; !exists(“s:std_in”) | exe ‘NERDTree’ argv()[0] | wincmd p | ene | endif “ 寻找全局配置文件let g:ycm_global_ycm_extra_conf = ‘~/.vim/bundle/YouCompleteMe/cpp/ycm/.ycm_extra_conf.py’“ 禁用syntastic来对python检查let g:syntastic_ignore_files=[“..py$”]“ 使用ctags生成的tags文件let g:ycm_collect_identifiers_from_tag_files = 1“ 开启语义补全“ 修改对C语言的补全快捷键，默认是CTRL+space，修改为ALT+;未测出效果“let g:ycm_key_invoke_completion = ‘&lt;M-;&gt;’“ 设置转到定义处的快捷键为ALT+G，未测出效果“nmap :YcmCompleter GoToDefinitionElseDeclaration =expand(““)“关键字补全let g:ycm_seed_identifiers_with_syntax = 1“ 在接受补全后不分裂出一个窗口显示接受的项set completeopt-=preview“ 让补全行为与一般的IDE一致set completeopt=longest,menu“ 不显示开启vim时检查ycm_extra_conf文件的信息let g:ycm_confirm_extra_conf=0“ 每次重新生成匹配项，禁止缓存匹配项let g:ycm_cache_omnifunc=0“ 在注释中也可以补全let g:ycm_complete_in_comments=1“ 输入第一个字符就开始补全let g:ycm_min_num_of_chars_for_completion=1“ 错误标识符let g:ycm_error_symbol=’&gt;&gt;’“ 警告标识符let g:ycm_warning_symbol=’&gt;‘“ 不查询ultisnips提供的代码模板补全，如果需要，设置成1即可 let g:ycm_use_ultisnips_completer=1“ “ale“始终开启标志列let g:ale_sign_column_always = 1let g:ale_set_highlights = 0“自定义error和warning图标let g:ale_sign_error = ‘✗’let g:ale_sign_warning = ‘⚡’“在vim自带的状态栏中整合alelet g:ale_statusline_format = [‘✗ %d’, ‘⚡ %d’, ‘✔ OK’]“显示Linter名称,出错或警告等相关信息let g:ale_echo_msg_error_str = ‘E’let g:ale_echo_msg_warning_str = ‘W’let g:ale_echo_msg_format = ‘[%linter%] %s [%severity%]’“普通模式下，sp前往上一个错误或警告，sn前往下一个错误或警告nmap sp (ale_previous_wrap)nmap sn (ale_next_wrap) ab sp set autoindent “按下F9进行编译运行map :call CompileRunGcc() func! CompileRunGcc() silent exec “w” “ exec “!clear” “if &amp;filetype == ‘cpp’ silent exec “!g++ %” exec “!./a.out” “elseif &amp;filetype == ‘java’ “ exec “!javac %” “ exec “!java %&lt;” “endifendfunc imap &lt;c-]&gt; {}O map ggVG”+y “inoremap ( ()“inoremap [ []“inoremap { {}“inoremap “ “”“inoremap ‘ ‘’ map :call SetTitle()func SetTitle()let l = 0 “let l = l + 1 | call setline(l,’Author :herongwei’)“let l = l + 1 | call setline(l,’Created Time :’.strftime(‘%c’))“let l = l + 1 | call setline(l,’File Name :’.expand(‘%’))“let l = l + 1 | call setline(l,’’) “let l = l + 1 | call setline(l,’#include ‘)let l = l + 1 | call setline(l,’#include ‘)let l = l + 1 | call setline(l,’#include ‘)let l = l + 1 | call setline(l,’#include ‘)“let l = l + 1 | call setline(l,’#include ‘)“let l = l + 1 | call setline(l,’#include ‘)“let l = l + 1 | call setline(l,’#include ‘)“let l = l + 1 | call setline(l,’#include ‘)“let l = l + 1 | call setline(l,’#include ‘)“let l = l + 1 | call setline(l,’#include ‘)“let l = l + 1 | call setline(l,’#include &lt;time.h&gt;’)let l = l + 1 | call setline(l,’using namespace std;’)let l = l + 1 | call setline(l, ‘’)let l = l + 1 | call setline(l,’typedef long long ll;’)let l = l + 1 | call setline(l, ‘’)“let l = l + 1 | call setline(l,’const int maxn = 1e5+233;’)“let l = l + 1 | call setline(l,’const int MOD = 1e9+7;’)“let l = l + 1 | call setline(l,’const double eps= 1e-6;’)“let l = l + 1 | call setline(l,’const double pi = acos(-1.0);’)“let l = l + 1 | call setline(l,’int n,m,t,ans,res,tmp; ‘)let l = l + 1 | call setline(l,’int main(){‘)“let l = l + 1 | call setline(l,’ //freopen(“in.txt”,”r”,stdin);’)“let l = l + 1 | call setline(l,’ //freopen(“out.txt”,”w”,stdout);’)let l = l + 1 | call setline(l,’ ‘)let l = l + 1 | call setline(l,’ return 0;’)let l = l + 1 | call setline(l,’}’)endfunc “空格键格式化当前行，并跳到下一行imap == o","categories":[],"tags":[]},{"title":"牛客网43的B题","slug":"algorithm/nowcoderPractice43","date":"2019-04-09T12:44:27.600Z","updated":"2019-04-09T12:44:27.564Z","comments":true,"path":"2019/04/09/algorithm/nowcoderPractice43/","link":"","permalink":"https://gydjsz.github.io/2019/04/09/algorithm/nowcoderPractice43/","excerpt":"","text":"链接：https://ac.nowcoder.com/acm/contest/548/B来源：牛客网 题目描述立华奏在学习初中数学的时候遇到了这样一道大水题：“设箱子内有 n 个球，其中给 m 个球打上标记，设一次摸球摸到每一个球的概率均等，求一次摸球摸到打标记的球的概率”“emmm…语言入门题”但是她改了一下询问方式：设最终的答案为 p ,请输出 p 小数点后K1到K2位的所有数字（若不足则用 0 补齐）输入描述:第一行一个整数 T,表示有 T 组数据。接下来每行包含四个整数m, n, K1, K2，意义如「题目描述」所示。输出描述:输出 T 行，每行输出 K 2 − K 1 + 1 K2−K1+1 个数，表示答案。注意同行的数字中间不需要用空格隔开。示例1输入5 2 3 2 31 7 1 72 5 1 312345 54321 3 1012345 54321 100000 100010输出6614285714007260175678428232175备注: 1&lt;=m&lt;=n&lt;=109, 1&lt;=K1&lt;=K2&lt;=109, 1&lt;=m&lt;=n&lt;=109,1&lt;=K1&lt;=K2&lt;=109","categories":[],"tags":[]},{"title":"数据库使用笔记","slug":"SQL/useSqlServer","date":"2019-04-08T04:37:17.911Z","updated":"2019-04-08T04:37:17.871Z","comments":true,"path":"2019/04/08/SQL/useSqlServer/","link":"","permalink":"https://gydjsz.github.io/2019/04/08/SQL/useSqlServer/","excerpt":"停止，启动，重启SQL server服务","text":"停止，启动，重启SQL server服务 命令：sudo systemctl stop mssql-server 或 service mssql-server stop 命令：sudo systemctl start mssql-server 或 service mssql-server start 命令：sudo systemctl restart mssql-server 或 service mssql-server restart 移除mssqlserver开机自动启动服务update-rc.d -f mssql-server remove \\ld : 查看所有数据库 \\lt : 列出所有表 use Name : 使用Name数据库 CREATE TABLE Student : 创建Student表 INSERT INTO Student(Sno, Sage, Ssex) VALUES(1, 10, ‘男’); :插入数据，Student(Sno, Sage, Ssex)，省略括号中的内容，则默认为添加全部值，省略一部分，则为那部分值为空 SELECT * FROM INFORMATION_SCHEMA.columns WHERE TABLE_NAME=’表名’ : 获取表的字段名及类型 SELECT COLUMN_NAME,DATA_TYPE FROM INFORMATION_SCHEMA.columns WHERE TABLE_NAME=’Student’ : 查询表属性名和类型名 ALTER TABLE table_name ADD Sc CHAR(3); : 增加属性ScALTER TABLE table_name DROP Sc; : 删除属性ScALTER TABLE table_name ADD COLUMN Sage INT; : 将Sage字符型改为整数ALTER TABLE table_name ADD UNIQUE(Cname); : 增加Cname必须取唯一值的约束条件 SELECT Sage Hello FROM Student; :显示Sage的别名Hello SELECT 2019-Sage FROM Student; : 计算2019 - Sage之后的结果 SELECT DISTINCT Sno FROM Student; : 去除重复的行并查询SELECT Sno FROM Student; = SELECT ALL Sno FROM Student; : 显示所有查询 比较：&lt;&gt; 不等于、!&gt; 不大于、!&lt; 不小于确定范围：BETWEEN a AND b 属性在a~b之间的的元组、NOT BETWEEN a AND b确定集合：IN, NOT IN字符匹配：LIKE, NOT LIKE空值：IS NULL, NOT NULL多重条件：AND, OR, NOT SELECT Sname FROM Student WHERE Sdept=’CS’; :显示Sdept=’CS’的Sname SELECT Sname FROM Student WHERE Sage IN(‘10’, ‘20’); :显示年龄为10和20的学生姓名 SELECT Sname FROM Student WHERE Sno LIKE’2%3’; :查找学号以2开头3结尾的学生姓名% :代表任意长度_ :代表任意单个字符 SELECT * FROM Student ORDER BY Sno DESC; :按Sno降序显示Student表(ASC为升序) ALTER TABLE Course ADD FOREIGN KEY(Sno) REFERENCES Student(Sno); :修改Course中的Sno为Student(Sno)外码 从Excel文件中,导入数据到SQL数据库中, select * into 表 from OPENROWSET(‘MICROSOFT.JET.OLEDB.4.0’ ,’Excel 5.0;HDR=YES;DATABASE=c:\\test.xls’,sheet1$) YEAR(日期); :获得日期的年份 ORDER BY [] ASC/DESC; :升序/降序 SELECT TOP 10 PERCENT * FROM Student; :查询前10%的数据 DATEDIFF(day, 起始日期, 终止日期); :获得两时间差","categories":[],"tags":[]},{"title":"第九届蓝桥杯真题题解","slug":"algorithm/lqb9","date":"2019-03-23T10:37:59.054Z","updated":"2019-03-23T10:37:58.806Z","comments":true,"path":"2019/03/23/algorithm/lqb9/","link":"","permalink":"https://gydjsz.github.io/2019/03/23/algorithm/lqb9/","excerpt":"目录： 第几天 明码 乘积尾零 测试次数 快速排序 递增三元组 螺旋折线 日志统计 全球变暖 乘积最大","text":"目录： 第几天 明码 乘积尾零 测试次数 快速排序 递增三元组 螺旋折线 日志统计 全球变暖 乘积最大 1. 第几天 2000年的1月1日，是那一年的第1天。那么，2000年的5月4日，是那一年的第几天？ 解：思路：Excel解决: 2000/5/4 - 2000/1/1 + 1 = 1251,3: 31天、2: 29天、4: 30天、5: 4天 =&gt; 31 * 2 + 29 + 30 + 4 = 125 答案: 125 2.明码 汉字的字形存在于字库中，即便在今天，16点阵的字库也仍然使用广泛。16点阵的字库把每个汉字看成是16x16个像素信息。并把这些信息记录在字节中。 一个字节可以存储8位信息，用32个字节就可以存一个汉字的字形了。把每个字节转为2进制表示，1表示墨迹，0表示底色。每行2个字节，一共16行，布局是： 第1字节，第2字节 第3字节，第4字节 .... 第31字节, 第32字节 这道题目是给你一段多个汉字组成的信息，每个汉字用32个字节表示，这里给出了字节作为有符号整数的值。 题目的要求隐藏在这些信息中。你的任务是复原这些汉字的字形，从中看出题目的要求，并根据要求填写答案。 这段信息是（一共10个汉字）：4 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 016 64 16 64 34 68 127 126 66 -124 67 4 66 4 66 -124 126 100 66 36 66 4 66 4 66 4 126 4 66 40 0 164 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 00 -128 64 -128 48 -128 17 8 1 -4 2 8 8 80 16 64 32 64 -32 64 32 -96 32 -96 33 16 34 8 36 14 40 44 0 3 0 1 0 0 4 -1 -2 4 0 4 16 7 -8 4 16 4 16 4 16 8 16 8 16 16 16 32 -96 64 6416 64 20 72 62 -4 73 32 5 16 1 0 63 -8 1 0 -1 -2 0 64 0 80 63 -8 8 64 4 64 1 64 0 -1280 16 63 -8 1 0 1 0 1 0 1 4 -1 -2 1 0 1 0 1 0 1 0 1 0 1 0 1 0 5 0 2 02 0 2 0 7 -16 8 32 24 64 37 -128 2 -128 12 -128 113 -4 2 8 12 16 18 32 33 -64 1 0 14 0 112 01 0 1 0 1 0 9 32 9 16 17 12 17 4 33 16 65 16 1 32 1 64 0 -128 1 0 2 0 12 0 112 00 0 0 0 7 -16 24 24 48 12 56 12 0 56 0 -32 0 -64 0 -128 0 0 0 0 1 -128 3 -64 1 -128 0 0 注意：需要提交的是一个整数，不要填写任何多余内容。 解:思路: 每行两个字节，每一个字节存储一个整数，可以先将整数转化为8位二进制，负数的二进制需要+2^n(这里n为8),然后用除k取余法求得整数对应的二进制，然后1输出 * , 0输出空格,每画完两个整数换行最终输出为 九的九次方等于多少? 代码1:1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;using namespace std;int fun()&#123; int n; cin &gt;&gt; n; if(n &lt; 0)&#123; //负数的二进制原码为2^n + x n += pow(2, 8); &#125; int a[8], k = 7; memset(a, 0, sizeof(a)); while(n != 0)&#123; //除k取余法,余数最终要倒过来 a[k--] = n % 2; n /= 2; &#125; for(int i = 0; i &lt; 8; i++)&#123; //输出图形 if(a[i] == 1) cout &lt;&lt; \"*\"; else cout &lt;&lt; \" \"; &#125; return 0;&#125;int main()&#123; for(int i = 0; i &lt; 10; i++) for(int j = 0; j &lt; 16; j++)&#123; fun(); //两个整数为一行，就直接调用两次函数 fun(); cout &lt;&lt; endl; &#125; return 0;&#125; 代码2:12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;bitset&gt;#include &lt;cstring&gt;using namespace std;int fun()&#123; cin &gt;&gt; n; bitset&lt;8&gt; b(n); //创建一个数值为n的8位二进制数,从左到右是低位到高位 for(int i = b.size() - 1; i &gt;= 0; i--)&#123; if(b[i] == 0) //直接下标访问 cout &lt;&lt; \" \"; else cout &lt;&lt; \"*\"; &#125;&#125;int main()&#123; for(int i = 0; i &lt; 10; i++) for(int j = 0; j &lt; 16; j++)&#123; fun(); fun(); cout &lt;&lt; endl; &#125; return 0;&#125; 答案: 387420489 3. 乘积尾零 如下的10行数据，每行有10个整数，请你求出它们的乘积的末尾有多少个零？ 5650 4542 3554 473 946 4114 3871 9073 90 43292758 7949 6113 5659 5245 7432 3051 4434 6704 35949937 1173 6866 3397 4759 7557 3070 2287 1453 98991486 5722 3135 1170 4014 5510 5120 729 2880 90192049 698 4582 4346 4427 646 9742 7340 1230 76835693 7015 6887 7381 4172 4341 2909 2027 7355 56496701 6645 1671 5978 2704 9926 295 3125 3878 67852066 4247 4800 1578 6652 4616 1113 6205 3264 29153966 5291 2904 1285 2193 1428 2265 8730 9436 7074689 5510 8243 6114 337 4096 8199 7313 3685 211 注意：需要提交的是一个整数，表示末尾零的个数。不要填写任何多余内容。 解：思路：由于2 * 5 = 10,因此直接求出所有数中2和5的个数，取最小的那个数就是0的个数 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;//求能整除的2的个数int fun2(int n)&#123; int sum1 = 0; while(n % 2 == 0)&#123; //不断除以2，直到该数不能被整除，求出的就是2的个数 n /= 2; sum1++; &#125; return sum1;&#125;//求能整除的5的个数int fun5(int n)&#123; int sum1 = 0; while(n % 5 == 0)&#123; n /= 5; sum1++; &#125; return sum1;&#125;int main()&#123; int sum2 = 0, sum5 = 0; int n; for(int i = 0; i &lt; 100; i++)&#123; cin &gt;&gt; n; sum2 += fun2(n); sum5 += fun5(n); &#125; int m = min(sum2, sum5); //2和5的个数中最小的那个就是10的个数,也就是末尾为0的个数 cout &lt;&lt; m &lt;&lt; endl; return 0;&#125; 4. 测试次数 x星球的居民脾气不太好，但好在他们生气的时候唯一的异常举动是：摔手机。各大厂商也就纷纷推出各种耐摔型手机。x星球的质监局规定了手机必须经过耐摔测试，并且评定出一个耐摔指数来，之后才允许上市流通。 x星球有很多高耸入云的高塔，刚好可以用来做耐摔测试。塔的每一层高度都是一样的，与地球上稍有不同的是，他们的第一层不是地面，而是相当于我们的2楼。 如果手机从第7层扔下去没摔坏，但第8层摔坏了，则手机耐摔指数=7。特别地，如果手机从第1层扔下去就坏了，则耐摔指数=0。如果到了塔的最高层第n层扔没摔坏，则耐摔指数=n 为了减少测试次数，从每个厂家抽样3部手机参加测试。 某次测试的塔高为1000层，如果我们总是采用最佳策略，在最坏的运气下最多需要测试多少次才能确定手机的耐摔指数呢？ 请填写这个最多测试次数。 注意：需要填写的是一个整数，不要填写任何多余内容。 解:思路: 这是一道动态规划的题，设dp[i][j]表示i部, 耐摔指数为j的手机的测试次数，经过k次测试能够得出手机的耐摔指数，可以写出状态转移方程dp[i][j] = max(dp[i - 1][k - 1], dp[i][j - k]) + 1。dp[i - 1][k - 1]表示第i部手机摔坏了，这个时候手机数目-1，测试次数k-1，需要从k-1层测试才能保证测出耐摔指数(k - 1次机会，测试1 ~ k - 1层必定测出)，dp[i][j - k]表示第i部手机没有摔坏，这个时候就要测试k + 1 ~ j层，可以转化为测试1 ~ j - k层(这里只是层数的区间和高度无关)，由于是最坏的运气下的测试次数，所以取前面两者的最大测试次数+1就是这一次测试的次数(如果不取最大，那么最坏情况不能满足, +1是因为要加上这一次的测试)，经过最佳策略得出的测试次数应该小于等于每一层都摔手机的这个最大次数, 即取min(dp[i][j], max(dp[i - 1][k - 1], dp[i][j - k]) + 1) N个鸡蛋从M楼层摔 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; int phone = 3, house = 1000; //3部手机，1000层楼 int dp[5][1005]; memset(dp, 0, sizeof(dp)); for(int i = 1; i &lt;= phone; i++)&#123; //初始化dp为最坏的层数，也就是每一层都要试 for(int j = 1;j &lt;= house; j++)&#123; dp[i][j] = j; &#125; &#125; for(int i = 2; i &lt;= phone; i++) for(int j = 1; j &lt;= house; j++)&#123; //i部手机在j层楼的摔坏指数 for(int k = 1; k &lt; j; k++) //测试次数为k //最优策略：1. 第i部手机摔坏, 假设前面已经求出摔坏指数，则摔坏指数为dp[i - 1][k - 1]; 2. 第i部手机没有摔坏，则摔坏指数为第i部手机在k + 1 ~ j中测试后得出的摔坏指数，k + 1 ~ j可以转化为1 ~ j - k, 即dp[i][j - k] dp[i][j] = min(dp[i][j], max(dp[i - 1][k - 1], dp[i][j - k]) + 1); &#125; cout &lt;&lt; dp[3][1000] &lt;&lt; endl; //由于是在层数增加的情况下在dp[i][j]得出测试次数k，那么无论层数多高，测试次数都是k,这里由于不知道j，取最高层就行 return 0;&#125; 答案: 19 快速排序 以下代码可以从数组a[]中找出第k小的元素。它使用了类似快速排序中的分治算法，期望时间复杂度是O(N)的。请仔细阅读分析源码，填写划线部分缺失的内容。 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;int quick_select(int a[], int l, int r, int k) &#123; int p = rand() % (r - l + 1) + l; int x = a[p]; &#123;int t = a[p]; a[p] = a[r]; a[r] = t;&#125; int i = l, j = r; while(i &lt; j) &#123; while(i &lt; j &amp;&amp; a[i] &lt; x) i++; if(i &lt; j) &#123; a[j] = a[i]; j--; &#125; while(i &lt; j &amp;&amp; a[j] &gt; x) j--; if(i &lt; j) &#123; a[i] = a[j]; i++; &#125; &#125; a[i] = x; p = i; if(i - l + 1 == k) return a[i]; if(i - l + 1 &lt; k) return quick_select( _____________________________ ); //填空 else return quick_select(a, l, i - 1, k);&#125;int main()&#123; int a[] = &#123;1, 4, 2, 8, 5, 7, 23, 58, 16, 27, 55, 13, 26, 24, 12&#125;; printf(\"%d\\n\", quick_select(a, 0, 14, 5)); return 0;&#125; 解:思路:首先观察代码，rand() % m是随机产生0 ~ m - 1的随机数，l为左边数的下标，r为右边数的下标, r - l + 1是[l, r]这个区间的长度也就是从这个区间从取出一个数a[p]赋值给x, 这里有个{int t = a[p]; a[p] = a[r]; a[r] = t;}交换操作，是因为循环中有两个if，如果没有这个操作，那么赋值操作会覆盖数据，例如1 2 3 4, 假设x = 3, 当a[i] = 3时, 不满足a[i] &lt; x跳出循环, 这个时候进入if，a[j] = 3, j–, 数组a中的数据为1 2 3 3, j = 3, 可以观察到数组中的4丢失了，所以预先把3放在最后就不会出现这种情况 =&gt; 1 2 4 3, 跳出循环时：1 2 4 4, 最后有个a[i] = x =&gt; 1 2 3 4然后中间循环就是熟悉的快速排序的操作，将比x小的放在它左边，比x大的放在它右边，这样即使x左右两边的数是无序的，x也是第i - l + 1大，这样就比较i - l + 1这个下标和下标k的大小，如果相等，那么这个数就是第k小，如果小于k，那么就找[i + 1, r]区间内的第k - (i - l + 1)小(如果假设n = i - l + 1,a[n]是第n小，那么只要再往后找k - n个数，那么就找到了k =&gt; 1 2 n 4 5 k)，就是最终的结果，如果大于k,那么就找[l, i - 1]区间内的第k小 答案: a, i + 1, r, k - (i - l + 1) 6. 递增三元组 给定三个整数数组A = [A1, A2, … AN],B = [B1, B2, … BN],C = [C1, C2, … CN]，请你统计有多少个三元组(i, j, k) 满足： 1 &lt;= i, j, k &lt;= N Ai &lt; Bj &lt; Ck 【输入格式】第一行包含一个整数N。第二行包含N个整数A1, A2, … AN。第三行包含N个整数B1, B2, … BN。第四行包含N个整数C1, C2, … CN。 对于30%的数据，1 &lt;= N &lt;= 100对于60%的数据，1 &lt;= N &lt;= 1000对于100%的数据，1 &lt;= N &lt;= 100000 0 &lt;= Ai, Bi, Ci &lt;= 100000 【输出格式】一个整数表示答案 【样例输入】31 1 12 2 23 3 3 【样例输出】27 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 解:思路: 先将三个数组中的数据排序，然后用查找a中有多少小于b的数，c中有多少大于b的数，然后求乘积就是b[i]情况下的组合数，最后将所有的组合数求和这里可以用库函数upper__bound(a, a + n, k), (函数为二分查找, 效率logn), 表示从ａ数组中查询第一个大于k的数，并返回其地址，由于a是数组的首地址，我们用upper__bound(a, a + n, k) - a就可以求得小于b[i]的个数 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;int main()&#123; int n; cin &gt;&gt; n; int a[100001], b[100001], c[100001]; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; for(int i = 0; i &lt; n; i++) cin &gt;&gt; b[i]; for(int i = 0; i &lt; n; i++) cin &gt;&gt; c[i]; ll sum = 0; for(int i = 0; i &lt; n; i++)&#123; ll s1 = upper_bound(a, a + n, b[i]) - a; //求出a数组中小于b[i]的个数 ll s2 = n - (upper_bound(c, c + n, b[i]) - c); //求出c数组中大于b[i]的个数 sum += s1 * s2; //求组合情况数 &#125; cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125; 螺旋折线 如图 所示的螺旋折线经过平面上所有整点恰好一次。对于整点(X, Y)，我们定义它到原点的距离dis(X, Y)是从原点到(X, Y)的螺旋折线段的长度。 例如dis(0, 1)=3, dis(-2, -1)=9 给出整点坐标(X, Y)，你能计算出dis(X, Y)吗？ 【输入格式】X和Y 对于40%的数据，-1000 &lt;= X, Y &lt;= 1000对于70%的数据，-100000 &lt;= X， Y &lt;= 100000对于100%的数据, -1000000000 &lt;= X, Y &lt;= 1000000000 【输出格式】输出dis(X, Y) 【样例输入】0 1 【样例输出】3 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 解:思路: 先将左下角的一条边旋转90°，得到将输入的x和y比较大小，将大的数n作为最外层正方形的边，起点为(-n, -n), 计算(x, y)和(-n, -n)的距离d1 = x - n, d2 = y - n, 当y &gt; x时，点在左部和上部, 最外层的边数为d1 + d2 (也就是走过的边); 当y &lt; x时，点在右部和下部，最外层的边数为总边数8 * n - (d1 + d2) (也就是总边减去没有经过的边),内层边为8 * 1, 8 * 2, 8 * 3, 8 * 4… =&gt; 8 * (n * (n - 1) / 2) =&gt; 4 * n * (n - 1), 最后求和sum + d 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;typedef long long ll;int main()&#123; ll x, y; cin &gt;&gt; x &gt;&gt; y; ll n = max(abs(x), abs(y)); //求最大的那个值，作为外层正方形的边 ll sum = 4 * n * (n - 1); //计算内层所有正方形的边长 ll tx = -n, ty = -n; //得到左下角的那个点 ll d = 0, d1 = x - tx, d2 = y - ty; if(y &gt; x) //在y - x &gt; 0的那一块，直接将x和y的相对距离相加 d = d1 + d2; else //在y - x &lt;= 0的那一块，直接用总数减去没有走的边 d = 8 * n - d1 - d2; cout &lt;&lt; sum + d &lt;&lt; endl; //最后求和 return 0;&#125; 8. 日志统计 小明维护着一个程序员论坛。现在他收集了一份”点赞”日志，日志共有N行。其中每一行的格式是： ts id 表示在ts时刻编号id的帖子收到一个”赞”。 现在小明想统计有哪些帖子曾经是”热帖”。如果一个帖子曾在任意一个长度为D的时间段内收到不少于K个赞，小明就认为这个帖子曾是”热帖”。 具体来说，如果存在某个时刻T满足该帖在[T ,T + D)这段时间内(注意是左闭右开区间)收到不少于K个赞，该帖就曾是”热帖”。 给定日志，请你帮助小明统计出所有曾是”热帖”的帖子编号。 【输入格式】第一行包含三个整数N、D和K。以下N行每行一条日志，包含两个整数ts和id。 对于50%的数据，1 &lt;= K &lt;= N &lt;= 1000对于100%的数据，1 &lt;= K &lt;= N &lt;= 100000 0 &lt;= ts &lt;= 100000 0 &lt;= id &lt;= 100000 【输出格式】按从小到大的顺序输出热帖id。每个id一行。 【输入样例】7 10 20 10 1010 1010 19 1100 3100 3 【输出样例】13 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms https://blog.csdn.net/qq_34202873/article/details/79835686 全球变暖 你有一张某海域NxN像素的照片，”.”表示海洋、”#”表示陆地，如下所示： ……..##…..##….….##...####.…###.……. 其中”上下左右”四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有2座岛屿。 由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。 例如上图中的海域未来会变成如下样子： …….…….…….…….….#..…….……. 请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。 【输入格式】第一行包含一个整数N。 (1 &lt;= N &lt;= 1000)以下N行N列代表一张海域照片。 照片保证第1行、第1列、第N行、第N列的像素都是海洋。 【输出格式】一个整数表示答案。 【输入样例】7……..##…..##….….##...####.…###.……. 【输出样例】1 资源约定：峰值内存消耗（含虚拟机） &lt; 256;MCPU消耗 &lt; 1000ms https://blog.csdn.net/holly_Z_P_F/article/details/88727693 乘积最大 给定N个整数A1, A2, … AN。请你从中选出K个数，使其乘积最大。 请你求出最大的乘积，由于乘积可能超出整型范围，你只需输出乘积除以1000000009的余数。 注意，如果X&lt;0， 我们定义X除以1000000009的余数是负(-X)除以1000000009的余数。即：0-((0-x) % 1000000009) 【输入格式】第一行包含两个整数N和K。以下N行每行一个整数Ai。 对于40%的数据，1 &lt;= K &lt;= N &lt;= 100对于60%的数据，1 &lt;= K &lt;= 1000对于100%的数据，1 &lt;= K &lt;= N &lt;= 100000 -100000 &lt;= Ai &lt;= 100000 【输出格式】一个整数，表示答案。 【输入样例】5 3-100000-10000210000010000 【输出样例】999100009 再例如：【输入样例】5 3-100000-100000-2-100000-100000 【输出样例】-999999829 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms https://blog.csdn.net/qq_34202873/article/details/79835790","categories":[],"tags":[]},{"title":"第六届蓝桥杯真题解析","slug":"algorithm/lqb6","date":"2019-03-20T10:53:11.097Z","updated":"2019-03-20T10:53:11.057Z","comments":true,"path":"2019/03/20/algorithm/lqb6/","link":"","permalink":"https://gydjsz.github.io/2019/03/20/algorithm/lqb6/","excerpt":"启明星工作室解析 目录： 奖券数目 星系炸弹 三羊献瑞 格子中输出 九数组分数 加法变乘法 牌型种数 移动距离 垒骰子 生命之树","text":"启明星工作室解析 目录： 奖券数目 星系炸弹 三羊献瑞 格子中输出 九数组分数 加法变乘法 牌型种数 移动距离 垒骰子 生命之树 1. 奖券数目 有些人很迷信数字，比如带“4”的数字，认为和“死”谐音，就觉得不吉利。虽然这些说法纯属无稽之谈，但有时还要迎合大众的需求。某抽奖活动的奖券号码是5位数（10000-99999），要求其中不要出现带“4”的号码，主办单位请你计算一下，如果任何两张奖券不重号，最多可发出奖券多少张。 请提交该数字（一个整数），不要写任何多余的内容或说明性文字。 解:思路:后四个数可选0 ~ 9除去4，共9个数，第一个数可选1 ~ 9除去4，共8个数，所有没有4的总数为：8 9 9 9 9 = 52488 代码：1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main()&#123; string s; int sum = 0; int i, j; for(i = 10000; i &lt;= 99999; i++)&#123; s = to_string(i); for(j = 0; j &lt; s.length(); j++) if(s[j] == '4') break; if(j == s.length()) sum++; &#125; cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125; 答案: 52488 2. 星系炸弹 在X星系的广袤空间中漂浮着许多X星人造“炸弹”，用来作为宇宙中的路标。每个炸弹都可以设定多少天之后爆炸。比如：阿尔法炸弹2015年1月1日放置，定时为15天，则它在2015年1月16日爆炸。有一个贝塔炸弹，2014年11月9日放置，定时为1000天，请你计算它爆炸的准确日期。请填写该日期，格式为 yyyy-mm-dd 即4位年份2位月份2位日期。比如：2015-02-19 请严格按照格式书写。不能出现其它文字或符号。 解：思路：先算完2014年的天数，11月30天，12月31天，那么还剩30 + 31 - 9 = 52天，定时变为1000 - 52 = 948天，2015为365天，2016为366天，2017为365天，算上2015和2016的，定时变为948 - 365 - 366 = 217天，2017年1~6月31,28,31,30,31,30,31共212天，定时变为217 - 212 = 5天，7月再过5天，爆炸，日期为2017-08-05 答案：2017-08-05 3. 三羊献瑞 观察下面的加法算式：12345 祥 瑞 生 辉 + 三 羊 献 瑞------------------- 三 羊 生 瑞 气 其中，相同的汉字代表相同的数字，不同的汉字代表不同的数字。 请你填写“三羊献瑞”所代表的4位数字（答案唯一），不要填写任何多余内容。 解：思路：先观察这个等式，易得’三’表示的数字为1，因为10进制进位为1，祥所代表的数必定大于７，如果为7，那么7 + 1 = 8，而’瑞’＋’羊’进位不可能为2, ‘祥’所代表的数就为8或者9，如果为８，那么发生进位，’祥’ + ‘三’ = 10,那么’羊’为0，而一个一位数加上０不可能进位，所以’祥’为９，’羊’为０，此时得到祥(9), 三(1), 羊(0),因为’瑞’ + ‘羊’(0) = 生，’瑞’ != ‘羊’，所以发生进位，’瑞’ + 1 = ‘生’, ‘生’ + ‘献’ = ‘瑞’，即’瑞’ + 1 + ‘献’ = ‘瑞’ + 10，’献’ = 9，发生冲突(祥为９)，所以’’辉’＋’瑞’必定发生进位，’献’为８，然后将’瑞’从２开始取，一个个试，’瑞’(2), ‘辉’ 取８或９，矛盾;’瑞’(3),’辉’取７或８或９,矛盾;最终，’瑞’(5),’辉’(7),’生’(4)满足,此时’祥’(9),’瑞’(5),’生’(4),’辉’(7),’三’(1),’羊’(0),’献’(8),’气’(2) 代码实现：1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int a[10]; for(int i = 0; i &lt;= 9; i++) a[i] = i; do&#123; int a0 = a[0]; //祥 int a1 = a[1]; //瑞 int a2 = a[2]; //生 int a3 = a[3]; //辉 int a4 = a[4]; //三 int a5 = a[5]; //羊 int a6 = a[6]; //献 int a7 = a[7]; //气 int x1 = a0 * 1000 + a1 * 100 + a2 * 10 + a3; int x2 = a4 * 1000 + a5 * 100 + a6 * 10 + a1; int x3 = a4 * 10000 + a5 * 1000 + a2 * 100 + a1 * 10 + a7; if(a0 != 0 &amp;&amp; a4 != 0 &amp;&amp; x1 + x2 == x3) //最高位不能为0 cout &lt;&lt; a4 &lt;&lt; a5 &lt;&lt; a6 &lt;&lt; a1 &lt;&lt; endl; &#125;while(next_permutation(a, a + 10)); return 0;&#125; 答案：1085 4. 格子中输出 StringInGrid函数会在一个指定大小的格子中打印指定的字符串。要求字符串在水平、垂直两个方向上都居中。如果字符串太长，就截断。如果不能恰好居中，可以稍稍偏左或者偏上一点。 下面的程序实现这个逻辑，请填写划线部分缺少的代码。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;string.h&gt;void StringInGrid(int width, int height, const char* s)&#123; int i,k; char buf[1000]; strcpy(buf, s); if(strlen(s)&gt;width-2) buf[width-2]=0; printf(\"+\"); for(i=0;i&lt;width-2;i++) printf(\"-\"); printf(\"+\\n\"); for(k=1; k&lt;(height-1)/2;k++)&#123; printf(\"|\"); for(i=0;i&lt;width-2;i++) printf(\" \"); printf(\"|\\n\"); &#125; printf(\"|\"); printf(\"%*s%s%*s\",_____________________________________________); //填空 printf(\"|\\n\"); for(k=(height-1)/2+1; k&lt;height-1; k++)&#123; printf(\"|\"); for(i=0;i&lt;width-2;i++) printf(\" \"); printf(\"|\\n\"); &#125; printf(\"+\"); for(i=0;i&lt;width-2;i++) printf(\"-\"); printf(\"+\\n\"); &#125;int main()&#123; StringInGrid(20,6,\"abcd1234\"); return 0;&#125; 1234567对于题目中数据，应该输出：+------------------+| || abcd1234 || || |+------------------+ 注意：只填写缺少的内容，不要书写任何题面已有代码或说明性文字。 解：思路：观察代码(或者先将要填的地方注释，然后运行一遍程序)结果为123456+------------------+| |||| || |+------------------+, 123456789发现要填的地方其实是要在恰当的地方输出这个这个字符，框框之类的已经帮我们写好了，观察printf(&quot;%*s%s%*s&quot;, ),首先要了解%*s是什么，这个printf(&quot;%*s&quot;, 10, s) 意思是输出字符串s，但至少占10个位置，不足的在字符串s左边补空格，这里等同于printf(&quot;%10s&quot;, s) 这样就明白了，%s应该是要输出字符串，%*s是要输出空格，多少空格呢，若要让字符串居中，那么空格个数为(width - strlen(s) - 2) / 2, 左右两边空格一样，那么就先算出总共有多少空格然后除以２就ｏｋ，所以结果就是printf(&quot;%*s%s%*s&quot;, (width - strlen(s) - 2) / 2, buf, (width - strlen(s) - 1) / 2); 这里中间为buf,因为题目中说明了超出界限的字符串要去掉，而代码中有buf[width - 2] = 0这个操作，说明输出的是ｂｕｆ,这里需要注意奇偶性问题，如果width为奇数，那么就要多一个空格，所以后面的宽度需要加上１再除２,即奇数多１，补上1再除２，就添了１，偶数＋1，除２，1 / 2值为０。 答案：(width - strlen(s) - 2) / 2, buf, (width - strlen(s) - 1) / 2 5. 九数组分数 1,2,3…9 这九个数字组成一个分数，其值恰好为1/3，如何组法？ 下面的程序实现了该功能，请填写划线部分缺失的代码。 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;void test(int x[])&#123; int a = x[0]*1000 + x[1]*100 + x[2]*10 + x[3]; int b = x[4]*10000 + x[5]*1000 + x[6]*100 + x[7]*10 + x[8]; if(a*3==b) printf(\"%d / %d\\n\", a, b);&#125;void f(int x[], int k)&#123; int i,t; if(k&gt;=9)&#123; test(x); return; &#125; for(i=k; i&lt;9; i++)&#123; &#123;t=x[k]; x[k]=x[i]; x[i]=t;&#125; f(x,k+1); _____________________________________________ // 填空处 &#125;&#125; int main()&#123; int x[] = &#123;1,2,3,4,5,6,7,8,9&#125;; f(x,0); return 0;&#125; 注意：只填写缺少的内容，不要书写任何题面已有代码或说明性文字。 解：思路：观察代码，很明显地发现ｆ一个递归函数，从第一个数字开始，不断将数组数字进行交换，然后得出所有的情况，最后调用test()函数测试是否为1 / 3, 在一次递归完成后需要将数组内的数字位置还原，因而结果应该填{t=x[k]; x[k]=x[i]; x[i]=t;},也就是交换一遍之后再重复这个操作便可以还原位置 答案：{t=x[k]; x[k]=x[i]; x[i]=t;} 6. 加法变乘法 我们都知道：1+2+3+ … + 49 = 1225现在要求你把其中两个不相邻的加号变成乘号，使得结果为2015 比如：1+2+3+…+1011+12+…+2728+29+…+49 = 2015就是符合要求的答案。 请你寻找另外一个可能的答案，并把位置靠前的那个乘号左边的数字提交（对于示例，就是提交10）。 注意：需要你提交的是一个整数，不要填写任何多余的内容。 解：思路：这题首先想到的就是一个个地试，因为已经告诉了一种情况，那么，左边的数字必然&gt;10,最右边的数字必然小于28,因为如果是&lt;10和大于28,由于后面的数字相乘之后太大，一定是超出2015的，因而只要尝试&gt;10&amp;&amp;&lt;28以内的就ｏｋ，尝试方法举例:若是11 12 和 26 27，那么1125 - 11 - 12 - 26 - 27 + 11 12 + 26 27, 多次尝试之后得到16 17 24 25 也可以写程序：1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main()&#123; int a[49]; int sum = 1225; for(int i = 1; i &lt;= 49; i++) a[i] = i; int i, j, p, q; for(i = 1, j = i + 1; i &lt;= 46; i++, j++) for(p = i + 2, q = p + 1; p &lt;= 48; p++, q++)&#123; if(sum - a[i] - a[j] - a[p] - a[q] + a[i] * a[j] + a[p] * a[q] == 2015)&#123; cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j &lt;&lt; \" \" &lt;&lt; p &lt;&lt; \" \" &lt;&lt; q &lt;&lt; endl; &#125; &#125; return 0;&#125; 答案：16 7. 牌型种数 小明被劫持到X赌城，被迫与其他3人玩牌。一副扑克牌（去掉大小王牌，共52张），均匀发给4个人，每个人13张。这时，小明脑子里突然冒出一个问题：如果不考虑花色，只考虑点数，也不考虑自己得到的牌的先后顺序，自己手里能拿到的初始牌型组合一共有多少种呢？ 请填写该整数，不要填写任何多余的内容或说明文字。 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int count = 0; //count为情况总数int dfs(int poker, int cnt)&#123; //poker为点数, cnt为张数 if(poker &gt; 13 || cnt &gt; 13) //点数或者张数大于１３，返回 return 0; if(cnt == 13)&#123; //当张数满足１３时，算作一种取法 count++; return 0; &#125; for(int i = 0; i &lt;= 4; i++) dfs(poker + 1, cnt + i); //点数逐渐加１，取牌张数从０到４ return 0;&#125;int main()&#123; dfs(0, 0); cout &lt;&lt; count &lt;&lt; endl; return 0;&#125; 8. 移动距离 X星球居民小区的楼房全是一样的，并且按矩阵样式排列。其楼房的编号为1,2,3…当排满一行时，从下一行相邻的楼往反方向排号。比如：当小区排号宽度为6时，开始情形如下： 1 2 3 4 5 612 11 10 9 8 713 14 15 ….. 我们的问题是：已知了两个楼号m和n，需要求出它们之间的最短移动距离（不能斜线方向移动） 输入为3个整数w m n，空格分开，都在1到10000范围内w为排号宽度，m,n为待计算的楼号。要求输出一个整数，表示m n 两楼间最短移动距离。 例如：用户输入：6 8 2则，程序应该输出：4 再例如：用户输入：4 7 20则，程序应该输出：5 资源约定：峰值内存消耗 &lt; 256MCPU消耗 &lt; 1000ms 代码： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int getX(int w, int m)&#123; //计算所在行 return m % w == 0 ? m / w : m / w + 1; //如果是中间的点，因为除不尽，所以需要＋１&#125;int getY(int x, int w, int m)&#123; if(x % 2 == 0) //能被２整除，数字从右往左排列//(x - 1) * w 是上面有多少数字，m - (x - 1) * w是当前的位置,然后用ｗ减去这个位置再＋１，就是当前所在列 return w - (m - (x - 1) * w) + 1; else return m - (x - 1) * w;&#125;int main()&#123; int w, m, n; cin &gt;&gt; w &gt;&gt; m &gt;&gt; n; int x1, y1, x2, y2; x1 = getX(w, m); x2 = getX(w, n); y1 = getY(x1, w, m); y2 = getY(x2, w, n); cout &lt;&lt; abs(x1 - x2) + abs(y1 - y2) &lt;&lt; endl; return 0;&#125; 9. 垒骰子 赌圣atm晚年迷恋上了垒骰子，就是把骰子一个垒在另一个上边，不能歪歪扭扭，要垒成方柱体。经过长期观察，atm 发现了稳定骰子的奥秘：有些数字的面贴着会互相排斥！我们先来规范一下骰子：1 的对面是 4，2 的对面是 5，3 的对面是 6。假设有 m 组互斥现象，每组中的那两个数字的面紧贴在一起，骰子就不能稳定的垒起来。atm想计算一下有多少种不同的可能的垒骰子方式。两种垒骰子方式相同，当且仅当这两种方式中对应高度的骰子的对应数字的朝向都相同。由于方案数可能过多，请输出模 10^9 + 7 的结果。 不要小看了 atm 的骰子数量哦～ 「输入格式」第一行两个整数 n mn表示骰子数目接下来 m 行，每行两个整数 a b ，表示 a 和 b 数字不能紧贴在一起。 「输出格式」一行一个数，表示答案模 10^9 + 7 的结果。 「样例输入」2 11 2 「样例输出」544 「数据范围」对于 30% 的数据：n &lt;= 5对于 60% 的数据：n &lt;= 100对于 100% 的数据：0 &lt; n &lt;= 10^9, m &lt;= 36 资源约定：峰值内存消耗 &lt; 256MCPU消耗 &lt; 2000ms 解：思路：矩阵X记录骰子是否选择，选择为０，不选为１，不能相贴合的面就为０，这里可以转化为顶面不满足的就为０，这样比较方便，比如1 2不能紧贴在一起，1的对面为4，2的对面为5, 那么如果1为顶面，那么下一个骰子的顶面就不能为5，这样相比前一个骰子看顶面，后一个骰子看底面的方法简单许多，然后矩阵A1 A2就计算这两个骰子的所有匹配情况，A1[i][j]表示点数为i，顶面为j的方案总数，A2就是新加入的一个骰子，比如我现在前面的骰子的匹配情况是10，那么将每一个点数所代表的方案数再和一个骰子相乘，如果该骰子为０，表示有冲突，那么相乘之后就为０，就不加入进来，如果是１，那么就加入进来，假如情况为1 2 3 1 2 1, 一个骰子为1 1 1 1 0 1, 点数为１时:1 1 + 1 1 + 1 1 + 1 1 + 1 0 + 1 1,点数为２时2 1 + 1 1 + 1 1 + 1 1 + 2 0 + 1…就和矩阵相乘是一样的，令X那么先利用矩阵快速幂求An, An = An-1 * X, A1 = E(单位矩阵), An = X ^ (n - 1), 之后再将矩阵内的值全部加起来就是顶面方案的全部情况，最后再乘以4 ^ n,因为有四个面，面可以旋转，这个用快速幂求解，避免爆 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;typedef vector&lt;ll&gt; vec;typedef vector&lt;vec&gt; mat;const ll MOD = 1000000007;//矩阵连乘mat mul(mat &amp;A, mat &amp;B)&#123; mat C(A.size(), vec(B[0].size())); for(int i = 0; i &lt; A.size(); i++) for(int j = 0; j &lt; B.size(); j++) for(int k = 0; k &lt; B[0].size(); k++) C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD; return C;&#125;//矩阵快速幂mat fast_pow1(mat &amp;A, int n)&#123; mat B(A.size(), vec(A.size())); for(int i = 0; i &lt; A.size(); i++) B[i][i] = 1; while(n)&#123; if(n &amp; 1) B = mul(B, A); A = mul(A, A); n &gt;&gt;= 1; &#125; return B;&#125;//快速幂ll fast_pow2(ll x, ll n)&#123; ll res = 1; while(n)&#123; if(n &amp; 1) res = res * x % MOD; x = x * x % MOD; n &gt;&gt;= 1; &#125; return res;&#125;int main()&#123; ll n, m; cin &gt;&gt; n &gt;&gt; m; int a, b; mat A(6, vec(6, 1)); //６行６列，全部值初始化为１ for(int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; a &gt;&gt; b; /** 从０开始计数,所以a - 1表示当前点,和(b + 2) % 6不相融， 例如1 2, a - 1 = 0, (b + 2) % 6 = 4, 0为顶面时，下一个骰子的4不能为顶面，相当于１和５, 当１为顶面时，２不能为底面，2为底面时，5就为顶面**/ A[a - 1][(b + 2) % 6] = 0; A[b - 1][(a + 2) % 6] = 0; //同理5为顶面时，下一个骰子的1不能为顶面 &#125; mat C = fast_pow1(A, n - 1); //矩阵快速幂求An = X ^ (n - 1) ll sum = 0; for(int i = 0; i &lt; A.size(); i++) for(int j = 0; j &lt; A.size(); j++) sum = (sum + C[i][j]) % MOD; //求矩阵的和 sum = sum * fast_pow2(4, n) % MOD; //快速幂求sum * (4 ^ n),四个面，ｎ个骰子情况数为4 ^ n cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125; 10. 生命之树 在X森林里，上帝创建了生命之树。 他给每棵树的每个节点（叶子也称为一个节点）上，都标了一个整数，代表这个点的和谐值。上帝要在这棵树内选出一个非空节点集S，使得对于S中的任意两个点a,b，都存在一个点列 {a, v1, v2, …, vk, b} 使得这个点列中的每个点都是S里面的元素，且序列中相邻两个点间有一条边相连。 在这个前提下，上帝要使得S中的点所对应的整数的和尽量大。这个最大的和就是上帝给生命之树的评分。 经过atm的努力，他已经知道了上帝给每棵树上每个节点上的整数。但是由于 atm 不擅长计算，他不知道怎样有效的求评分。他需要你为他写一个程序来计算一棵树的分数。 「输入格式」第一行一个整数 n 表示这棵树有 n 个节点。第二行 n 个整数，依次表示每个节点的评分。接下来 n-1 行，每行 2 个整数 u, v，表示存在一条 u 到 v 的边。由于这是一棵树，所以是不存在环的。 「输出格式」输出一行一个数，表示上帝给这棵树的分数。 「样例输入」51 -2 -3 4 54 23 11 22 5 「样例输出」8 「数据范围」对于 30% 的数据，n &lt;= 10对于 100% 的数据，0 &lt; n &lt;= 10^5, 每个节点的评分的绝对值不超过 10^6 。 资源约定：峰值内存消耗 &lt; 256MCPU消耗 &lt; 3000ms 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 1e5;int N, dp[MAX][2];vector&lt;int&gt; G[MAX];void dfs(int v, int father)&#123; for(int i = 0; i &lt; G[v].size(); i++)&#123; int u = G[v][i]; if(u == father) continue; dfs(u, v); dp[v][0] = max(max(dp[u][0], dp[u][1]), dp[v][0]); if(dp[u][1] &gt; 0) dp[v][1] += dp[u][1]; &#125;&#125;int main()&#123; cin &gt;&gt; N; for(int i = 1; i &lt;= N; i++)&#123; cin &gt;&gt; dp[i][1]; dp[i][0] = -INF; &#125; for(int i = 0; i &lt; N - 1; i++)&#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[v].push_back(u); G[u].push_back(v); &#125; dfs(1, -1); cout &lt;&lt; max(dp[1][0], dp[1][1]) &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[]},{"title":"第八届蓝桥杯真题解题报告","slug":"algorithm/lqb8","date":"2019-03-19T11:18:06.553Z","updated":"2019-03-19T11:18:06.509Z","comments":true,"path":"2019/03/19/algorithm/lqb8/","link":"","permalink":"https://gydjsz.github.io/2019/03/19/algorithm/lqb8/","excerpt":"目录： 购物单 等差素数列 承压计算 方格分割 取数位 最大公共子串 日期问题 包子凑数 分巧克力 k倍区间","text":"目录： 购物单 等差素数列 承压计算 方格分割 取数位 最大公共子串 日期问题 包子凑数 分巧克力 k倍区间 1. 购物单 小明刚刚找到工作，老板人很好，只是老板夫人很爱购物。老板忙的时候经常让小明帮忙到商场代为购物。小明很厌烦，但又不好推辞。 这不，XX大促销又来了！老板夫人开出了长长的购物单，都是有打折优惠的。 小明也有个怪癖，不到万不得已，从不刷卡，直接现金搞定。 现在小明很心烦，请你帮他计算一下，需要从取款机上取多少现金，才能搞定这次购物。 取款机只能提供100元面额的纸币。小明想尽可能少取些现金，够用就行了。 你的任务是计算出，小明最少需要取多少现金。 以下是让人头疼的购物单，为了保护隐私，物品名称被隐藏了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152-----------------**** 180.90 88折**** 10.25 65折**** 56.14 9折**** 104.65 9折**** 100.30 88折**** 297.15 半价**** 26.75 65折**** 130.62 半价**** 240.28 58折**** 270.62 8折**** 115.87 88折**** 247.34 95折**** 73.21 9折**** 101.00 半价**** 79.54 半价**** 278.44 7折**** 199.26 半价**** 12.97 9折**** 166.30 78折**** 125.50 58折**** 84.98 9折**** 113.35 68折**** 166.57 半价**** 42.56 9折**** 81.90 95折**** 131.78 8折**** 255.89 78折**** 109.17 9折**** 146.69 68折**** 139.33 65折**** 141.16 78折**** 154.74 8折**** 59.42 8折**** 85.44 68折**** 293.70 88折**** 261.79 65折**** 11.30 88折**** 268.27 58折**** 128.29 88折**** 251.03 8折**** 208.39 75折**** 128.88 75折**** 62.06 9折**** 225.87 75折**** 12.89 75折**** 34.28 75折**** 62.16 58折**** 129.12 半价**** 218.37 半价**** 289.69 8折-------------------- 需要说明的是，88折指的是按标价的88%计算，而8折是按80%计算，余者类推。特别地，半价是按50%计算。请提交小明要从取款机上提取的金额，单位是元。答案是一个整数，类似4300的样子，结尾必然是00，不要填写任何多余的内容。 特别提醒：不许携带计算器入场，也不能打开手机。 解：思路：这题直接代码解决，先将数据处理一下，去除****和’折’字, 然后直接作为数据输入 Excel解决办法 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main()&#123; double value, sum = 0; int discount; while(cin &gt;&gt; value &amp;&amp; value != -1)&#123; //输入-1结束 cin &gt;&gt; discount; if(discount % 10 == 0) //如果是8折、9折就换成80、90,便于后面计算 discount *= 10; sum += value * discount / 100; //每一次折扣后的费用都加起来 &#125; int a = sum / 100; //取出整百部分 if(sum - a * 100 &gt; 0) //如果费用不是整百，那么a + 1，表示将整百部分+1, 4301=&gt;4400 cout &lt;&lt; (a + 1) * 100 &lt;&lt; endl; else cout &lt;&lt; a * 100 &lt;&lt; endl; return 0;&#125; 答案：9700 2. 等差素数列 2,3,5,7,11,13,….是素数序列。类似：7,37,67,97,127,157 这样完全由素数组成的等差数列，叫等差素数数列。上边的数列公差为30，长度为6。2004年，格林与华人陶哲轩合作证明了：存在任意长度的素数等差数列。这是数论领域一项惊人的成果！有这一理论为基础，请你借助手中的计算机，满怀信心地搜索：长度为10的等差素数列，其公差最小值是多少？注意：需要提交的是一个整数，不要填写任何多余的内容和说明文字。 解：思路：暴力枚举每一个素数，每次得到一个素数，就从1-1000循环公差, 如果在该公差下的十个数都是素数，那么最小值就是该公差 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;bool sushu(int n)&#123; //求素数 for(int i = 2; i &lt;= sqrt(n); i++)&#123; if(n % i == 0) return false; &#125; return true;&#125;int main()&#123; int a; for(int i = 2; i &lt; 100000; i++)&#123; if(sushu(i))&#123; //如果该数是素数 for(int j = 2; j &lt; 1000; j += 2)&#123; //素数的公差不可能为奇数，因为除2外的素数都是奇数，奇数+奇数=偶数 int p; for(p = 0; p &lt; 10; p++) //在公差为j的情况下，遍历后面的10个数 if(!sushu(i + j * p)) //如果某一个不是素数，则跳出循环 break; if(p == 10)&#123; //10个数为素数，输出 cout &lt;&lt; j &lt;&lt; endl; &#125; &#125; &#125; &#125; return 0;&#125; 答案：210 3. 承压计算 X星球的高科技实验室中整齐地堆放着某批珍贵金属原料。每块金属原料的外形、尺寸完全一致，但重量不同。金属材料被严格地堆放成金字塔形。123456789101112131415161718192021222324252627282930 7 5 8 7 8 8 9 2 7 2 8 1 4 9 1 8 1 8 8 4 1 7 9 6 1 4 5 4 5 6 5 5 6 9 5 6 5 5 4 7 9 3 5 5 1 7 5 7 9 7 4 7 3 3 1 4 6 4 5 5 8 8 3 2 4 3 1 1 3 3 1 6 6 5 5 4 4 2 9 9 9 2 1 9 1 9 2 9 5 7 9 4 3 3 7 7 9 3 6 1 3 8 8 3 7 3 6 8 1 5 3 9 5 8 3 8 1 8 3 3 8 3 2 3 3 5 5 8 5 4 2 8 6 7 6 9 8 1 8 1 8 4 6 2 2 1 7 9 4 2 3 3 4 2 8 4 2 2 9 9 2 8 3 4 9 6 3 9 4 6 9 7 9 7 4 9 7 6 6 2 8 9 4 1 8 1 7 2 1 6 9 2 8 6 4 2 7 9 5 4 1 2 5 1 7 3 9 8 3 3 5 2 1 6 7 9 3 2 8 9 5 5 6 6 6 2 1 8 7 9 9 6 7 1 8 8 7 5 3 6 5 4 7 3 4 6 7 8 1 3 2 7 4 2 2 6 3 5 3 4 9 2 4 5 7 6 6 3 2 7 2 4 8 5 5 4 7 4 4 5 8 3 3 8 1 8 6 3 2 1 6 2 6 4 6 3 8 2 9 6 1 2 4 1 3 3 5 3 4 9 6 3 8 6 5 9 1 5 3 2 6 8 8 5 3 2 2 7 9 3 3 2 8 6 9 8 4 4 9 5 8 2 6 3 4 8 4 9 3 8 8 7 7 7 9 7 5 2 7 9 2 5 1 9 2 6 5 3 9 3 5 7 3 5 4 2 8 9 7 7 6 6 8 7 5 5 8 2 4 7 7 4 7 2 6 9 2 1 8 2 9 8 5 7 3 6 5 9 4 5 5 7 5 5 6 3 5 3 9 5 8 9 5 4 1 2 6 1 4 3 5 3 2 4 1 X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X 其中的数字代表金属块的重量（计量单位较大）。最下一层的X代表30台极高精度的电子秤。 假设每块原料的重量都十分精确地平均落在下方的两个金属块上，最后，所有的金属块的重量都严格精确地平分落在最底层的电子秤上。电子秤的计量单位很小，所以显示的数字很大。工作人员发现，其中读数最小的电子秤的示数为：2086458231请你推算出：读数最大的电子秤的示数为多少？注意：需要提交的是一个整数，不要填写任何多余的内容。 解：思路：上面一个数字平均分到它下面的两个数字上，直接用二维数组存下所有数字，然后每一行的数字等于当前的数字加上它上面两个数字的一半例如：123 1 1 2 3 =&gt; 2 3 4 5 6 4 5 6 当上面的重量落下来的时候，第二行的2就变为2 + 1 / 2 = 2.5, 第三行的4就变为4 + 2.5 / 2一直算到最后一行，取出最大和最小的两个数，那么读数最大的示数应为MAX * 2086458231 / MIN 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; double a[31][31]; memset(a, 0, sizeof(a)); for(int i = 1; i &lt;= 29; i++) for(int j = 1;j &lt;= i; j++) cin &gt;&gt; a[i][j]; for(int i = 2; i &lt;= 29; i++) for(int j = 1; j &lt;= 29; j++)&#123; a[i][j] += a[i - 1][j - 1] / 2 + a[i - 1][j] / 2; //下面一个数=正上的左边一个数/2+正上面的数/2 &#125; double MIN = 9999999, MAX = 0; for(int i = 1; i &lt;= 30; i++)&#123; a[30][i] = a[29][i - 1] / 2 + a[29][i] / 2; //求出第30行的X的数字 MIN = min(MIN, a[30][i]); //求出最小值 MAX = max(MAX, a[30][i]); //求出最大值 &#125; cout &lt;&lt; fixed &lt;&lt; MAX * 2086458231 / MIN &lt;&lt; endl; //fixed格式化输出，使其以小数形式输出 return 0;&#125; 答案：72665192664 4. 方格分割 6x6的方格，沿着格子的边线剪开成两部分。要求这两部分的形状完全相同。 如图： 就是可行的分割法。 试计算：包括这3种分法在内，一共有多少种不同的分割方法。注意：旋转对称的属于同一种分割法。 请提交该整数，不要填写任何多余的内容或说明文字。 解：思路：由于剪开的两部分要完全相同，此时其一定关于中心对称，我们可以从(3, 3)开始出发，进行dfs遍历，由于dfs是连续找点的，所以找的格子一定是连在一起的，这就保证了可以分成两部分，在dfs遍历的时候同时对其对称的点作标记，这样旋转之后两部分就完全相同，因为旋转对称属于同一种，最终除以4，就是结果。 dfs讲解：https://www.cnblogs.com/OctoptusLian/p/7429645.html 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 6;int ans = 0; //存储方式int map[N + 1][N + 1]; //存储走过的格子int d[4][2] = &#123; //定义行走方式 0, 1, 1, 0, 0, -1, -1, 0 &#125;;int dfs(int x, int y)&#123; if(x == 0 || y == 0 || x == N || y == N)&#123; //到达边界返回 ans++; return 0; &#125; for(int i = 0; i &lt; 4; i++)&#123; int tx = x + d[i][0]; int ty = y + d[i][1]; if(map[tx][ty]) continue; //如果已经走过，那么换一条路 map[tx][ty] = 1; //没走过，标记1 map[N - tx][N - ty] = 1; //对称的格子标记1 dfs(tx, ty); //dfs继续遍历 map[tx][ty] = 0; //对路径进行还原 map[N - tx][N - ty] = 0; &#125;&#125;int main()&#123; map[N / 2][N / 2] = 1; //先从(3, 3)点开始走，先标记为1 dfs(N / 2, N / 2); cout &lt;&lt; ans / 4 &lt;&lt; endl; //除以重复的情况 return 0;&#125; 5. 取数位 求1个整数的第k位数字有很多种方法。以下的方法就是一种。 123456789101112131415161718// 求x用10进制表示时的数位长度 int len(int x)&#123; if(x&lt;10) return 1; return len(x/10)+1;&#125; // 取x的第k位数字int f(int x, int k)&#123; if(len(x)-k==0) return x%10; return _____________________; //填空&#125; int main()&#123; int x = 23574; printf(&quot;%d\\n&quot;, f(x,3)); return 0;&#125; 对于题目中的测试数据，应该打印5。请仔细分析源码，并补充划线部分所缺少的代码。注意：只提交缺失的代码，不要填写任何已有内容或说明性的文字。 解：思路：观察代码，len()函数明显是求x的长度，题目中23574的长度为5，f()函数就是求第k位数字，第一个if就是当x的长度和k相等时，返回x % 10, 如果x = 574, k = 3, 那么第k为数字就为x % 10 = 4，这里不满足if的话，就直接return了，可以看出，这是一个递归函数，将x的长度不断减小，最终只剩下k位，最终取模即可，空格处应该填f(x / 10, k) 答案：f(x / 10, k) 6. 最大公共子串 最大公共子串长度问题就是：求两个串的所有子串中能够匹配上的最大长度是多少。比如：”abcdkkk” 和 “baabcdadabc”，可以找到的最长的公共子串是”abcd”,所以最大公共子串长度为4。下面的程序是采用矩阵法进行求解的，这对串的规模不大的情况还是比较有效的解法。请分析该解法的思路，并补全划线部分缺失的代码。 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define N 256int f(const char* s1, const char* s2)&#123; int a[N][N]; int len1 = strlen(s1); int len2 = strlen(s2); int i,j; memset(a,0,sizeof(int)*N*N); int max = 0; for(i=1; i&lt;=len1; i++)&#123; for(j=1; j&lt;=len2; j++)&#123; if(s1[i-1]==s2[j-1]) &#123; a[i][j] = __________________________; //填空 if(a[i][j] &gt; max) max = a[i][j]; &#125; &#125; &#125; return max;&#125;int main()&#123; printf(\"%d\\n\", f(\"abcdkkk\", \"baabcdadabc\")); return 0;&#125; 注意：只提交缺少的代码，不要提交已有的代码和符号。也不要提交说明性文字。 解：思路：观察代码，两个循环+一个if，循环将s1中的每一个字母和s2中的每一个字母进行比较，s1中的第i个字符和s2中的字符相等，那么就将当前的这一次相等+它前面字符相等个数，由于每行都存储的是相等的字符个数，那么 它前面字符相等个数=a[i - 1][j - 1]1234567891011a b c d k k kb a a b c d a d a b c第一次比较a：0 1 1 0 0 0 1 0 1 0 0第二次比较b：1 1 1 2 0 0 1 0 1 2 0第三次比较c：1 1 1 2 3 0 1 0 1 2 3第三次比较d：1 1 1 2 3 4 1 1 1 2 3然后比较k... 答案：a[i][j] + a[i - 1][j - 1] + 1 7. 日期问题 小明正在整理一批历史文献。这些历史文献中出现了很多日期。小明知道这些日期都在1960年1月1日至2059年12月31日。令小明头疼的是，这些日期采用的格式非常不统一，有采用年/月/日的，有采用月/日/年的，还有采用日/月/年的。更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。 比如02/03/04，可能是2002年03月04日、2004年02月03日或2004年03月02日。 给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？ 输入一个日期，格式是”AA/BB/CC”。 (0 &lt;= A, B, C &lt;= 9) 输入输出若干个不相同的日期，每个日期一行，格式是”yyyy-MM-dd”。多个日期按从早到晚排列。 样例输入02/03/04 样例输出2002-03-042004-02-032004-03-02 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 解：思路：首先将输入的字符串转化为年月日的数字，然后用数组存储下题意中的三种排列，对每个情况进行判断，首先年份要在1960 ~ 2059之间，月份在1 ~ 12之间，天数在1 ~ 31之间，注意闰年的2月是29天，4,6,9,11是30天，输出的时候注意前导0，比如2要输出02，这里需要注意去重的问题，如果是输入02/02/02，那么输出为2002-02-02，但是这个情况对于三种排列都满足 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;using namespace std;struct Day&#123; int year; int month; int day;&#125;;bool judge(int year, int month, int day)&#123; if(year &lt; 1960 || year &gt; 2059 || month &gt;= 13 || day &gt; 31) return false; if(year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0)&#123; //闰年的情况 if(month == 2 &amp;&amp; day &gt; 29) return false; &#125; switch(month)&#123; //对于每一个月，天数不同的情况 case 2: if(day &gt; 28) return false; case 4: case 6: case 9: case 11: if(day &gt; 30) return false; &#125; return true;&#125;bool cmp(Day a, Day b)&#123; if(a.year == b.year)&#123; //年份相等,则比较月份 if(a.month == b.month) //月份相等，则比较天数 return a.day &lt; b.day; return a.month &lt; b.month; &#125; return a.year &lt; b.year;&#125;int main()&#123; string s; cin &gt;&gt; s; //提取出每个部分的数字 int a = (s[0] - '0') * 10 + (s[1] - '0'); int b = (s[3] - '0') * 10 + (s[4] - '0'); int c = (s[6] - '0') * 10 + (s[7] - '0'); int m[][3] = &#123; a, b, c, c, a, b, c, b, a&#125;; //将三种情况存储在数组中 Day d[100]; int k = 0; for(int i = 0; i &lt; 3; i++)&#123; int year = 1900 + m[i][0]; //年份有19和20两种 int month = m[i][1]; int day = m[i][2]; if(judge(year, month, day))&#123; //如果满足，则加入进来 d[k].year = year; d[k].month = month; d[k].day = day; k++; &#125; year = 2000 + m[i][0]; if(judge(year, month, day))&#123; d[k].year = year; d[k].month = month; d[k].day = day; k++; &#125; &#125; sort(d, d + k, cmp); //对日期进行排序 for(int i = 0; i &lt; k; i++)&#123; //去除和前一个日期重复的 if(i != 0 &amp;&amp; d[i].year == d[i - 1].year &amp;&amp; d[i].month == d[i - 1].month &amp;&amp; d[i].day == d[i - 1].day) continue; cout &lt;&lt; d[i].year &lt;&lt; \"-\"; cout &lt;&lt; setw(2) &lt;&lt; setfill('0') &lt;&lt; d[i].month &lt;&lt; \"-\"; cout &lt;&lt; setw(2) &lt;&lt; setfill('0') &lt;&lt; d[i].day &lt;&lt; endl; &#125; return 0;&#125; 8. 包子凑数 小明几乎每天早晨都会在一家包子铺吃早餐。他发现这家包子铺有N种蒸笼，其中第i种蒸笼恰好能放Ai个包子。每种蒸笼都有非常多笼，可以认为是无限笼。 每当有顾客想买X个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有X个包子。比如一共有3种蒸笼，分别能放3、4和5个包子。当顾客想买11个包子时，大叔就会选2笼3个的再加1笼5个的（也可能选出1笼3个的再加2笼4个的）。 当然有时包子大叔无论如何也凑不出顾客想买的数量。比如一共有3种蒸笼，分别能放4、5和6个包子。而顾客想买7个包子时，大叔就凑不出来了。 小明想知道一共有多少种数目是包子大叔凑不出来的。 输入第一行包含一个整数N。(1 &lt;= N &lt;= 100)以下N行每行包含一个整数Ai。(1 &lt;= Ai &lt;= 100) 输出一个整数代表答案。如果凑不出的数目有无限多个，输出INF。 例如，输入：245 程序应该输出：6 再例如，输入：246 程序应该输出：INF 样例解释：对于样例1，凑不出的数目包括：1, 2, 3, 6, 7, 11。对于样例2，所有奇数都凑不出来，所以有无限多个。 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 解：思路：由裴蜀定理知：a x + b y = gcd(a, b), 令c = gcd(a, b), 则a x + b y = c, 说明如果想让ａ和ｂ来表示ｃ，那么ｃ一定为ａ和ｂ的最大公约数的倍数。这样就有一个结论：如果数据中含有两个数的最大公约数为１，那么就可以表示１的倍数，除了前面凑不出来的数有两个数４,６, 最大公约数为２, 只能表示２的倍数的数字,不能表示奇数首先标记能表示的数，然后遍历没有被标记的，就是不能表示的数 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 10001;int gcd(int a, int b)&#123; return b == 0 ? a : gcd(b, a % b);&#125;int main()&#123; int n; cin &gt;&gt; n; int a[N]; int b[N]; memset(b, 0, sizeof(b)); for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; a[i]; &#125; int g = a[0]; for(int i = 0; i &lt; n; i++) g = gcd(g, a[i]); //如果有两个数a, b，gcd(a, b) = 1, 则g = 1, 那么gcd(g, x) = 1; if(g != 1)&#123; //如果最大公约数没有为１的，那么就有无限个数凑不出来 cout &lt;&lt; \"INF\" &lt;&lt; endl; return 0; &#125; else&#123; b[0] = 1; //0个包子，就取0笼 for(int i = 0; i &lt; n; i++) for(int j = 0; j + a[i] &lt; N; j++) if(b[j]) //如果数字为ｊ的能凑，那么j + a[i]也能凑，即在ｊ的基础上+a[i] b[j + a[i]] = 1; &#125; int sum = 0; for(int i = 0; i &lt; N; i++) //遍历Ｎ，看那些没有标记 if(!b[i]) sum++; cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125; 9. 分巧克力 儿童节那天有K位小朋友到小明家做客。小明拿出了珍藏的巧克力招待小朋友们。小明一共有N块巧克力，其中第i块是Hi x Wi的方格组成的长方形。 为了公平起见，小明需要从这 N 块巧克力中切出K块巧克力分给小朋友们。切出的巧克力需要满足： 1.形状是正方形，边长是整数2.大小相同 例如一块6x5的巧克力可以切出6块2x2的巧克力或者2块3x3的巧克力。 当然小朋友们都希望得到的巧克力尽可能大，你能帮小Hi计算出最大的边长是多少么？ 输入第一行包含两个整数N和K。(1 &lt;= N, K &lt;= 100000)以下N行每行包含两个整数Hi和Wi。(1 &lt;= Hi, Wi &lt;= 100000)输入保证每位小朋友至少能获得一块1x1的巧克力。 输出输出切出的正方形巧克力最大可能的边长。 样例输入：2 106 55 6 样例输出：2 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 解：思路：这题采用二分法，首先找到最大的边长，作为二分操作中的right，对边长进行二分操作，即mid = (left + right) / 2，如果mid长度满足题意，那么继续增大mid，也就是让left = mid + 1.如何判断mid长度是否满足题意呢，循环遍历巧克力的边长，h / mid, w / mid 得到有多少mid长度的边，两者的乘积就是边长为mid的正方形的个数例如：1234 __ __ __| | 边长为3*3的矩形,假如mid = 2, 那么(3 / 2) * (3 / 2) = 1,可以形成一个2*2的正方形| | 相当于在ｈ上有n = h / mid 个mid, ｗ上有m = w / mid个mid, 总共有n * m 个 mid*mid|__ __ __| 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;int n, k;int h[100000], w[100000];bool fun(int b)&#123; int sum = 0; for(int i = 0; i &lt; n; i++)&#123; sum += (h[i] / b) * (w[i] / b); //求出满足边长为mid的正方形的个数 if(sum &gt;= k) //如果已经达到ｋ个了，就返回 return true; &#125; return false;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; k; int left = 0, right = 0; for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; h[i] &gt;&gt; w[i]; right = max(right, h[i]); //找出最大的那个边长 right = max(right, w[i]); &#125; while(left &lt; right)&#123; int mid = (left + right) / 2; //不断二分边长，直到left &lt; right if(fun(mid)) left = mid + 1; else right = mid - 1; &#125; cout &lt;&lt; left &lt;&lt; endl; //输出边长 return 0;&#125; 10. k倍区间 给定一个长度为N的数列，A1, A2, … AN，如果其中一段连续的子序列Ai, Ai+1, … Aj(i &lt;= j)之和是K的倍数，我们就称这个区间[i, j]是K倍区间。 你能求出数列中总共有多少个K倍区间吗？ 输入第一行包含两个整数N和K。(1 &lt;= N, K &lt;= 100000)以下N行每行包含一个整数Ai。(1 &lt;= Ai &lt;= 100000) 输出输出一个整数，代表K倍区间的数目。 例如，输入：5 212345 程序应该输出：6 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 2000ms 解：思路：首先对数组进行前缀和a[i] + a[i - 1], 那么区间[l, r]的和为a[r] - a[l - 1], 如果(a[r] - a[l - 1]) % k == 0, 那么这个区间就是一个ｋ倍区间(a[r] - a[l - 1]) % k == 0=&gt; a[r] % k == a[l - 1] % k可以看出如果区间两端点对ｋ的模相等，那么这个区间就是一个ｋ倍区间。我们可以在求前缀和的同时直接将这个对ｋ取模之后的数求出来，即a[r] % k, 只要有一个相等的情况我们就存储起来，这个数组记做b[],b数组的下标存储的就是a[r] % k, 对于进行了前缀和取模后的数组a, 只要将里面模数相等的个数全部存储在b数组中，那么对里面的端点进行两两组合，那么就可以得出这个区间[l, r], 组合数为C(n, 2) = n * (n - 1) / 2, 对于a[r] % k刚好为０的情况，只需要这一个端点就满足条件，所以要加上模数为０的总数 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll; //定义long long 避免爆数据int main()&#123; int n, k; cin &gt;&gt; n &gt;&gt; k; ll a[100001], b[100001]; memset(a, 0, sizeof(a)); //初始化数组为０ memset(b, 0, sizeof(b)); for(int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; a[i]; a[i] = (a[i] + a[i - 1]) % k; //a[i] + a[i - 1]为前缀和，这里同时取模，即a[r] % k b[a[i]]++; //a[r] % k的个数，满足a[r] % k == a[l - 1] % k的区间[l, r]为k倍区间 &#125; ll sum = 0; for(int i = 0; i &lt; k; i++)&#123; if(b[i])&#123; //如果含有点 sum += b[i] * (b[i] - 1) / 2; //组合求个数, 每两个点可以组成一个区间 &#125; &#125; sum += b[0]; //如果模数为0, 表明区间为[0, r], 加上本身的情况 cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[]},{"title":"第七届蓝桥杯真题解题报告","slug":"algorithm/lqb7","date":"2019-03-18T13:31:16.300Z","updated":"2019-03-18T13:31:16.268Z","comments":true,"path":"2019/03/18/algorithm/lqb7/","link":"","permalink":"https://gydjsz.github.io/2019/03/18/algorithm/lqb7/","excerpt":"目录： 煤球数目 生日蜡烛 凑算式 快速排序 抽签 方格填数 剪邮票 四平方和 交换瓶子 最大比例","text":"目录： 煤球数目 生日蜡烛 凑算式 快速排序 抽签 方格填数 剪邮票 四平方和 交换瓶子 最大比例 1. 煤球数目 有一堆煤球，堆成三角棱锥形。具体：第一层放1个，第二层3个（排列成三角形），第三层6个（排列成三角形），第四层10个（排列成三角形），….如果一共有100层，共有多少个煤球？ 请填表示煤球总数目的数字。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。 解：思路：3 - 1 = 26 - 3 = 310 - 6 = 4通过观察可以写出该数列的递推公式: an - an-1 = n, 对an累加求和即可 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 0, s = 0; for(int i = 1; i &lt;= 100; i++)&#123; //递推计算数列 a += i; //求an s += a; //累加ai &#125; cout &lt;&lt; s &lt;&lt; endl; return 0;&#125; 答案：171700 2. 生日蜡烛 某君从某年开始每年都举办一次生日party，并且每次都要吹熄与年龄相同根数的蜡烛。现在算起来，他一共吹熄了236根蜡烛。请问，他从多少岁开始过生日party的？请填写他开始过生日party的年龄数。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。 解：思路：因为蜡烛数目和年龄数对应，而年龄是一个等差数列，其前n项和为Sn = n * (n + 1) / 2设他从n年开始举办生日，现在已经m年了，则Sm - Sn + an= 236, (这里+an，是因为会减去开始的那一年的蜡烛数，比如从1开始举办生日，举办了3年，就是Sm = 1+2+3 = 6, Sn = 1, Sm - Sn = 5, (实际应该是6才对).m (m + 1) / 2 - n (n + 1) / 2 + n = 236=&gt; (m + n)(m - n + 1) = 472472因式分解：2, 2, 2, 59得出m - n + 1只能是2 2 2 = 8, (m + n)只能是59m - n + 1 = 8m + n = 59 联立求得方程组的解为m = 33, n = 26 程序解决：1234567891011121314151617#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; int sum; for(int i = 1; i &lt;= 150; i++)&#123; sum = 0; for(int j = i; j &lt;= 150; j++)&#123; sum += j; if(sum == 236)&#123; cout &lt;&lt; i &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; 答案：26 3. 凑算式 123 B DEFA + --- + ------- = 10 C GHI 这个算式中A ~ I代表1 ~ 9的数字，不同的字母代表不同的数字。 比如：6+8/3+952/714 就是一种解法，5+3/1+972/486 是另一种解法。 这个算式一共有多少种解法？ 注意：你提交应该是个整数，不要填写任何多余的内容或说明性文字。 解：思路：生成1-9的全排列，然后暴力尝试即可，这里可以将除法转化为乘法，避免小数的情况，转化后为A C GHI + B GHI + C DEF = 10 C GHI 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int a[10]; for(int i = 1; i &lt;= 9; i++)&#123; a[i] = i; &#125; int sum = 0; do&#123; int A = a[1], B = a[2], C = a[3], D = a[4], E = a[5], F = a[6], G = a[7], H = a[8], I = a[9]; int GHI = G * 100 + H * 10 + I; int DEF = D * 100 + E * 10 + F; if(A * C * GHI + B * GHI + C * DEF == 10 * C * GHI)&#123; sum++; &#125; &#125;while(next_permutation(a + 1, a + 10)); //全排列函数从生成数组a中[1, 10)的排列 cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125; 答案：29 4. 快速排序 排序在各种场合经常被用到。快速排序是十分常用的高效率的算法。其思想是：先选一个“标尺”，用它把整个队列过一遍筛子，以保证：其左边的元素都不大于它，其右边的元素都不小于它。这样，排序问题就被分割为两个子区间。再分别对子区间排序就可以了。下面的代码是一种实现，请分析并填写划线部分缺少的代码。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;void swap(int a[], int i, int j) &#123; int t = a[i]; a[i] = a[j]; a[j] = t;&#125;int partition(int a[], int p, int r) &#123; int i = p; int j = r + 1; int x = a[p]; while(1)&#123; while(i&lt;r &amp;&amp; a[++i]&lt;x); while(a[--j]&gt;x); if(i&gt;=j) break; swap(a,i,j); &#125; ______________________; return j;&#125;void quicksort(int a[], int p, int r) &#123; if(p&lt;r)&#123; int q = partition(a,p,r); quicksort(a,p,q-1); quicksort(a,q+1,r); &#125;&#125;int main() &#123; int i; int a[] = &#123;5,13,6,24,2,8,19,27,6,12,1,17&#125;; int N = 12; quicksort(a, 0, N-1); for(i=0; i&lt;N; i++) printf(\"%d \", a[i]); printf(\"\\n\"); return 0;&#125; 注意：只填写缺少的内容，不要书写任何题面已有代码或说明性文字。 解:思路：首先了解程序中的快速排序，采用分治的思想，将数据以第一个数为基准分成两部分,例子:12345678910111213141516171819202122231. 初始：6 1 2 7 9 3 4 10 8 key = 66 1 2 7 9 3 4 10 8i j2. i从左边开始向右移动，遇到第一个比key大的数，停止(while(i &lt; r &amp;&amp; a[++i] &lt; x))，j从最右边开始向左移动,遇到第一个比key小的数，停止(while(a[--j] &gt; x))6 1 2 7 9 3 4 10 8 i j3. 交换i和j的位置,即代码中的swap()6 1 2 4 9 3 7 10 8 i j4. 重复2操作6 1 2 4 9 3 7 10 8 i j5. 重复4操作6 1 2 4 3 9 7 10 8 i j6. 重复2操作6 1 2 4 3 9 7 10 8 j i 7. i &gt; j, 跳出循环, 此时由于j在i的左边，所以a[j] &lt; a[i] 并且a[j] &lt; a[0], 否则i不会到j的右边,swap(a, p, j)操作，将6和3交换位置, 就完成了一次快速排序, 这里的p是传入的数据的最左边位置，也就是样例数据的a[0] 答案：swap(a, p, j) 5. 抽签 X星球要派出一个5人组成的观察团前往W星。其中：A国最多可以派出4人。B国最多可以派出2人。C国最多可以派出2人。….那么最终派往W星的观察团会有多少种国别的不同组合呢？下面的程序解决了这个问题。数组a[] 中既是每个国家可以派出的最多的名额。程序执行结果为：DEFFFCEFFFCDFFFCDEFFCCFFFCCEFFCCDFFCCDEFBEFFFBDFFFBDEFFBCFFFBCEFFBCDFFBCDEF….(以下省略，总共101行) 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#define N 6#define M 5#define BUF 1024void f(int a[], int k, int m, char b[]) &#123; int i,j; if(k==N)&#123; b[M] = 0; if(m==0) printf(\"%s\\n\",b); return; &#125; for(i=0; i&lt;=a[k]; i++)&#123; for(j=0; j&lt;i; j++) b[M-m+j] = k+'A'; ______________________; //填空位置 &#125;&#125;int main() &#123; int a[N] = &#123;4,2,2,1,1,3&#125;; char b[BUF]; f(a,0,M,b); return 0;&#125; 仔细阅读代码，填写划线部分缺少的内容。注意：不要填写任何已有内容或说明性文字。 解：思路：a数组表示各国能派出的人数，b数组表示派出的组合，在f()函数中，第一个循环是遍历各国，第二个循环是各国派出的人数，这里明显是一个递归方程，k应该不断增加1，才能遍历完每一个国家，由于b中存储各国的人员，所以循环j次，就代表派出了j个人，m - j就表示还需要派出多少人，观察if内部程序，当k == N时表示对国家选择完，然后再看各国派出的人数是否达到了人，，当m == 0时，表示一种情况生成完毕，输出b数组 答案：f(a, k + 1, m - j, b) 6. 方格填数 如下的10个格子1234567 +--+--+--+ | | | |+--+--+--+--+| | | | |+--+--+--+--+| | | |+--+--+--+ 填入0~9的数字。要求：连续的两个数字不能相邻。（左右、上下、对角都算相邻）一共有多少种可能的填数方案？请填写表示方案数目的整数。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。 解：思路：这题直接暴力求解，全排列所有情况，然后一个个试就完事，判断每一个格子与周围格子的绝对值之差是否为1，如果为1就返回false, 否则返回true，每次以当前格子为基础，向四周比较，比较完就把当前格子划掉就不会漏掉。 1234567 +--+--+--+ +--+--+--+ |a |b |c | | |b |c | +--+--+--+--+ 比较完a =&gt; +--+--+--+--+, |d |e |f |g | |d |e |f |g |+--+--+--+--+ +--+--+--+--+|h |i |j | |h |i |j |+--+--+--+ +--+--+--+ 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;bool can(int a, int b)&#123; return abs(a - b) == 1 ? false : true; //判断格子是否相邻&#125;int main()&#123; int array[10]; for(int i = 0; i &lt;= 9; i++) //初始化数组array array[i] = i; int sum = 0; do&#123; int a = array[0], b = array[1], c = array[2], d = array[3], e = array[4], f = array[5], g = array[6], h = array[7], i = array[8], j = array[9]; //一个个比较 if(can(a, b) &amp;&amp; can(a, d) &amp;&amp; can(a, e) &amp;&amp; can(a, f) &amp;&amp; can(b, e) &amp;&amp; can(b, f) &amp;&amp; can(b, c) &amp;&amp; can(b, g) &amp;&amp; can(c, f) &amp;&amp; can(c, g) &amp;&amp; can(d, h) &amp;&amp; can(d, e) &amp;&amp; can(d, i) &amp;&amp; can(e, i) &amp;&amp; can(e, h) &amp;&amp; can(e, f) &amp;&amp; can(e, j) &amp;&amp; can(f, i) &amp;&amp; can(f, j) &amp;&amp; can(f, g) &amp;&amp; can(g, j) &amp;&amp; can(h, i) &amp;&amp; can(i, j)) sum++; &#125;while(next_permutation(array, array + 10)); //生成全排列 cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125; 答案：1508 7. 剪邮票 如, 有12张连在一起的12生肖的邮票。现在你要从中剪下5张来，要求必须是连着的。（仅仅连接一个角不算相连）比如，，中，粉红色所示部分就是合格的剪取。请你计算，一共有多少种不同的剪取方法。请填写表示方案数目的整数。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。 解：思路：将邮票的标号改为1, 2, 3, 4, 6, 7, 8, 9, 11, 12, 13, 14, 这样上下相差5，左右相差1，下左边界和上右边界的数就相差2，便于判断，暴力循环求所有情况生成的数组c，dfs搜索c判断邮票是否连接，标号+{-1, 1, -5, 5}表示上下左右移动，已知c数组的第一个数如果该数经过移动操作能和c中第二个数相等，那么表示两个邮票连接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int visit[5];int a[] = &#123;1, 2, 3, 4, 6, 7, 8, 9, 11, 12, 13, 14&#125;; int b[] = &#123;-1, 1, -5, 5&#125;;int c[5];void dfs(int n)&#123; for(int i = 0; i &lt; 4; i++) &#123; int t = c[n] + b[i]; if(t &lt; 1 || t &gt; 14 || t == 5 || t == 10) continue; for(int j = 0; j &lt; 5; j++) if(!visit[j] &amp;&amp; c[j] == t) &#123; visit[j] = 1; dfs(j); &#125; &#125;&#125;int main()&#123; int sum = 0; for(int i = 1; i &lt;= 14; i++) for(int j = i + 1; j &lt;= 14; j++) for(int k = j + 1; k &lt;= 14; k++) for(int p = k + 1; p &lt;= 14; p++) for(int q = p + 1; q &lt;= 14; q++) &#123; c[0] = a[i]; c[1] = a[j]; c[2] = a[k]; c[3] = a[p]; c[4] = a[q]; memset(visit, 0, sizeof(visit)); visit[0] = 1; dfs(0); int flag = 0; for(int i = 0; i &lt; 5; i++)&#123; if(visit[i] == 1)&#123; flag++; &#125; &#125; if(flag == 5) sum++; &#125; cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125; 答案：116 8. 四平方和 四平方和定理，又称为拉格朗日定理：每个正整数都可以表示为至多4个正整数的平方和。如果把0包括进去，就正好可以表示为4个数的平方和。比如：5 = 0^2 + 0^2 + 1^2 + 2^27 = 1^2 + 1^2 + 1^2 + 2^2（^符号表示乘方的意思）对于一个给定的正整数，可能存在多种平方和的表示法。 要求你对4个数排序：0 &lt;= a &lt;= b &lt;= c &lt;= d并对所有的可能表示法按 a,b,c,d 为联合主键升序排列，最后输出第一个表示法 程序输入为一个正整数N (N&lt;5000000) 要求输出4个非负整数，按从小到大排序，中间用空格分开例如，输入：5则程序应该输出：0 0 1 2 再例如，输入：12则程序应该输出：0 2 2 2 再例如，输入：773535则程序应该输出：1 1 267 838 资源约定：峰值内存消耗 &lt; 256MCPU消耗 &lt; 3000ms 解：思路：暴力枚举，附加一些条件即可。每一层循环的终点就是剩余的值，比如第一层循环i, 终点为sqrt(n)，需要遍历0 ~ sqrt(n), 第二层循环ｊ，终点为sqrt(n - i i), 因为已经有一个i值，不需要从0 ~ sqrt(n)，第三层循环就为0 ~ sqrt(n - i i - j * j)，第四层就不需要循环了，因为，虽然有四个未知数,，但只要知道其中三个，另一个就可以直接求出来，只需要判断第四个数的开方是否为整数就行了 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt;= sqrt(n); i++)&#123; for(int j = 0; j &lt;= sqrt(n - i * i); j++) for(int k = 0; k &lt;= sqrt(n - i * i - j * j); k++)&#123; double s = 1.0 * sqrt(n - i * i - j * j - k * k); if(s == (int)s)&#123; cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j &lt;&lt; \" \" &lt;&lt; k &lt;&lt; \" \" &lt;&lt; s &lt;&lt; endl; return 0; &#125; &#125; &#125; return 0;&#125; 9. 交换瓶子 有N个瓶子，编号 1 ~ N，放在架子上。比如有5个瓶子：2 1 3 5 4要求每次拿起2个瓶子，交换它们的位置。经过若干次后，使得瓶子的序号为：1 2 3 4 5对于这么简单的情况，显然，至少需要交换2次就可以复位。如果瓶子更多呢？你可以通过编程来解决。 输入格式为两行：第一行: 一个正整数N（N&lt;10000）, 表示瓶子的数目第二行：N个正整数，用空格分开，表示瓶子目前的排列情况。输出数据为一行一个正整数，表示至少交换多少次，才能完成排序。 例如，输入：53 1 2 5 4程序应该输出：3 再例如，输入：55 4 3 2 1程序应该输出：2 资源约定：峰值内存消耗 &lt; 256MCPU消耗 &lt; 1000ms 解：思路：求最少交换次数，那么每次交换的结果必须是最终的位置，那么只需要通过选择排序，每次都从后面挑选出最小的数换到前面它所在的位置就行了. 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; int a[n]; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; int min, flag = 0; int sum = 0; for(int i = 0; i &lt; n; i++)&#123; min = a[i]; flag = i; for(int j = i; j &lt; n; j++) if(min &gt; a[j])&#123; min = a[j]; flag = j; &#125; if(flag != i)&#123; sum++; a[flag] = a[i]; a[i] = min; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125; 10. 最大比例 X星球的某个大奖赛设了M级奖励。每个级别的奖金是一个正整数。并且，相邻的两个级别间的比例是个固定值。也就是说：所有级别的奖金数构成了一个等比数列。比如：16,24,36,54其等比值为：3/2现在，我们随机调查了一些获奖者的奖金数。请你据此推算可能的最大的等比值。 输入格式：第一行为数字 N (0&lt; N &lt;100)，表示接下的一行包含N个正整数第二行N个正整数Xi(Xi&lt;1 000 000 000 000)，用空格分开。每个整数表示调查到的某人的奖金数额 要求输出：一个形如A/B的分数，要求A、B互质。表示可能的最大比例系数测试数据保证了输入格式正确，并且最大比例是存在的。 例如，输入：31250 200 32 程序应该输出：25/4 再例如，输入：43125 32 32 200程序应该输出：5/2 再例如，输入：3549755813888 524288 2程序应该输出：4/1 资源约定：峰值内存消耗 &lt; 256MCPU消耗 &lt; 3000ms 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;struct Node&#123; ll p; ll q;&#125;;ll gcd(ll a, ll b)&#123; return b == 0 ? a : gcd(b, a % b);&#125;int main()&#123; ll n; cin &gt;&gt; n; ll a[n]; Node b[n]; for(ll i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; sort(a, a + n); //对a数组排序 ll size = 0; for(ll i = 1; i &lt; n; i++)&#123; //剔除重复的元素 if(a[size] != a[i])&#123; a[++size] = a[i]; &#125; &#125; if(a[0] == a[size]) //如果最终只有一个元素,那么直接输出 cout &lt;&lt; 1 &lt;&lt; \"/\" &lt;&lt; 1 &lt;&lt; endl; else&#123; for(ll i = 1; i &lt;= size; i++)&#123; //求出比值的分子分母 ll g = gcd(a[i], a[i - 1]); b[i - 1].p = a[i] / g; b[i - 1].q = a[i - 1] / g; &#125; ll pq1, pq2; ll A, B; double t = 999999999, t1; for(ll i = 0; i &lt; size; i++) //求出最小的比例系数 for(ll j = i; j &lt; size; j++)&#123; if(b[i].p * b[j].q &gt; b[i].q * b[j].p)&#123; pq1 = b[i].p * b[j].q; pq2 = b[i].q * b[j].p; t1 = pq1 / pq2; &#125; else if(b[i].p * b[j].q &lt; b[i].q * b[j].p)&#123; pq1 = b[i].q * b[j].p; pq2 = b[i].p * b[j].q; t1 = pq1 / pq2; &#125; else&#123; pq1 = b[i].p; pq2 = b[i].q; t1 = pq1 / pq2; &#125; if(t1 &lt; t)&#123; t = t1; A = pq1; B = pq2; &#125; &#125; ll g = gcd(A, B); //对系数进行化简 cout &lt;&lt; A / g &lt;&lt; \"/\" &lt;&lt; B / g &lt;&lt; endl; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"牛客练习赛34的C、D题题解","slug":"algorithm/nowcoderPractice34","date":"2019-03-18T13:03:02.799Z","updated":"2019-03-18T13:03:02.759Z","comments":true,"path":"2019/03/18/algorithm/nowcoderPractice34/","link":"","permalink":"https://gydjsz.github.io/2019/03/18/algorithm/nowcoderPractice34/","excerpt":"学到了前缀和,开心","text":"学到了前缀和,开心 C题123456789101112131415161718192021222324252627题目描述 小w有m条线段，编号为1到m。用这些线段覆盖数轴上的n个点，编号为1到n。第i条线段覆盖数轴上的区间是L[i]，R[i]。覆盖的区间可能会有重叠，而且不保证m条线段一定能覆盖所有n个点。现在小w不小心丢失了一条线段，请问丢失哪条线段，使数轴上没被覆盖到的点的个数尽可能少，请输出丢失的线段的编号和没被覆盖到的点的个数。如果有多条线段符合要求，请输出编号最大线段的编号（编号为1到m）。输入描述:第一行包括两个正整数n，m(1≤n，m≤10^5)。接下来m行，每行包括两个正整数L[i]，R[i](1≤L[i]≤R[i]≤n)。输出描述:输出一行，包括两个整数a b。a表示丢失的线段的编号。b表示丢失了第a条线段后，没被覆盖到的点的个数。输入5 31 34 53 4输出3 0 这里涉及到区间的修改与查询.先了解一下差分区间和前缀和:如果要修改[L, R]区间,可以直接将区间L[i] + k,R[i + 1] - k,然后遍历一遍数组，将前缀和d[i] += d[i - 1]与原数组相加,最后就可以得到修改后的数组。例如0 1 2 3 4 5 0, 我这里想把[2, 4]区间里面的值都加上1，将[1, 3]中的值都加上3,得到的差分区间为0 3 1 0 -3 -1 0,然后遍历数组，将前缀和(0 3 4 4 1 0 0)与原数组相加得到0 4 6 7 5 5 0.这样的好处是只需要一次遍历就能修改所有改变了的值。然后回到这题：首先对输入的区间进行一次差分d[L[i]]++, d[R[i] + 1]–，然后使用前缀和d[i] += d[i - 1]得到更改之后的数组(因为初始数组内的数字全为0)。将数组内值为1的点找出来(因为覆盖的点的个数为1，那么删除该线段之后，该点就没有被覆盖了)，再用一次前缀和，这个前缀和就是便于查找某区间内点的个数为1的数组，同时在遍历的时候记录值为0的点,即线段没覆盖的点cnt，最后用求得的前缀和数组便可以找到区间内覆盖点的数目最少的区间以及个数min, cnt + min就是没被覆盖的点的个数。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 100001;int main()&#123; int L[N], R[N]; int b[N], s[N]; memset(b, 0, sizeof(b)); memset(s, 0, sizeof(s)); int n, m, cnt = 0; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++)&#123; cin &gt;&gt; L[i] &gt;&gt; R[i]; b[L[i]]++; b[R[i] + 1]--; &#125; for(int i = 1; i &lt;= n; i++)&#123; b[i] += b[i - 1]; s[i] = s[i - 1] + (b[i] == 1); cnt += (b[i] == 0); &#125; int now = 0, min = 1000000, ans = 1; for(int i = 1; i &lt;= m; i++)&#123; now = s[R[i]] - s[L[i] - 1]; if(now &lt;= min)&#123; min = now; ans = i; &#125; &#125; cout &lt;&lt; ans &lt;&lt; &quot; &quot; &lt;&lt; min + cnt &lt;&lt; endl; return 0;&#125; D题1234567891011121314151617181920212223题目描述旅行到K国的小w发现K国有着很多物美价廉的商品，他想要买一些商品。结果一掏钱包，包里只剩下n张K国的纸币了，说起来也奇怪，K国纸币并不像其他国家一样都是1元，5元，10元…而是各种奇怪的面值，所以找零就不是很方便。 已知商店里的商品价格都是小于等于m的正整数，如果有可能存在某个商品的价格为x&lt;=m并且x无法在不找零的情况下支付，小w就不能任意购买一件商店中的商品，小w想知道自己在不找零的情况下能否任意购买一件商店中的商品，你能帮帮他么？输入描述:第一行是两个正整数n,m（n&lt;=1000,m&lt;=2^31-1）第二行共n个正整数ai(1&lt;=ai&lt;=2^31-1)，代表小w钱包中K国纸币的面值。输出描述:如果能任意购买商店中的物品，请输出&quot;YES&quot;(不含引号)。如不能任意购买商店中的物品，请输出&quot;NO&quot;（不含引号）。输入4 101 2 3 4输出YES 商品价值和纸币面值&gt;=1,首先将纸币面值排序，第一个数必须为1，否则不能购买商店中的商品,第二个数为1或2，否则不能凑成2; 第三个数为1、2或3，否则不能凑成3，以此类推. 数列{an}满足题意,该数列是从1开始表示一直到最大能表示的数，也就是数列的和Sn， 数列的第一个数为a[0],将后面的数一个个加入到该数列中,加入的条件为 a[i + 1] &lt;= sum + 1，如何理解呢，首先：a[i + 1] 如果大于sum + 1，那么该数列只能表示1~sum和a[i + 1] + {1 ~ sum}，无法表示sum + 1; 如果等于那么a[i + 1]本身就可以 表示sum + 1; 如果小于，a[i + 1] + {1 ~ sum}表示的范围就是{1 ~ sum + a[i + 1]}, a[i + 1]又至少为1，则必定满足。最后判断表示最大数的sum大于等于m，那么就输出YES，否则NO. 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define ll long long int main()&#123; ll n; ll m, a[1001]; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; sort(a + 1, a + n + 1); ll sum = 0; for(int i = 0; i &lt;= n; i++)&#123; sum += a[i]; if(a[i + 1] &gt; sum + 1) break; &#125; if(sum &gt;= m) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[]},{"title":"牛客练习赛41的E题题解","slug":"algorithm/nowcoderPractice41","date":"2019-03-18T13:02:47.415Z","updated":"2019-03-18T13:02:47.383Z","comments":true,"path":"2019/03/18/algorithm/nowcoderPractice41/","link":"","permalink":"https://gydjsz.github.io/2019/03/18/algorithm/nowcoderPractice41/","excerpt":"这题貌似知道了公式就简单了","text":"这题貌似知道了公式就简单了 E题某天lililalala正在玩一种奇妙的吃鸡游戏–因为在这个游戏里会同时有两个圆形安全区(他们可能相交)lililalala觉得求圆的面积并太简单了，所以想把这个问题升级一下。现在在三维空间里有 2 个球形安全区，分别用四元组&lt;x1, y1, z1, r1&gt;和&lt;x2, y2, z2, r2&gt;表示，其中 r1、r2表示球半径，&lt;x1, y1, z1&gt;和&lt;x2, y2, z2&gt;表示球心lililalala想知道安全区的总体积是多少？即求这两个球的体积并。 输入描述:输入有两行。第一行四个实数x1,y1,z1,r1–第一个球的球心坐标和半径。第二行四个实数x2,y2,z2,r2–第一个球的球心坐标和半径。保证所有输入的坐标和半径的范围都在[−100,100] 内。 输出描述:输出一行一个实数–表示两个球的体积并，你的答案被认为正确，当且仅当绝对误差不超过10^−6。输入0 0 0 12 0 0 1输出8.3775804 输入0 0 0 10 0 0 0.5 输出4.1887902 思路：设两个球体的体积为Va, Vb, 球心之间的距离为d，球体存在三种情况，相离/外切，相交, 内切 相离/外切，直接求两球体积之和 相交，先求两球体积之和，再减去公共部分, 公共部分为两个球缺(球缺知识)Va = π h² (3 * r - h) / 3 距离ｄ可以用两点间的距离公式求解h 未知，现在求h：123456789h = r1² - x1²h = r2² - x2²=&gt; r1² - x1² = r2² - x2²=&gt; r1² - r2² = x1² - x2²=&gt; r1² - r2² = (x1 + x2) * (x1 - x2)=&gt; r1² - r2² = d * (x1 - (d - x1))=&gt; r1² - r2² = d * (2 * x1 - d)=&gt; x1 = (r1² - r2² + d²) / (2 * d)=&gt; h = r1² - (r1² - r2² + d²) / (2 * d) 内切，分别求两球体积，体积大的就是两球的并 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;iomanip&gt;using namespace std;const double PI = acos(-1);int main()&#123; double x1, y1, z1, r1; double x2, y2, z2, r2; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; z1 &gt;&gt; r1; cin &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; z2 &gt;&gt; r2; double d = sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2) + pow(z1 - z2, 2)); double area; if(d &gt;= r1 + r2)&#123; area = 1.0 * 4 * PI * (pow(r1, 3) + pow(r2, 3)) / 3; &#125; else if(abs(r1 - r2) &lt; d &amp;&amp; d &lt; r1 + r2)&#123; double h1 = r1 - (r1 * r1 - r2 * r2 + d * d) / (2 * d); double h2 = r2 - (r2 * r2 - r1 * r1 + d * d) / (2 * d); double qiuque1 = PI * h1 * h1 * (3 * r1 - h1) / 3; double qiuque2 = PI * h2 * h2 * (3 * r2 - h2) / 3; double areaSum = 1.0 * 4 * PI * (pow(r1, 3) + pow(r2, 3)) / 3; area = areaSum - qiuque1 - qiuque2; &#125; else&#123; double area1 = 1.0 * 4 * PI * pow(r1, 3) / 3; double area2 = 1.0 * 4 * PI * pow(r2, 3) / 3; area = max(area1, area2); &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(7) &lt;&lt; area &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[]},{"title":"二分图","slug":"algorithm/bipartiteGraph","date":"2019-03-18T13:01:04.979Z","updated":"2019-03-18T13:01:04.935Z","comments":true,"path":"2019/03/18/algorithm/bipartiteGraph/","link":"","permalink":"https://gydjsz.github.io/2019/03/18/algorithm/bipartiteGraph/","excerpt":"参考连接:https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E5%9B%BE/9089095?fr=aladdinhttps://blog.csdn.net/sixdaycoder/article/details/47720471http://blog.jobbole.com/106084/","text":"参考连接:https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E5%9B%BE/9089095?fr=aladdinhttps://blog.csdn.net/sixdaycoder/article/details/47720471http://blog.jobbole.com/106084/ 几个概念 二分图二分图又称作二部图，是图论中的一种特殊模型。 设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。 最大匹配问题给定一个二分图G，在G的一个子图M中，M的边集中的任意两条边都不依附于同一个顶点，则称M是一个匹配.选择这样的边数最大的子集称为图的最大匹配问题。 完备匹配(complete matching)是匹配了二分图较小集合（二分图X，Y中小的那个）的所有点的匹配。完美匹配(perfect matching)是匹配了所有点的匹配。 最佳匹配如果二分图的每条边都有一个权（可以是负数），要求一种完备匹配方案，使得所有匹配边的权和最大，记做最佳完美匹配。（特殊的，当所有边的权为1时，就是最大完备匹配问题） 最小顶点覆盖在二分图中寻找一个尽量小的点集，使图中每一条边至少有一个点在该点集中。 最小顶点覆盖 == 最大匹配。 最小路径覆盖在二分图中寻找一个尽量小的边集，使图中每一个点都是该边集中某条边的端点。 最小路径覆盖 == |V| - 最大匹配。 最大独立集在N个点中选出来一个最大点集，使这个点集中的任意两点之间都没有边。 最大独立集 == 顶点数 - 最大匹配。 交替路和增广路 交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。 增广路的定义(也称增广轨或交错轨):从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路. 由增广路的定义可以推出下述三个结论:1) P的路径长度必定为奇数，第一条边和最后一条边都不属于M.2) P经过取反操作可以得到一个更大的匹配M’.3) M为G的最大匹配当且仅当不存在相对于M的增广路径. 匈牙利算法和km算法https://www.cnblogs.com/logosG/p/logos.htmlhttps://blog.csdn.net/ling_wang/article/details/79830980?utm_source=blogxgwz3https://www.cnblogs.com/zhanzhao/p/3895880.htmlhttps://blog.csdn.net/ling_wang/article/details/79830980?utm_source=blogxgwz3","categories":[],"tags":[]},{"title":"linux终端下实现有道翻译","slug":"Interest/youdao","date":"2019-03-18T13:00:55.683Z","updated":"2019-03-18T13:00:55.639Z","comments":true,"path":"2019/03/18/Interest/youdao/","link":"","permalink":"https://gydjsz.github.io/2019/03/18/Interest/youdao/","excerpt":"参考链接1参考链接2","text":"参考链接1参考链接2 有道翻译的代码如下先将此代码复制到一个文件里面，并将这个文件放到～/Documents下，命名为youdao.py 版本一123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#! /usr/bin/pythonimport re;import urllib;import urllib2;import sys;def debug(): xml = open(\"word.xml\").read(); print get_text(xml); print get_elements_by_path(xml, \"custom-translation/content\"); #print_translations(xml, False, False);def get_elements_by_path(xml, elem): if type(xml) == type(''): xml = [xml]; if type(elem) == type(''): elem = elem.split('/'); if (len(xml) == 0): return []; elif (len(elem) == 0): return xml; elif (len(elem) == 1): result = []; for item in xml: result += get_elements(item, elem[0]); return result; else: subitems = []; for item in xml: subitems += get_elements(item, elem[0]); return get_elements_by_path(subitems, elem[1:]);textre = re.compile(\"\\!\\[CDATA\\[(.*?)\\]\\]\", re.DOTALL);def get_text(xml): match = re.search(textre, xml); if not match: return xml; return match.group(1);def get_elements(xml, elem): p = re.compile(\"&lt;\" + elem + \"&gt;\" + \"(.*?)&lt;/\" + elem + \"&gt;\", re.DOTALL); it = p.finditer(xml); result = []; for m in it: result.append(m.group(1)); return result;GREEN = \"\\033[1;32m\";DEFAULT = \"\\033[0;49m\";BOLD = \"\\033[1m\";UNDERLINE = \"\\033[4m\";NORMAL = \"\\033[m\";RED = \"\\033[1;31m\"def crawl_xml(queryword): return urllib2.urlopen(\"http://dict.yodao.com/search?keyfrom=dict.python&amp;q=\" + urllib.quote_plus(queryword) + \"&amp;xmlDetail=true&amp;doctype=xml\").read();def print_translations(xml, with_color, detailed): #print xml; original_query = get_elements(xml, \"original-query\"); queryword = get_text(original_query[0]); custom_translations = get_elements(xml, \"custom-translation\"); print BOLD + UNDERLINE + queryword + NORMAL; translated = False; for cus in custom_translations: source = get_elements_by_path(cus, \"source/name\"); print RED + \"Translations from \" + source[0] + DEFAULT; contents = get_elements_by_path(cus, \"translation/content\"); if with_color: for content in contents[0:5]: print GREEN + get_text(content) + DEFAULT; else: for content in contents[0:5]: print get_text(content); translated = True; yodao_translations = get_elements(xml, \"yodao-web-dict\"); printed = False; for trans in yodao_translations: webtrans = get_elements(trans, \"web-translation\"); for web in webtrans[0:5]: if not printed: print RED + \"Translations from yodao:\" + DEFAULT; printed = True; keys = get_elements(web, \"key\"); values = get_elements_by_path(web, \"trans/value\"); summaries = get_elements_by_path(web, \"trans/summary\"); key = keys[0].strip(); value = values[0].strip(); #summary = summaries[0].strip(); #lines = get_elements(summary, \"line\"); if with_color: print BOLD + get_text(key) + \":\\t\" +DEFAULT + GREEN + get_text(value) + NORMAL; #for line in lines: # print GREEN + get_text(line) + DEFAULT; #print get_text(summary) + DEFAULT; else: print get_text(value); #print get_text(summary); #translated = True; #if not detailed: # break def usage(): print \"usage: dict.py word_to_translate\";def main(argv): if len(argv) &lt;= 0: usage(); #debug(); sys.exit(1); xml = crawl_xml(\" \".join(argv)); print_translations(xml, True, False); if __name__ == \"__main__\": main(sys.argv[1:]); 版本二(simply)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/env python# -*- coding:utf-8 -*-# API key：273646050# keyfrom：11pegasus11import jsonimport systry: # py3 from urllib.parse import urlparse, quote, urlencode, unquote from urllib.request import urlopenexcept: # py2 from urllib import urlencode, quote, unquote from urllib2 import urlopendef fetch(query_str=''): query_str = query_str.strip(\"'\").strip('\"').strip() if not query_str: query_str = 'python' print(query_str) query = &#123; 'q': query_str &#125; url = 'http://fanyi.youdao.com/openapi.do?keyfrom=11pegasus11&amp;key=273646050&amp;type=data&amp;doctype=json&amp;version=1.1&amp;' + urlencode(query) response = urlopen(url, timeout=3) html = response.read().decode('utf-8') return htmldef parse(html): d = json.loads(html) try: if d.get('errorCode') == 0: explains = d.get('basic').get('explains') for i in explains: print(i) else: print('无法翻译') except: print('翻译出错，请输入合法单词')def main(): try: s = sys.argv[1] except IndexError: s = 'python' parse(fetch(s))if __name__ == '__main__': main() 创建一个脚本，放在～/下，命名为fy 123456#! /bin/bashwhile [ $# -ne 0 ]do python ~/Documents/youdao.py $1 shiftdone 赋予脚本可执行的权限chmod u+x fy 将该脚本链接到/usr/bin下sudo ln -s ~/fy /usr/bin/fy 输入fy 单词/汉语 就可以翻译了Oh yeah！ 注:这里其实还有一种很神奇的办法,在Linux之中有一种叫做命令别名的东西,即alias 别名=’命令参数’比如说这里使用chmod u+x youdao.py,讲youdao.py变为可执行文件之后,可以使用命令./youdao.py来执行,那么我该怎么做呢,首先vim .bashrc,打开.bashrc文件,将alias fy=’/home/username/./youdao.py’添加到文件的末尾,然后使用source .bashrc来使其生效即可,/home/username/是你的目录名,fy=’/home/username/./youdao.py’的意思是将/home/username/./youdao.py起一个别名,为fy,这样你虽然命令为fy,但其实是后面的那一长串命令的效果","categories":[],"tags":[]},{"title":"坦克大战","slug":"Java/TankGame","date":"2019-03-18T13:00:12.331Z","updated":"2019-03-18T13:00:12.291Z","comments":true,"path":"2019/03/18/Java/TankGame/","link":"","permalink":"https://gydjsz.github.io/2019/03/18/Java/TankGame/","excerpt":"一、前言：整个坦克大战游戏做的比较匆忙的，里面也有很多的bug，代码也写得比较乱，整理博客的时候也不太好整理，本想优化一下下，可是由于整个项目结构的缘故，只能到这一步了，这次算是有了很多的经验，相信下次再做的时候，应该会好得多。","text":"一、前言：整个坦克大战游戏做的比较匆忙的，里面也有很多的bug，代码也写得比较乱，整理博客的时候也不太好整理，本想优化一下下，可是由于整个项目结构的缘故，只能到这一步了，这次算是有了很多的经验，相信下次再做的时候，应该会好得多。 二、主体介绍游戏结构主要有游戏面板、设置面板、菜单栏、坦克、子弹以及提升属性的物品 玩法规则 我方坦克将敌方坦克打完，就算获胜 敌方坦克将我方坦克击败三次以及基地被摧毁，就算失败 打掉草地以及击败敌方坦克均会掉落物品，捡到后能提升属性值 三、代码实现 游戏面板 游戏的开始面板将背景的图片，以及文字信息放了上去。这里由于出现了双缓冲技术，就在这里简单地说一下。 “双缓冲技术”的绘图过程如下 在内存中创建与画布一致的缓冲区 在缓冲区画图 将缓冲区位图拷贝到当前画布上 释放内存缓冲区 &emsp;双缓冲即在内存中创建一个与屏幕绘图区域一致的对象，先将图形绘制到内存中的这个对象上，再一次性将这个对象上的图形拷贝到屏幕上，这样能大大加快绘图的速度。 版本一（重写update方法）：重量级中repaint首先调用update方法，update然后再调用paint方法。再轻量级组件中直接调用paint。 12345678910private Image offScreenImage = null; public void update(Graphics g) &#123; if(offScreenImage == null) offScreenImage = this.createImage(500,500);//这是游戏窗口的宽度和高度 Graphics gOff = offScreenImage.getGraphics(); paint(gOff); g.drawImage(offScreenImage, 0, 0, null);&#125; 由于JFrame是轻量级的，因而可以重写paint方法 1234567891011private Image offScreenImage = null;public void paint(Graphics g) &#123; // 在重绘函数中实现双缓冲机制 offScreenImage = this.createImage(WIDTH, HEIGHT); // 获得截取图片的画布 gImage = offScreenImage.getGraphics(); gImage.setColor(gImage.getColor()); gImage.fillRect(0, 0, WIDTH, HEIGHT); // 填充缓冲 super.paint(gImage); //用gImage绘制图形, 代码根据具体情况 g.drawImage(offScreenImage, 0, 0, null); //将缓冲图案绘制在屏幕上 &#125; 这中方式就比较容易理解，而且通用1234567//初始化缓冲区BufferedImage imag = new BufferedImage(Constent.width, Constent.height, BufferedImage.TYPE_INT_RGB);Graphics g1 = imag.getGraphics();public void paint()&#123; g1.drawImage(x, y, width, height, null); g.drawImage(imag, x, y, width, height, null);&#125; 里面有个设置鼠标指针样式一个代码，不过找的指针图片不太好看，就没加上，就先把方法留在里面了。 123Image coursor = GameUtil.getImage(\"TankImage/logo.jpg\"); //设置指针图片//设置鼠标指针样式setCursor(Toolkit.getDefaultToolkit().createCustomCursor(coursor,new Point(0, 0), null)); 点击开始游戏和游戏设置的面板切换这里使用了鼠标监听1234public void mousegCliked(MouseEvent e)&#123; e.getX(); e.getY(); //获得鼠标的坐标&#125; 首先可以获得左上角和右下角的坐标位置，然后可以得到一个范围，只要是在这个范围内，都可以触发鼠标事件。 这里需要注意的是，要将事件监听添加到JFrame中。如果是点击开始游戏，那么触发事件后就可以将初始面板设置为不可见setVisible(false)，然后将它从JFrame中移除，再将新的面板添加进来，并设置其为可见。然后如果是点击游戏设置，那么就直接将该面板设置为可见 游戏设置窗口 里面使用几个组件： JLabel: 标签 JRadioButton: 单选按钮 JSLider: 滑块 JTextField: 文本框 JButton: 按钮 JComboBox: 下拉菜单 12345678910111213141516jSlider = new JSlider(10, 100, initValue); //设置起始点值，终点值，默认值jsl.setPaintTicks(true); //设置滑块绘制刻度标记jsl.setMajorTickSpacing(10); //设置主刻度标记的间隔jsl.setMinorTickSpacing(2); //设置副刻度标记的间隔//这是修改坦克数量显示的事件处理jSlider.addChangeListener(new ChangeListener() &#123; public void stateChanged(ChangeEvent e) &#123; jTextField.setText(String.valueOf(jSlider.getValue())); &#125;&#125;);jTextField.setEditable(true); //设置文本不可更改jDialog.setModalityType(ModalityType.APPLICATION_MODAL); //设置该窗口打开后将其它窗口锁住 坦克大战的主面板 这个是游戏的主体，包含地图的绘制、显示所有坦克的移动和子弹发射的轨迹、物品掉落、游戏信息面板，坦克死亡、基地破坏的判定; 由于所有的地图、坦克、子弹都已经放在了各自的ArrayList容器之中，所以在paint方法之中就只需遍历容器中的每一个值，然后将里面的内容绘制在屏幕上。 1234567ArrayList&lt;Tank&gt; tank;tank = new ArrayList&lt;Tank&gt;;tank.add(tank1); //将坦克添加到容器中tank.add(tank2);Tank t = tank.get(i); //获得第i个坦克tank.remove(i); //移除第i个坦克 设置字体的颜色和样式setFont(new Font(“楷体”, Font.BOLD, 60)); //楷体，粗体，60号setColor(Color.BLACK); //白色 记录游戏的时间startTime = System.currentTimeMillis();setEnd.endTime = System.currentTimeMillis();setEnd.time = setEnd.endTime - setEnd.startTime; 菜单 功能: 回到主面板、重新开始游戏、暂停游戏、恢复、退出游戏 回到主面板将游戏数据设置为结束的状态，然后将主面板设置为不可见，再移除坦克的键盘监听，新建一个主面板，再添加到JFrame中 重新开始游戏将游戏数据设置为结束的状态，然后初始化主面板 暂停游戏将所有的坦克和子弹，位置、方向不可改变，坦克不可键盘监听，这样线程还在运作，但是事实上所有的物体已经不能移动 恢复就反过来，将一切复原 退出游戏System.exit(0); 坦克设置 坦克的属性有坐标、方向、速度、是否存活、生命值、攻击力等这里速度可以直接设置坐标的改变量，然后也可以设置执行线程的时间，线程中有sleep()方法和坦克坐标移动的方法，避免由于线程执行太快而设置了线程暂停的时间，将时间缩短也可以提高速度 坦克的子弹使用了线程，当发射子弹后，就执行线程，线程中每隔一段时间将子弹的坐标改变，以此达到子弹自动运动的效果 在坦克的键盘监听之中，可以将按下的四个方向设置为boolean类型，如果直接按下方向键就进行移动，那么会有卡顿感，因为键盘监听是有延时的，当按下某一个方向的键时，就设置其为true，那么按下的过程中那个方向就一直为true，松开键时，将其设为false 坦克的碰撞检测:碰撞检测的理论是：将两个物体看做矩形，矩形相交就判定为相碰。 123Rectangle r1 = new Rectangle(x1, y1, width, height);Rectangle r2 = new Rectangle(x2, y2, width, height);rl.intersects(r2); //相交为true，否则为false 如果加上位移会相交，那么就刚好到碰不到物体的地方，否则可以移动 坦克的移动使用的是随机数12Random random = new Random();int n = random.nextInt(4); //随机数[0,3) 图片的插入这里使用了GameUtil类，使用这个类比较容易添加图片 1234567891011121314151617public class GameUtil &#123; // 工具类最好将构造器私有化。 private GameUtil() &#123; &#125; public static Image getImage(String path) &#123; BufferedImage bi = null; try &#123; URL u = GameUtil.class.getClassLoader().getResource(path); bi = ImageIO.read(u); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return bi; &#125;&#125; 使用方法1Image image = GameUtil.getImage(路径);","categories":[],"tags":[]},{"title":"String类","slug":"Java/javaString","date":"2019-03-18T12:59:55.855Z","updated":"2019-03-18T12:59:55.815Z","comments":true,"path":"2019/03/18/Java/javaString/","link":"","permalink":"https://gydjsz.github.io/2019/03/18/Java/javaString/","excerpt":"String类型访问里面的每一个字符可以使用s.charAt(i)1String s = \"hello\"; //s.charAt(0) = h","text":"String类型访问里面的每一个字符可以使用s.charAt(i)1String s = \"hello\"; //s.charAt(0) = h 产生随机数123double b = Math.random(); //产生[0,1)之间的小数int n = (int)(b * 5); //产生[0,5)之间的整数int m = 1 + (int)(b * 6); //产生[1,6]之间的整数 public boolean equals(String s),比较当前String对象字符序列和参数的字符序列是否相等equalsIgnoreCase()方法在比较时会忽略大小写123456String Tom = new String(\"木头人\");String Marry = new String(\"植物人\"); String Jack = new String(\"植物人\"\");System.out.println(Tom.equals(Marry)); //结果为falseSystem.out.println(Jack.equals(Marry)); //结果为true System.out.println(Jack == Marry); //结果为false 由于string对象Marry和Jack存放的是引用,其所在的内存不一样,因而内容相同却不相等 public boolean startsWith(String s)/endsWith(String s)s1.startsWith(s2)&emsp;:判断当前String对象的字符序列前缀是否和参数相同s1.endsWith(s2)&emsp;:判断当前String对象的字符序列后缀是否和参数相同 public int compareTo(String s)s1.compareTo(s2)&emsp; :按照字典序比较s1和s2的字符序列是否相同,相同返回0,s1 &gt; s2返回正值, s1 &lt; s2返回负值 public boolean contains(String s)s1.contains(s2):判断s1中是否包含s2123String Tom = \"students\";System.out.println(Tom.contains(\"stu\")); //值为tureSystem.out.println(Tom.contains(\"ab\")); //值为false public int indexOf(String s) / lastIndexOf(String s)s1.indexOf(s2):从s1中的0位置开始搜索s2,并返回首次出现s2的位置,如果没有找到就返回-1,lastIndexOf()则是从末尾开始搜索indexOf(String str, int startpoint)重载方法,startpoint指定检索的开始位置12345String tom = \"I am a good cat\";tom.indexOf(\"a\"); //值为2tom.indexOf(\"good\", 2); //值为7tom.indexOf(\"a\", 7); //值为13tom.indexOf(\"w\", 2); //值为-1 public String substring(int startpoint)s2 = s1.substring(start); //从start位置开始复制s1中字符串到s2中s2 = s1.substring(start, end) //从start位置开始截至end-1复制s1中字符串到s2中123String s = \"abcdefg\";String s1 = s.substring(0); //s1 = \"abcdefg\";String s2 = s.substring(2, 4); //s2 = \"cd\"; public String trim()去掉字符序列中的前后空格12String s = \" abcd \";System.out.println(s.trim()); //结果为abcd public void getChars(int start, int end, char c[], int offset)将String对象从start到end-1的字符存放到从offset位置开始的c数组中1234String s = \"abcdefg\";char c[] = new char[10];s.getChars(0, 2, c, 0);System.out.println(c); //输出结果为ab public char[] toCharArray()将String中的字符序列全部存放在数组中123String s = \"abcdefghijk\";char c[] = s.toCharArray();System.out.println(c); //输出结果为abcdefghijk public boolean matches(String regex)判断当前字符串是否匹配给定的正则表达式, 是返回true, 否则返回false123String s = \"[1234]?\";String s1 = \"123\";System.out.println(s1.matches(s1)); public String repalceAll(String regex, String replacement)匹配当前对象中字符序列和regex中相同的, 用replacement全部替换123String s = \"hello\";String s1 = \"hello world\";System.out.println(s1.replacement(s, \"welcome to my\")); //结果为welcome to my world","categories":[],"tags":[]},{"title":"java图形库学习","slug":"Java/graphicsLibrary","date":"2019-03-18T12:59:47.899Z","updated":"2019-03-18T12:59:47.855Z","comments":true,"path":"2019/03/18/Java/graphicsLibrary/","link":"","permalink":"https://gydjsz.github.io/2019/03/18/Java/graphicsLibrary/","excerpt":"需要继承JFrame类来画窗口 =&gt; public class Game extends JFrame {}setTitle(String s); //设置窗口标题setLocation(int x, int y); //设置窗口位置setSize(int width, int height); //设置窗口宽和高setVisible(true); //设置窗口可见,默认为flase,这个方法放在setLocation()和setSize后面较好,我放在前面窗口为黑色,本来默认为白色的","text":"需要继承JFrame类来画窗口 =&gt; public class Game extends JFrame {}setTitle(String s); //设置窗口标题setLocation(int x, int y); //设置窗口位置setSize(int width, int height); //设置窗口宽和高setVisible(true); //设置窗口可见,默认为flase,这个方法放在setLocation()和setSize后面较好,我放在前面窗口为黑色,本来默认为白色的 paint方法画图定义后自动调用123456789101112public class paint(Graphics g) &#123; Color c = g.getColor(); //记录原来的颜色 Font f = g.getFont(); //记录原来的字体 g.setColor(Color.BLACK); //设置画线的颜色 g.drawLine(int x1, int y1, int x2, int y2); //两点画直线 g.drawRect(int x, int y, int width, int height); //左上角顶点加宽高画矩形 g.fillRect(int x, int y, int width, int height); //画填充矩形 g.setFont(new Font(\"楷体\", Font.BOLD, 40)); //设置字体为楷体,粗体,大小为40 g.drawString(str, int x, int y); //画出str字符串 g.setColor(c); //变回原来的颜色 g.setFont(f); //变回原来的字体&#125; GameUtil工具类导入图片1234567891011121314151617181920212223242526import java.awt.Image;import java.awt.image.BufferedImage;import java.io.IOException;import java.net.URL;import javax.imageio.ImageIO; public class GameUtil &#123; // 工具类最好将构造器私有化。 private GameUtil() &#123; &#125; public static Image getImage(String path) &#123; BufferedImage bi = null; try &#123; URL u = GameUtil.class.getClassLoader().getResource(path); bi = ImageIO.read(u); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return bi; &#125;&#125; 在Game类里面调用GameUtilImage imag = GameUtil.getImage(“images/picture.png”); //我建立的一个images包,用来存储图片,引号里面为图片的路径g.drawImage(imag, x, y, width, height, null); //imag图片,位置,宽高,观察者 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.Image;import javax.swing.JFrame;public class MyGame extends JFrame&#123; Image imag = GameUtil.getImage(\"images/text1.png\"); //指定图片 @Override public void paint(Graphics g) &#123; Color c = g.getColor(); Font f = g.getFont(); g.setColor(Color.BLUE); //设置线体颜色 g.drawLine(100, 100, 650, 100); //直线 g.drawRect(50, 150, 200, 200); //空心矩形 g.fillRect(550, 150, 200, 200); //实体矩形 g.drawOval(300, 150, 200, 200); //圆形 g.setFont(new Font(\"楷体\", Font.BOLD, 90)); //设置字体 g.drawString(\"How are you？\", 100, 100); //写字 g.drawImage(imag, 250, 400, 300, 300, null); //插入图片 g.setColor(c); //线条颜色变为原来的样子 g.setFont(f); //字体变为原来的样子 &#125; public void launchJFrame() &#123; this.setTitle(\"我的游戏\"); //设置窗口标题 this.setSize(800, 800); //设置窗口大小 this.setLocation(100, 100); //设置窗口位置 this.setVisible(true); //设置窗口可见 /*this.addWindowListener(new WindowAdapter() &#123; //叉掉窗口后，结束窗口所在的应用程序 @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); */ this.setDefaultCloseOperation(EXIT_ON_CLOSE); //叉掉窗口后，结束窗口所在的应用程序 &#125; public static void main(String args[]) &#123; MyGame game = new MyGame(); game.launchJFrame(); &#125;&#125; 设置图片的大小public Image getScaledInstance(int width, int height, int hints) &emsp;//hints - 指示用于图像重新取样的算法类型的标志(这句话不知道是什么意思,照着下面的写就对了)12Image img = GameUtil.getImage(\"images/text1.jpg\");img = img.getScaledInstance(width, height, Image.SCALE_DEFAULT); 如果是要获取图片的大小,直接使用getWidth()和getHeight()方法就可以了12width = img.getWidth();height = img.getheight(); 双缓冲技术解决闪烁原理大概是:先将所需要画的东西加载到缓冲区,然后将缓冲区中的内容全部画到屏幕上,这样就可以避免因为屏幕加载的东西太多导致屏幕疯狂闪烁12345678public void paint(Graphics g)&#123; BufferedImage imag = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); //构建缓冲区 Graphics g2 = imag.creatGraphics(); //新建一支画笔,使用这支画笔来将内容画到缓冲区中 g2.drawRect(...); //括号里面的参数就不写了,此处用来说明一些画图操作 g2.drawImag(...); g2.fillOval(...); g.drawImage(imag, x, y, width, height, null); //将内容画到屏幕上&#125;","categories":[],"tags":[]},{"title":"java基本数据类型","slug":"Java/dataType","date":"2019-03-18T12:59:37.815Z","updated":"2019-03-18T12:59:37.783Z","comments":true,"path":"2019/03/18/Java/dataType/","link":"","permalink":"https://gydjsz.github.io/2019/03/18/Java/dataType/","excerpt":"char类型转化为小写字母大写为toUpperCase();1char c = input.nextLine().toLowerCase().toCharArray()[0];","text":"char类型转化为小写字母大写为toUpperCase();1char c = input.nextLine().toLowerCase().toCharArray()[0]; float类型常量后面必须要有后缀f或Fdouble类型后面有后缀d或D,但是可以省略1float x = 3.14f; double类型可以进行模运算1double x = 3.0 / 2; //x的值为1.0 数字格式化 123double b = 3.150;NumberFormat nf = NumberFormat.getInstance();nf.format(b); //3.15 将Double转化为Integer类型Double d = 3.7; 12int n = d.inValue(); //double转化为int类型Integer it = Integer.valueOf(n); //int类型转化为double类型 double类型保留小数 123DecimalFormat df = new DecimalFormat(\"0.00\");double b = 3.141;df.format(b);","categories":[],"tags":[]},{"title":"学习新的emacs快捷键","slug":"LearnEmacs/GoodShortCutkey","date":"2019-03-18T12:59:22.279Z","updated":"2019-03-18T12:59:22.239Z","comments":true,"path":"2019/03/18/LearnEmacs/GoodShortCutkey/","link":"","permalink":"https://gydjsz.github.io/2019/03/18/LearnEmacs/GoodShortCutkey/","excerpt":"emacs对文本执行操作C-x-t: 交换上下两行C-t: 和光标左边的字母交换M-t: 和光标左边的字符串交换C-/: 撤销操作M-/: 单词补全c-u-n / ESC—n + 数字 向上下左右 删除 字母","text":"emacs对文本执行操作C-x-t: 交换上下两行C-t: 和光标左边的字母交换M-t: 和光标左边的字符串交换C-/: 撤销操作M-/: 单词补全c-u-n / ESC—n + 数字 向上下左右 删除 字母 (重复执行n次后续命令,省略n则执行4次(ps：对光标跳转之类的功能好用，C-y之类的功能无效) emacs光标跳转M-g-g + n(行数): 跳转到第n行M-{: 光标移动到段落开头M-}: 光标移动到段落结尾C-M-n: 跳转到括号结束位置C-M-p: 跳转到括号开始位置 emacs多窗口操作C-x 2: 水平分割C-x 3: 竖直分割C-x 1: 只保留当前窗格C-x 0: 关闭当前窗格C-x o: 切换窗格C-x 4 C-f: 在此窗格打开一个文件C-M-v: 滚动下一个窗格C-x-^: 扩大所在的窗格 emacs缩进C-M-\\: 缩进区域所有行 emacs正则表达式查找和替换C-s: 向下搜索C-r: 向上搜索M-%: 替换C-M-s: 向下使用正则表达式搜索C-M-r: 向上使用正则表达式搜索C-M-%: 使用正则表达式进行替换 如果找到匹配的, 可以按(C-r或C-M-r)/(C-s或C-M-s)继续向上/下搜索","categories":[],"tags":[]},{"title":"emacs配置","slug":"LearnEmacs/emacs","date":"2019-03-18T12:59:10.651Z","updated":"2019-03-18T12:59:10.615Z","comments":true,"path":"2019/03/18/LearnEmacs/emacs/","link":"","permalink":"https://gydjsz.github.io/2019/03/18/LearnEmacs/emacs/","excerpt":"这个配置有点乱，但是先放这里","text":"这个配置有点乱，但是先放这里(require ‘package)(package-initialize)(add-to-list’package-archives ‘(“melpa” . “http://melpa.milkbox.net/packages/&quot;) t)(custom-set-variables ;; custom-set-variables was added by Custom. ;; If you edit it by hand, you could mess it up, so be careful. ;; Your init file should contain only one such instance. ;; If there is more than one, they won’t work right. ‘(custom-safe-themes (quote (“8aebf25556399b58091e533e455dd50a6a9cba958cc4ebb0aab175863c25b9a4” “bffa9739ce0752a37d9b1eee78fc00ba159748f50dc328af4be661484848e476” default))) ‘(display-time-mode t) ‘(package-archives (quote ((“gnu” . “http://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/&quot;) (“melpa” . “http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/&quot;)))) ‘(package-selected-packages (quote (emms emms-bilibili w3m eimp dracula-theme ecb yasnippet-snippets sr-speedbar auto-yasnippet yasnippet-classic-snippets yasnippet electric-spacing spacemacs-theme solarized-theme flymake-cppcheck flycheck-title flycheck-objc-clang flycheck-irony flycheck-color-mode-line flycheck auto-complete-c-headers auto-complete))) ‘(show-paren-mode t))(custom-set-faces ;; custom-set-faces was added by Custom. ;; If you edit it by hand, you could mess it up, so be careful. ;; Your init file should contain only one such instance. ;; If there is more than one, they won’t work right. ‘(default ((t (:family “Ubuntu Mono” :foundry “DAMA” :slant normal :weight normal :height 158 :width normal))))) (global-auto-complete-mode t) ;(global-linum-mode 1) ; always show line numbers;(setq linum-format “%d)”) ;set format(global-linum-mode t) (global-flycheck-mode t) ;;启用时间显示设置，在minibuffer上面的那个杠上(display-time-mode 1);;时间使用24小时制(setq display-time-24hr-format t);;时间显示包括日期和具体时间;(setq display-time t) ;; TAB键的宽度设置为4(setq c-basic-offset 4) ;(load-theme ‘spacemacs-dark t) ;设置Spacemacs-dark主题 (load-theme ‘dracula t) ;(global-hl-line-mode 1) ;设置行号 ;;让Emacs可以直接打开和显示图片。(setq auto-image-file-mode t) (global-set-key (kbd “,”) ;逗号后面自动添加空格 #&apos;(lambda () (interactive) (insert &quot;, &quot;))) ;; 以 y/n代表 yes/no(fset ‘yes-or-no-p ‘y-or-n-p) ;; 语法高亮(global-font-lock-mode t) ;; 显示括号匹配(show-paren-mode t)(setq show-paren-style ‘parentheses) ;; 支持emacs和外部程序的粘贴(setq x-select-enable-clipboard t) ;; 在标题栏提示你目前在什么位置(setq frame-title-format “zhj@%b”) ;; 回车缩进(global-set-key “\\C-m” ‘newline-and-indent)(global-set-key (kbd “C-“) ‘newline) ;(yas-global-mode 1) (add-to-list ‘load-path “~/.emacs.d/plugins/yasnippet”)(require ‘yasnippet)(setq yas/prompt-functions ‘(yas/dropdown-prompt yas/x-prompt yas/completing-prompt yas/ido-prompt yas/no-prompt))(yas/global-mode 1)(yas/minor-mode-on) ; 以minor mode打开，这样才能配合主mode使用 (require ‘auto-yasnippet)(global-set-key (kbd “H-w”) #’aya-create)(global-set-key (kbd “H-y”) #’aya-expand) ;(sr-speedbar-open) (auto-image-file-mode) ;;关闭emacs启动时的画面(setq inhibit-startup-message t) ;; 改变 Emacs 固执的要你回答 yes 的行为。按 y 或空格键表示 yes，n 表示 no(fset ‘yes-or-no-p ‘y-or-n-p) ;;设置emacs GUI下的字体(set-default-font “-bitstream-Courier 10 Pitch-normal-normal-normal--29----m-0-iso10646-1”) (add-to-list ‘load-path “/home/dal/.emacs.d/elpa/ecb-20170728.1221”) ;;;; 各窗口间切换 (global-set-key [M-left] ‘windmove-left) (global-set-key [M-right] ‘windmove-right) (global-set-key [M-up] ‘windmove-up) (global-set-key [M-down] ‘windmove-down) ;; Disable buckets so that history buffer can display more entries;(setq ecb-history-make-buckets ‘never) (defun set-image-mode-mwheel-scroll-function () (setq-local mwheel-scroll-down-function ‘image-scroll-down) (setq-local mwheel-scroll-up-function ‘image-scroll-up)) (add-hook ‘image-mode-hook #’set-image-mode-mwheel-scroll-function) ;;emacs启动的时候自动全屏(add-to-list ‘default-frame-alist ‘(fullscreen . maximized)) ;(require ‘sr-speedbar) //隐藏工具栏, 菜单栏, 滚动条;(tool-bar-mode 0);(menu-bar-mode 0);(scroll-bar-mode 0) (global-auto-revert-mode t) ;(add-hook ‘c-mode-common-hook ( lambda() ( c-set-style “k&amp;r” ) ) ) ;;设置C语言默认格式(add-hook ‘c++-mode-common-hook ( lambda() ( c-set-style “k&amp;r” ) ) ) ;;设置C++语言默认格式 ;(global-set-key [(f8)] ‘loop-alpha) ;;注意这行中的F8 , 可以改成你想要的按键 (setq alpha-list ‘((85 55) (100 100))) (defun loop-alpha () (interactive) (let ((h (car alpha-list))) ((lambda (a ab) (set-frame-parameter (selected-frame) ‘alpha (list a ab)) (add-to-list ‘default-frame-alist (cons ‘alpha (list a ab))) ) (car h) (car (cdr h))) (setq alpha-list (cdr (append alpha-list (list h)))) )) ;打开emacs 之后 按F8 可以在透明 和不透明之间切换… (setq is-alpha nil) (defun transform-window (a ab) (set-frame-parameter (selected-frame) ‘alpha (list a ab)) (add-to-list ‘default-frame-alist (cons ‘alpha (list a ab)))) (global-set-key [(f8)] (lambda() (interactive) (if is-alpha (transform-window 100 100) (transform-window 85 50)) (setq is-alpha (not is-alpha)))) ;; Enable EDE (Project Management) features(global-ede-mode 1) (custom-set-variables‘(semantic-default-submodes (quote (global-semantic-decoration-mode global-semantic-idle-completions-modeglobal-semantic-idle-scheduler-mode global-semanticdb-minor-modeglobal-semantic-idle-summary-mode global-semantic-mru-bookmark-mode)))‘(semantic-idle-scheduler-idle-time 3)) (semantic-mode) ;; smart complitions(require ‘semantic/ia)(setq-mode-local c-mode semanticdb-find-default-throttle‘(project unloaded system recursive))(setq-mode-local c++-mode semanticdb-find-default-throttle‘(project unloaded system recursive)) ;;;; TAGS Menu(defun my-semantic-hook ()(imenu-add-to-menubar “TAGS”)) (add-hook ‘semantic-init-hooks ‘my-semantic-hook) ;;;; Semantic DataBase存储位置(setq semanticdb-default-save-directory(expand-file-name “~/.emacs.d/semanticdb”)) ;; 使用 gnu global 的TAGS。(require ‘semantic/db-global)(semanticdb-enable-gnu-global-databases ‘c-mode)(semanticdb-enable-gnu-global-databases ‘c++-mode) ;;;; 缩进或者补齐;;; hippie-try-expand settings(setq hippie-expand-try-functions-list‘(yas/hippie-try-expandsemantic-ia-complete-symboltry-expand-dabbrevtry-expand-dabbrev-visibletry-expand-dabbrev-all-bufferstry-expand-dabbrev-from-killtry-complete-file-name-partiallytry-complete-file-nametry-expand-all-abbrevs)) (defun indent-or-complete ()“Complete if point is at end of a word, otherwise indent line.”(interactive)(if (looking-at “\\&gt;”)(hippie-expand nil)(indent-for-tab-command))) (defun yyc/indent-key-setup ();”Set tab as key for indent-or-complete”(local-set-key [(tab)] ‘indent-or-complete)) (require ‘cedet) (semantic-mode 1) (global-ede-mode 1) (global-set-key (kbd ““) ‘sr-speedbar-toggle) ;;sr-speedbar按键绑定 ;;;; 自动启动ecb，并且不显示每日提示 (setq ecb-auto-activate t ecb-tip-of-the-day nil)","categories":[],"tags":[]},{"title":"为emacs添加源","slug":"LearnEmacs/addPlug","date":"2019-03-18T12:58:36.099Z","updated":"2019-03-18T12:58:36.063Z","comments":true,"path":"2019/03/18/LearnEmacs/addPlug/","link":"","permalink":"https://gydjsz.github.io/2019/03/18/LearnEmacs/addPlug/","excerpt":"参考链接:https://blog.csdn.net/sjhuangx/article/details/51252522参考链接:https://blog.csdn.net/watanuki2006/article/details/52122427","text":"参考链接:https://blog.csdn.net/sjhuangx/article/details/51252522参考链接:https://blog.csdn.net/watanuki2006/article/details/52122427 方法1emacs中输入M-x customize-variable RET package-archives，进入之后可以看到当前的package源，点击下面的INS按钮来插入新的package源，输入一个名字，一个url链接 name：melpaurl：https://melpa.org/packages 清华源:“gnu” . “http://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/&quot;“melpa” . “http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/&quot; 输入list-pakcages, 进入插件管理 i - 选择要安装的包 d - 选择要删除的包 U - 升级已安装的包 x - 执行操作 d - 选择要删除的包 输入 M-x package-refresh-contents，刷新package信息","categories":[],"tags":[]},{"title":"远程登陆linux系统","slug":"Linux/longRange","date":"2019-03-18T12:57:54.027Z","updated":"2019-03-18T12:57:53.991Z","comments":true,"path":"2019/03/18/Linux/longRange/","link":"","permalink":"https://gydjsz.github.io/2019/03/18/Linux/longRange/","excerpt":"开通ssh服务sudo apt-get install openssh-server","text":"开通ssh服务sudo apt-get install openssh-server 启用ssh-server服务默认安装之后就开启，可以通过ps -e |grep ssh查看，出现sshd就说明启动了 启动sshserver命令：service ssh start 或者sudo /etc/init.d/ssh start 关闭sshserver命令：service ssh stop 重启sshserver命令：service ssh restart 此时已经可以远程登陆，如果需要直接使用root账号登陆，则需要开通root权限vi /etc/ssh/ssh_dconfig将PermitRootLogin without-password 修改为PermitRootLogin yes 下载putty，输入linux系统的ip，并修改字体大小， 如果是通过linux来远程登陆另一台linux主机，则可以在终端里面输入ssh username@ip 注：查看linux的ip地址可以输入ifconfig","categories":[],"tags":[]},{"title":"matlab学习","slug":"matlabLearn/matlab","date":"2019-03-18T12:57:27.056Z","updated":"2019-03-18T12:57:27.016Z","comments":true,"path":"2019/03/18/matlabLearn/matlab/","link":"","permalink":"https://gydjsz.github.io/2019/03/18/matlabLearn/matlab/","excerpt":"clc,clear; 清除命令 close all 清除所有窗口 warning off 关闭警告","text":"clc,clear; 清除命令 close all 清除所有窗口 warning off 关闭警告 fprintf(‘result: %d’, a); 输出a的值 fprintf(fid, format, A) fid输出的位置(如果缺省，则输出在窗口) format(输出内容的类型) %e: 实数 %.3f: 浮点数(保留3位小数) A:输入内容的变量名 disp(a) 显示a的值 disp(‘hello’);disp(‘numstr(12)’) %%numstr()将其他类型的变量转化成字符串形式disp(zeros(m, n)) 顺序结构 判断结构 1234567if 条件 执行内容elseif 条件二 执行内容else 执行内容end 循环结构 1234567891011for i = 1 : m 循环内容endfor i = 1 : 3 : 9 fprintf('%d ', i); 输出1，4，7(步长为3)endwhile(条件) 循环内容end a = mod(45678, 10) 获得45678的余数 n = fix(465 / 10) n的值为46 [m, n] = size(a) 获取a的行、列数a(i, j) 第i行j列的值 函数的自定义function[输出] = fun(n)","categories":[],"tags":[]},{"title":"python","slug":"python/learnPython","date":"2019-03-18T12:57:12.304Z","updated":"2019-03-18T12:57:12.272Z","comments":true,"path":"2019/03/18/python/learnPython/","link":"","permalink":"https://gydjsz.github.io/2019/03/18/python/learnPython/","excerpt":"大小写转换12345name = \"hello, world\"name = name.title() #将单词首字母大写print(name) #输出Hello, Worldprint(name.upper()) #输出HELLO, WORLd (将字符串中的所有字母转化为大写)print(name.lower()) #输出hello, world (将字符串中的所有字母转化为小写)","text":"大小写转换12345name = \"hello, world\"name = name.title() #将单词首字母大写print(name) #输出Hello, Worldprint(name.upper()) #输出HELLO, WORLd (将字符串中的所有字母转化为大写)print(name.lower()) #输出hello, world (将字符串中的所有字母转化为小写) 注释123单行: #多行: ''' 注释''' 或者 \"\"\" 注释 \"\"\" 删除末尾的空格12favorite_language = 'python 'favorite_language.rstrip() #删除末尾的空格 将非字符串转化为字符串1str(n) #将非字符串转化为字符串 列表123456789101112list = [] #创建一个空列表list.append('abc') #在列表末尾添加元素list.insert(0, 'abc') #在列表的0位置处添加一个元素del list[1] #删除列表中1位置的元素x = list.pop() #弹出栈顶元素list.remove('abc') #移除第一个出现的元素abclist.sort() #按字母顺序从小到大list.sort(reverse=True) #按与字母顺序相反的顺序排列sorted(list) #字母顺序显示列表，不影响列表内部排序sorted(list, reverse=True) #逆字母顺序显示列表，不影响列表内部排序list.reverse() #反转列表中的元素len(list) #获取列表长度 print输出的格式12输入不换行:print(2233, end = '') 产生数字列表12生成数字列表:numbers = list(range(5)) #range产生[0, 5)的整数 ** #表示乘方运算 最小值、最大值及总和123456numbers = list(range(10))#数字列表中的最小值,最大值以及总和min(numbers) max(numbers)sum(numbers) 列表解析12range(start, stop, step) #从start开始，以stop - 1结束步长为step的整数list = [value for value in range(1, 21, 2)] #1~20以内的奇数.列表解析: 表达式(value) + 循环(for...)) 切片123456789101112131415players = ['charles', 'martina', 'michael', 'florence', 'eli']print(players[0 : 3]) #输出列表中的0~2号元素print(players[:4]) #省略第一个索引，默认为从头开始print(players[2:]) #省略第二个索引，默认为从索引2开始到末尾print(players[-3:]) #从倒数第三个索引开始到末尾所有元素#遍历切片for player in players[:3]: print(player)#复制列表other_players = players[:]#如果是下面这样, 并不能复制列表other_players = players #将other_players关联到players，other_players内容改变对players有效 元组1234dimensions = (200, 50) #使用括号来标识, 元组内的值不能更改,但是可以重新定义dimensions = (400, 100)for dimension in dimensions: print(dimension) 判断特定值是否在列表中123numbers = [1, 2, 3, 4]print(3 in numbers) //Trueprint(56 not in numbers) //True 遍历键值对1234tom = &#123;'name': 'tom', 'age': 34, 'heigh': 150, 'weight': 40&#125;for k, v in tom.items(): print(k + \":\", end = ' ') print(v) 遍历字典12345678910111213favorite_language = &#123; 'jen': 'python', 'sarah': 'c', 'edward': 'ruby', 'phil': 'python',&#125;for key in favorite_language.keys(): #遍历键 print(key)for name in favorite_language.values(): #遍历值 print(name)for k, v in favorite_language.items(): print(k + \" \" v) 嵌套123456789101112131415#字典列表alien_0 = &#123;'color': 'green', 'points': 5&#125;alien_1 = &#123;'color': 'yellow', 'points': 10&#125;alien_2 = &#123;'color': 'red', 'points': 15&#125;aliens = [alien_0, alien_1, alien_2]for alien in aliens: print(alien)#字典中储存列表pizza = &#123; 'crust': 'thick', 'toppings': ['mushrooms', 'extra cheese'],&#125;","categories":[],"tags":[]},{"title":"加快github和firefox扩展页面访问速度","slug":"improveBrowseSpeed","date":"2019-03-18T12:56:16.356Z","updated":"2019-03-18T12:56:16.232Z","comments":true,"path":"2019/03/18/improveBrowseSpeed/","link":"","permalink":"https://gydjsz.github.io/2019/03/18/improveBrowseSpeed/","excerpt":"访问https://www.ipaddress.com，拉下来，找到页面中下方的“IP Address Tools – Quick Links”","text":"访问https://www.ipaddress.com，拉下来，找到页面中下方的“IP Address Tools – Quick Links”分别输入github.global.ssl.fastly.net和github.com，查询ip地址修改本地hosts文件 在/etc/hosts中添加以下内容： 151.101.185.194 https://github.global.ssl.fastly.net192.30.253.112 https://github.com 117.18.232.191 mozorg.cdn.mozilla.net117.18.232.191 addons.cdn.mozilla.net","categories":[],"tags":[]},{"title":"github搭建自己的博客步骤","slug":"hexoBuild","date":"2019-03-18T12:56:04.392Z","updated":"2019-03-18T12:56:04.360Z","comments":true,"path":"2019/03/18/hexoBuild/","link":"","permalink":"https://gydjsz.github.io/2019/03/18/hexoBuild/","excerpt":"先在github上注册账号，新建一个仓库，仓库名为用户名.github.io","text":"先在github上注册账号，新建一个仓库，仓库名为用户名.github.io 1.安装git：sudo apt-get install git2.git安装完成之后设置基本信息 1)设置用户名：git config –global user.name “用户名” 2)设置用户名邮箱：git config –global user.email “邮箱” 3)查看设置：git config –list 3.添加ssh公钥：ssh-keygen -t rsa -C “email”,输入cat ~/.ssh/if_rsa.pub，将公钥添加到github中，可以输入ssh -T git@github.com，测试是否连接成功4.安装nodejs：curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -sudo apt-get install -y nodejs5.安装npm：sudo apt-get install npm6.安装hexo：sudo npm install hexo-cli -g(npm install)7.初始化hexo：hexo init安装一些插件： npm install hexo-generator-index –save #索引生成器 npm install hexo-generator-archive –save #归档生成器 npm install hexo-generator-category –save #分类生成器 npm install hexo-generator-tag –save #标签生成器 npm install hexo-server –save #本地服务 npm install hexo-deployer-git –save #hexo通过git发布（必装） npm install hexo-renderer-marked@0.2.7--save #渲染器 npm install hexo-renderer-stylus@0.3.0 –save #渲染 8.初始化git：git init9.git clone 仓库，查看clone 地址：git remote -v，为https:// 方式移除https的方式，换成 ssh方式 git remote rm origin， git remote add origin git地址 首先找到一个背景图片放到 hexo（hexo工程文件）-&gt; themes -&gt; next -&gt; source -&gt; images 的路径下；hexo（hexo工程文件）-&gt; themes -&gt; next -&gt; source -&gt; css -&gt; _custom ，找到路径下的custom.styl文件，在文件的最上方加上一代码 body { background:url(/images/backGround.jpg（这是你之前加的背景图片的名字）);} 就完事了。出现 fatal: 不是一个 git 仓库（或者任何父目录）：.git 错误提示时，需要初始化本地仓库：git inithexo new “postName” #新建文章 hexo new page “pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 hexo deploy -g #生成加部署 hexo server -g #生成加预览 命令的简写hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy git中ssh的生成：ssh-keygen -t rsa -C “youremail@example.com“ 从git中删除文件：git rm 文件名 从github上复制仓库中的项目：git clone 仓库地址 将本地仓库同步到远程仓库：git push 在工作区编写文件、通过git add 文件名添加到暂存区、通过git commit -m “提交信息”添加到本地仓库，通过git push同步到远程仓库 如果是私有仓库或者无法关联远程仓库，无法同步，需要输入用户名和密码的，可以： vim .git/config 将 [remote “origin”] url = https://github.com/用户名/仓库名.git 改为 [remote “origin”] url = https://用户名:密码@github.com/用户名/仓库名.git 个人站点 -&gt; 新建仓库 -&gt; 仓库名必须是用户名.github.io 如果无法推送到远程仓库，原因是远程仓库有过变动，需要先将远程仓库同步到本地：git pull，再将本地文件添加到远程仓库：git push 打开hexo博客分类标签出现Cannot GET/xxxx，说明需要初始化子目录，输入hexo new page “categories”, 就会在source文件里面初始化这些目录，并生成一个index文件","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-03-18T12:54:30.580Z","updated":"2019-03-18T12:54:30.496Z","comments":true,"path":"2019/03/18/hello-world/","link":"","permalink":"https://gydjsz.github.io/2019/03/18/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"一、STL容器篇","slug":"StlLearn/container","date":"2019-03-17T09:52:51.898Z","updated":"2019-03-17T09:52:51.866Z","comments":true,"path":"2019/03/17/StlLearn/container/","link":"","permalink":"https://gydjsz.github.io/2019/03/17/StlLearn/container/","excerpt":"","text":"目录(点击章节可跳转)：1. vector容器- 1.1 构造- 1.2 常用赋值操作- 1.3 大小操作- 1.4 存取- 1.5 插入与删除- 1.6 一些技巧2. string容器- 2.1 构造- 2.2 基本操作- 2.3 存取操作- 2.4 拼接操作- 2.5 查找与替换- 2.6 字典序比较- 2.7 子串- 2.8 插入与删除- 2.9 string和char*- 2.10 一些实用方法3. deque容器- 3.1 构造- 3.2 赋值操作- 3.3 大小操作- 3.4 双端插入与删除- 3.5 数据存取- 3.6 插入与删除操作4. stack容器- 4.1 构造- 4.2 赋值操作- 4.3 数据存取- 4.4 大小操作5. queue容器- 5.1 构造- 5.2 存取、插入和删除- 5.3 赋值- 5.4 大小操作6. list容器- 6.1 构造- 6.2 插入与删除- 6.3 大小操作- 6.4 赋值操作- 6.5 存取- 6.6 反转排序7. set/multiset容器- 7.1 构造- 7.2 赋值操作- 7.3 大小操作- 7.4 插入与删除- 7.5 查找操作- 7.6 修改排序规则8. map/multimap容器- 8.1 构造- 8.2 赋值- 8.3 大小操作- 8.4 插入和删除- 8.5 查找 一、vector迭代器可以动态分配内存,当内存不足时，会自动分配一个更大的空间，并把值拷贝进来，原有空间释放1.构造12345//头文件#include &lt;vector&gt;vector&lt;T&gt; v; //定义vector&lt;T&gt; v(v.begin(), v.end()) //拷贝[v.begin(),v.end())的元素vector&lt;T&gt; v(n, elem); //将n个elemvector&lt;T&gt; v(vec) //拷贝构造2.常用赋值操作12345678910111213141516171819v.begin() //指向容器中第一个元素位置v.end() //指向容器中最后一个元素的下一个位置v.rbegin() //指向容器中最后一个位置v.rend() //指向容器中第一个元素的前一个位置v.assign(begin, end); //将[begin, end)拷贝到v中v.assign(n, elem); //将n个elem拷贝给vv = vec; //直接赋值v.swap(vec); //v与vec元素互换//使用swap()方法收缩内存vector&lt;int&gt; v;for(int i = 0; i &lt; 10000; i++) v.push_back(i);v.size(); //大小为10000v.capacity(); //大小大于10000v.resize(3); //重新指定容器长度为3,其容量大于10000//vector&lt;int&gt; (v)为匿名构造一个vector容器，将v中的值赋给匿名容器，容器size为3,容量为3vector&lt;int&gt; (v).swap(v); //此时匿名容器和v交换，v的size为3,容量也为3,匿名容器空间被系统自动回收3.大小操作123456789size() //返回容器中元素的个数empty() //判断容器是否为空resize(num) //重新指定容器的长度为num， 若容器变长，则以默认值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除resize(num, elem) //重新指定容器的长度为num， 若容器变长，则以elem填充新位置，如果容器变短，则末尾超出容器长度的元素被删除capacity() //容器的容量reserve(len) //容器预留len个元素长度，预留位置不可初始化，元素不可访问如果事先可以预测所需空间大小v.reserve(10000) //预开辟空间10000, 可以节约多次扩充空间的时间4.存取123v.at(index) 和 v[index] //返回index所指数据front() //返回容器中第一个数据的元素back() //返回容器中最后一个数据的元素5.插入与删除12345insert(pos, count, elem) //迭代器指向的pos(pos是迭代器)位置插入count个elem元素push_back(elem) //尾部插入一个元素elempop_back() //删除最后一个元素erase(start, end) //删除迭代器从start到end之间的元素,start和end是迭代器clear() //删除容器中所有元素6.一些技巧12345678910111213141516171819202122232425262728293031323334353637383940414243//向容器中添加数据v.push_back(1); //将1存入容器v中v.push_back(2); //将2存入容器v中v.push_back(3); //将3存入容器v中//通过迭代器遍历容器//v.begin() 起始迭代器，指向第一个元素的地址，v.end() 结束迭代器，指向最后一个元素的下一个地址for(vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it)&#123; cout &lt;&lt; *it &lt;&lt; endl; //依次输出容器中的数据&#125;//通过for_each()//头文件#include &lt;algorithm&gt;for_each(v.begin(), v.end(), output); void output(int n)&#123; cout &lt;&lt; n &lt;&lt; endl;&#125;//容器嵌套vector&lt;vector&lt;int&gt;&gt; vv;vector&lt;int&gt; v1;vector&lt;int&gt; v2;vector&lt;int&gt; v3;v1.push_back(1);v2.push_back(2);v3.push_back(3);vv.push_back(v1);vv.push_back(v2);vv.push_back(v3);for(vector&lt;vector&lt;int&gt;&gt;::iterator iter = vv.begin(); iter != vv.end(); ++iter) for(vector&lt;int&gt;::iterator it = (*iter).begin(); it != (*iter).end(); ++it) cout &lt;&lt; *it &lt;&lt; endl;//逆序遍历for(vector&lt;int&gt;::reverse it = v.rbegin(); it != v.rend(); ++it) cout &lt;&lt; *it &lt;&lt; endl;//vector容器的迭代器是随机访问迭代器 二、string容器1. 构造123string str; //创建一个空的字符串string s(str); //使用一个string对象初始化另一个string对像,即拷贝string s1(3, 'h'); //使用n个字符初始化2.string基本赋值操作123456string s = \"hello\";string s1 = s; //字符串赋值 s1.assign(s); //将字符s赋给s1s1.assign(\"hello\", n); //将前n个字符赋给当前字符串(string&amp; assign(const char* s, int n)), 这里貌似使用常量字符串或者字符数组是这样的，如果是变量字符串，那么是从n位置开始之后的字符串,如果n是3, 那么s1 = \"lo\";s1.assign(n, c); //用n个字符c赋给s1s1.assign(s, start, n); //将s从start开始n个字符赋值给s13.string存取字符操作12345678910111213string s = \"hello\";s[0]; //通过[]获取s[1];s[2];s.at(0); //通过at方法获取s.at(1);s.at(2); /*1.[]和at的区别：[]访问越界直接挂掉，at访问越界会抛出out_of_range异常2.[]效率高，at更安全*/4.string拼接操作123456789string s1 = \"hello\", s2 = \"world\";s1 += s2; //使用+=操作符，将s2连接到s1尾s1.append(s2); //append()方法, 将s2连接到s1尾s1.append(\"hello\", n); //将字符串的前n个字符连接到s1尾,适用于字符串常量和字符数组s1.append(s2, start, n); //将字符串s2从start开始的n个字符连接到s1尾s1.append(n, c); //在s1尾部添加n个字符c5.string查找与替换1234567891011121314//查找不到返回-1str.find(s, pos); //查找第一次出现s的位置，从pos开始查找str.find(s, pos, n); //从pos开始查找s的前n个字符第一次出现的位置//rfind(),r即right,从右往左查找//这里应该是每次将该字符作为首字符依次往后找，比如str = \"abcabc\", n = str.find(\"abc\", 3),n = 3;str.rfind(s, pos); //从pos开始从右向左查找s第一次出现的位置str.rfind(s, pos, n); //从pos开始从右向左查找s的前n个字符第一次出现的位置str.replace(pos, n, s); //替换从pos开始的n个字符为字符串s/*str = \"hello\";str.replace(0, 2, \"abcdef\"); //str = \"abcdefllo\"*/6.string比较操作12str1.compare(str2); //字典序比较，&gt;返回1，&lt;返回-1, ==返回0//也可以直接使用&gt;,&lt;,==比较7.string子串1str.substr(pos, n); //返回由pos开始的n个字符组成的字串8.插入与删除123str.insert(pos, s); //在pos位置插入字符串sstr.insert(pos, n, c); //在指定位置插入n个字符cstr.erase(pos, n); //删除从pos开始的n个字符9.string和char*12345678//string转char*string s = \"hello\";const char* cs = s.c_str(); //添加const,或者强制转换(char*)s.c_str(),因为其返回值是const char*//c++中存在const char*到string的隐式类型转换,反之不行//char*转stringchar* cs = \"hello\";string s(cs); //直接赋值就ok10.一些实用方法12c = toupper(c); //将小写字符c转化为大写c = tolower(c); //将大写转化为小写 三、deque容器deque是双向开口，可以在头尾两端分别做元素的插入和删除操作1.构造1234deque&lt;T&gt; deqT //默认构造deque&lt;T&gt; deqT(begin, end) //将[begin, end)区间中的数据拷贝给deqTdeque&lt;T&gt; deqT(n, elem) //将n个elem元素拷贝给deqTdeque&lt;T&gt; deqT(deq) //拷贝构造2.赋值操作1234assign(begin, end) //将[begin,end)区间的元素拷贝过来assign(n, elem) //将n个elem拷贝过来= //重载运算符=直接赋值swap(deq) //与deq的元素交换3.大小操作1234size() //返回容器中元素的大小empty() //判断容器是否为空resize(num) //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除resize(num, elem) //重新指定容器的长度为num，若容器变长，则以elem填充新位置。如果容器变短，则末尾超出容器长度的元素被删除4.双端插入与删除1234push_back(elem) //在容器尾部插入一个数据push_front(elem) //在容器头部插入一个数据 pop_back() //删除容器最后一个数据pop_front() //删除容器第一个数据5.数据存取123at(index) 和 [] //at()方法和[]访问,索引indexfront() //返回第一个数据back() //返回最后一个数据6.插入和删除操作1234567insert(pos, elem) //在pos位置插入一个elem元素,返回新数据位置insert(pos, n, elem) //在pos位置插入一个elem元素，无返回值insert(pos, begin, end) //在pos位置插入[begin, end)区间的数据，无返回值clear() //移除容器所有数据erase(begin, end) //删除[begin, end)区间的数据，返回下一个数据的位置erase(pos) //删除pos位置的数据,返回下一个数据的位置7.一个例子12345678910111213141516171819202122232425262728293031//将5名学生的分数排序，去掉最低和最高分，计算平均分#include &lt;iostream&gt;#include &lt;deque&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; deque&lt;int&gt; deq; //定义 deq.push_back(80); //尾插入值 deq.push_back(72); deq.push_back(90); deq.push_back(85); deq.push_back(74); sort(deq.begin(), deq.end()); //由小到大排序 deq.pop_front(); //去掉头元素 deq.pop_back(); //去掉尾元素 double sum = 0; for(deque&lt;int&gt;::iterator it = deq.begin(); it != deq.end(); ++it) //利用迭代器遍历求和 sum += *it; cout &lt;&lt; sum / deq.size() &lt;&lt; endl; //取平均 return 0;&#125;/*如果是由大到小排序 sort(deq.begin(), deq.end(), cmp); bool cmp(int a, int b)&#123; return a &gt; b; &#125;*/ 四、stack容器stack所有元素进出都必须符合”先进后出”的条件，只有stack顶端的元素才有机会被外界取用.stack不提供遍历功能，也不提供迭代器1.构造12stack&lt;T&gt; stkT //默认构造stack&lt;T&gt; stkT(stk) //拷贝构造2.赋值操作1stkT = stk //重载操作符=3.数据存取123push(elem) //向栈顶添加一个元素pop() //向栈顶移除一个元素top() //返回栈顶元素4.大小操作12empty() //判断堆栈是否为空size() //返回堆栈大小 五、queue容器一种先进先出的数据结构,允许从一端新增元素，从另一端移除元素,不提供遍历，也没有迭代器1.构造12queue&lt;T&gt; queT //默认构造queue&lt;T&gt; queT(que) //拷贝构造2.存取、插入和删除1234push(elem) //往队尾插入一个元素pop() //从队头移除第一个元素back() //返回最后一个元素front() //返回第一个元素3.赋值1queT = que //重载运算符=将一个queue容器拷贝给另一个4.大小操作12empty() //判断队列是否为空size() //返回队列的大小 六、list容器list容器是一个循环双向链表，对于任何位置的元素插入和删除是常数时间1.构造1234list&lt;T&gt; lstT //默认构造list&lt;T&gt; lstT(begin, end) //将[begin, end)区间中的元素拷贝给lstTlist&lt;T&gt; lstT(n, elem) //将n个elem拷贝给lstTlist&lt;T&gt; lstT(lst) //拷贝构造2.插入和删除操作123456789101112131415push_back() //在容器尾部加入一个元素pop_back() //删除容器最后一个元素push_front(elem) //在容器头部加入一个元素pop_front() //删除容器第一个元素begin() //第一个元素的迭代器end() //最后一个元素的下一个迭代器rbegin() //最后一个元素的迭代器 reverse_iterator迭代器rend() //第一个元素的前一个迭代器 reverse_iterator迭代器insert(pos, elem) //在pos位置插入elem元素,返回新数据的位置insert(pos, n, elem) //在pos位置插入n个elem元素insert(pos, begin, end) //在pos位置插入[begin, end)区间的数据clear() //移除容器内所有元素erase(begin, end) //删除[begin, end)区间的数据，返回下一个数据的位置erase(pos) //删除pos位置的数据,返回下一个数据的位置remove(elem) //删除容器中所有与elem值匹配的数据3.大小操作1234size() //返回容器中元素的个数empty() //判断容器是否为空resize(num) //重新指定容器长度为num,若容器变长，则以默认值填充新位置，若容器变短，则末尾超出容器长度的元素被删除resize(num, elem) //重新指定容器长度为num,若容器变长，则以elem填充新位置，若容器变短，则末尾超出容器长度的元素被删除4.赋值操作1234assign(begin, end) //将[begin, end)区间的数据拷贝给容器assign(n, elem) //将n个elem拷贝给容器= //重载运算符swap(lst) //和lst的元素交换5.存取12front() //返回第一个元素back() //返回最后一个元素6.反转排序12345678910reverse() //反转链表，将数据反转sort() //list排序, 由小到大,由于list不是随机访问的迭代器，内部提供了相应算法的接口/* //由大到小排序 lst.sort(cmp); bool cmp(int a, int b)&#123; return a &gt; b; &#125;*/ 七、set/multiset容器所有元素会根据元素的键值自动被排序，set的元素既是键值又是实值(key即value)，set不允许两个元素有相同的键值.不能通过迭代器改变set元素的值，因为set元素值就是键值，关系到set元素的排序规则,如果任意改变，会破坏set组织。换句话说，set的iterator是一种const_iteratormultiset特性和用法与set完全相同，唯一的差别在于它允许键重复1.构造123set&lt;T&gt; st //默认构造multiset&lt;T&gt; mst set&lt;T&gt; stT(st) //拷贝构造2.赋值操作12= //重载运算符swap(st) //交换两个容器3.大小操作12size() //返回容器中元素的数目empty() //判断容器是否为空4.插入和删除操作12345insert(elem) //在容器中插入elem元素clear() //清除所有元素erase(pos) //删除pos迭代器所指元素，返回下一个元素的迭代器erase(begin, end) //删除[begin, end)的所有元素，返回下一个元素的迭代器erase(elem) //删除容器中值为elem的元素5.查找操作12345678910111213141516171819202122232425262728find(key) //查找key是否存在，若存在返回该键元素的迭代器，不存在，返回set.end()count(key) //查找键key的个数lower_bound(keyElem) //返回第一个key &gt;= keyElem的迭代器upper_bound(keyElem) //返回第一个key &gt; keyElem的迭代器equal_range(keyElem) /*equal_range是C++ STL中的一种二分查找的算法，试图在已排序的[first,last)中寻找value，它返回一对迭代器i和j，其中i是在不破坏次序的前提下，value可插入的第一个位置（亦即lower_bound），j则是在不破坏次序的前提下，value可插入的最后一个位置（亦即upper_bound），因此，[i,j)内的每个元素都等同于value，而且[i,j)是[first,last)之中符合此一性质的最大子区间*/pair&lt;set&lt;int&gt;::iterator, set&lt;int&gt;::iterator&gt; it = st.equal_range(elem);//it.first为lower_bound()//it.second为upper_bound()//对组pair是将2个数据组合成一组数据，当需要这样的需求时就可以使用pair，如stl中的map就是将key和value放在一起来保存。另一个应用是，当一个函数需要返回2个数据的时候，可以选择pair。pair的实现是一个结构体，主要的两个成员变量是first second因为是使用struct不是class，所以可以直接使用pair的成员变量。pair&lt;T1, T2&gt; p //创建一个空对象pair&lt;T1, T2&gt; p(v1, v2) //创建一个pair对象，两个元素分别为v1和v2pair&lt;T1, T2&gt; p = make_pair(v1, v2) //调用方法创建pair.first //第一个元素pair.second //第二个元素6.修改set排序规则123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;//利用仿函数指定set容器的排序规则//使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了。class Mycompare&#123; public: bool operator()(int a, int b)&#123; //重载() return a &gt; b; &#125;&#125;;int main()&#123; set&lt;int, Mycompare&gt; st; //由于set自动从小到大排序,这里需要一个排序函数，但是set&lt;&gt;中必须是一种类型，不能是函数，所以就用仿函数来使得一个类拥有函数的行为 st.insert(1); st.insert(2); st.insert(3); st.insert(4); for(set&lt;int, Mycompare&gt;::iterator it = st.begin(); it != st.end(); ++it) cout &lt;&lt; *it &lt;&lt; \" \"; //输出4 3 2 1 return 0;&#125; 八、map/multimap特性：所有元素会根据元素的键值自动排序，map的所有元素是pair，同时拥有实值和键值，pair第一元素为键值，第二为实值，map不允许两个元素有相同的键值(multimap键值可重复)1.构造12map&lt;T1, T2&gt; mapT //默认构造map&lt;T1, T2&gt; mapT(m) //拷贝构造2.赋值12= //重载操作符=swap(mp) //交换两个集合容器3.大小操作12size() //返回容器中元素的个数empty() //判断容器是否为空4.插入和删除1234567891011121314151617insert() //往容器插入元素，返回pair&lt;iterator, bool&gt;//第一种:通过pair的方式插入insert(pair&lt;int, string&gt;(1, \"折纸\"))//第二种:通过pair的方式插入insert(makr_pair(2, \"二亚\"))//第三种:通过value_type的方式插入insert(map&lt;int, string&gt;::value_type(3, \"狂三\"))//第四种:通过数组的方式插入mapStu[7] = \"七罪\"mapStu[8] = \"八舞\"first 和 second //键值和实值clear() //删除所有元素erase(pos) //删除pos迭代器所指的元素，返回下一个元素的迭代器erase(begin, end) //删除[begin, end)的所有元素，返回下一个元素的迭代器erase(keyElem) //删除容器中key为keyElem的对组5.查找12345find(key) //查找key是否存在，若存在，返回元素的迭代器，否则返回map.end()count(keyElem) //返回容器中key为keyElem的对组个数，对map来说要么是0,要么是1，对于multimap来世，值可能大于1lower_bound(keyElem) //返回第一个key &gt;= keyElem元素的迭代器upper_bound(keyElem) //返回第一个key &gt; keyElem元素的迭代器equal_bound(keyElem) //返回容器中key与keyElem相等的上下限的两个迭代器","categories":[],"tags":[]},{"title":"虚拟机与windows 10互传文件","slug":"virtual/virtualOperation","date":"2019-02-05T14:56:37.648Z","updated":"2019-02-05T14:56:37.612Z","comments":true,"path":"2019/02/05/virtual/virtualOperation/","link":"","permalink":"https://gydjsz.github.io/2019/02/05/virtual/virtualOperation/","excerpt":"在虚拟机设置中找到“选项”，再点击共享文件夹，点击启用，然后在下方的添加里面加入windows 10共享文件的目录","text":"在虚拟机设置中找到“选项”，再点击共享文件夹，点击启用，然后在下方的添加里面加入windows 10共享文件的目录 在Ubuntu中，共享文件的路径为 /mnt/hgfs，cd /mnt/hgfs进入之后就可以查看了 出现启用了共享后没有反应的情况时，可以： 输入sudo vmhgfs-fuse .host:/ /mnt/hgfs 启用vmhgfs-fuse模块，然后以root用户进入目录就可以查看文件了。 在/root/.bashrc 中添加命令vmhgfs-fuse .host:/ /mnt/hgfs，每次开机以root用户登陆，就可以直接访问共享文件啦","categories":[],"tags":[]},{"title":"终端下emacs鼠标支持","slug":"LearnEmacs/Mouse","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/LearnEmacs/Mouse/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/LearnEmacs/Mouse/","excerpt":"","text":"[参考链接]http://cn-popeye.iteye.com/blog/1164033[参考链接]http://blog.chinaunix.net/uid-20609878-id-1915823.html[参考链接]http://emacser.com/mouse.htmECB模式开启四个窗口，可以浏览目录，源码文件，方法和历史记录，但是默认只支持键盘操作，RET才能打开。 要支持鼠标需如下操作： 1.在 Emacs 中执行“ M-x ecb-customize-most-important ”，找到“ Ecb Primary Secondary Mouse Buttons ”选项 2.将其设为“ Primary: mouse-1, secondary: mouse -2 ” ， 3.点击state，设置成“ Save for Future Sessions ”保存。 在.emacs配置文件中加入(xterm-mouse-mode t), 支持终端鼠标","categories":[],"tags":[]},{"title":"设置emacs里面的字体类型","slug":"LearnEmacs/EmacsTypeFace","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/LearnEmacs/EmacsTypeFace/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/LearnEmacs/EmacsTypeFace/","excerpt":"","text":"在Option里面找到Set Default Font，然后选择自己喜欢的字体，打开.emacs文件，输入M-x，在下方输入describe-font， 回车之后再回车，出现如图形式： 复制如图黄色选中的部分，然后在.emacs之中添加： ;;set font family (set-default-font “-bitstream-Courier 10 Pitch-normal-normal-normal--29----m-0-iso10646-“) 就可以永久设置字体","categories":[],"tags":[]},{"title":"Ubuntu下打开Anaconda图形界面","slug":"anacondaStart","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/anacondaStart/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/anacondaStart/","excerpt":"","text":"在终端下输入anaconda-navigator","categories":[],"tags":[]},{"title":"Linux将文件内容输出重定向","slug":"Linux/outputRedirection","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/Linux/outputRedirection/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Linux/outputRedirection/","excerpt":"","text":"将一个文件内容重定向至另一个文件中 1cat hello.cpp &gt; world.cpp 将一个文件中的内容重定向至剪贴板中 123sudo apt install xselcat hello.cpp | xsel -b -i //将hello.cpp内容写入剪贴板中","categories":[],"tags":[]},{"title":"缩略linux路径","slug":"Linux/CutPathName","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/Linux/CutPathName/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Linux/CutPathName/","excerpt":"","text":"emacs ~/.bashrc 将 if [ “$colovr prompt” = yes ]; then PS1=’${debian chroot:+($debian chroot)}[\\033[01;32m]\\u@\\h[\\033[00m]:[\\033[01;34m]\\w[\\033[00m]\\$ ‘else PS1=’${debian chroot:+($debian chroot)}\\u@\\h:\\w\\$ ‘ 里面的小写w改为大写的W就可以缩略路径名，避免进入的目录多了之后导致路径名太长，可以使用pwd来查看全目录","categories":[],"tags":[]},{"title":"设置root密码","slug":"Linux/setRoot","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/Linux/setRoot/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Linux/setRoot/","excerpt":"","text":"Ubuntu下 su:出现： authentication failure的解决办法执行：sudo passwd root","categories":[],"tags":[]},{"title":"c++和java在linux下的编译运行","slug":"Linux/Compile","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/Linux/Compile/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Linux/Compile/","excerpt":"","text":"c++的编译运行g++ &ensp;text.cpp -o &ensp;text.out./text.out 如果不加 -o ,则默认为a.outg++ &ensp;text.cpp./a.out java的编译运行javac &ensp;Text.javajava &ensp;Text","categories":[],"tags":[]},{"title":"设置终端打开的快捷键","slug":"Linux/SetTerminalKey","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/Linux/SetTerminalKey/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Linux/SetTerminalKey/","excerpt":"","text":"打开设置，找到键盘选项，在右边往下拉，找到‘+’，名称填写：Terminal；命令填写：/usr/bin/gnome-terminal;我的快捷键：C-M-t","categories":[],"tags":[]},{"title":"centos7中使用yum安装ntfs-3g","slug":"Linux/Install_Ntfs-3g","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/Linux/Install_Ntfs-3g/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Linux/Install_Ntfs-3g/","excerpt":"","text":"加源wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo 安装yum update;yum install ntfs-3gyum install ntfs-3g","categories":[],"tags":[]},{"title":"vim中修改颜色配置","slug":"LearnVim/ColorSetting","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/LearnVim/ColorSetting/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/LearnVim/ColorSetting/","excerpt":"","text":"参考链接:&ensp;https://blog.csdn.net/qq_16912257/article/details/77957248 在linux终端中输入cd /usr/share/vim/vim74/colors进入目录然后输入ls查看vim中自带的配色方案 修改~/.vimrc配置在.vimrc中添加colorscheme peachpuffpeachpuff为主题的名字","categories":[],"tags":[]},{"title":"设置emacs在shell中显示","slug":"LearnEmacs/TurnCharacter","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/LearnEmacs/TurnCharacter/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/LearnEmacs/TurnCharacter/","excerpt":"","text":"emacs安装之后在终端里面打开的是图形版，要想在shell里面直接打开就在~/.bashrc里面添加alias emacs=’emacs -nw’注意等号两边没有空格","categories":[],"tags":[]},{"title":"在eclipse中使用vim","slug":"LearnVim/vimInEclipse","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/LearnVim/vimInEclipse/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/LearnVim/vimInEclipse/","excerpt":"","text":"参考链接:&ensp;https://blog.csdn.net/wr132/article/details/70232043 在help中找到Install New SoftWare,点击add,输入name和网址 选择viPlugin,之后点击next和accept 3.在eclipse根目录建立文件 viPlugin2.lic ，在其中输入 q1MHdGlxh7nCyn_FpHaVazxTdn1tajjeIABlcgJBc20 这里注意在安装插件过程中eclipse是没有什么反应的,这个时候不要重启,我之前按照教程里面说的选择了accept, next之后几秒种没反应就直接手动restart了,这个时候其实是在下载,最后eclipse会出现警告,点击install anyway,最后eclipse会弹出restart,点击这个就没问题了 5.vim模式的切换快捷键为Ctrl-Alt-v","categories":[],"tags":[]},{"title":"How to operate xsel in Linux?","slug":"Linux/xselOperation","date":"2019-01-19T10:30:53.952Z","updated":"2019-01-19T10:30:53.952Z","comments":true,"path":"2019/01/19/Linux/xselOperation/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Linux/xselOperation/","excerpt":"","text":"first download xsel in Linux by using this command: sudo apt-get install xselordownload the xsel(the link is in my other blog–Link Collection)modify the ~/.bashrc by vim or emacsFor example: 123vim ~/.bashrcin the last line add: export PATH=&apos;~/XselDirectory/&apos;source ~/.bashrc //make the operation effective Some operationxsel &lt; file //read file content to xselxsel &gt; file //write xsel content to xselxsel // show xsel contentcat file | xsel -b -i //file to xselcat file | xsel -b -a //add file content to xsel last line more content can read README in XselDirectory","categories":[],"tags":[]},{"title":"c++ 和 java添加环境变量","slug":"Java/environmentVariable","date":"2019-01-19T10:30:53.948Z","updated":"2019-01-19T10:30:53.948Z","comments":true,"path":"2019/01/19/Java/environmentVariable/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Java/environmentVariable/","excerpt":"","text":"1234//MinGW(以下根据自己的目录来)Path: E:\\BaiduNetdiskDownload\\MinGW\\mingw64\\bin INCLUDE: E:\\BaiduNetdiskDownload\\MinGW\\mingw64\\includeLib: E:\\BaiduNetdiskDownload\\MinGW\\mingw64\\libx 1234JAVA_HOME： F:\\Java\\jdk-10.0.2（根据自己的安装目录来）CLASSPATH： .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jarPath：第一个： %JAVA_HOME%\\bin 第二个： %JAVA_HOME%\\jre\\bin","categories":[],"tags":[]},{"title":"java题库导出","slug":"Java/questionBankExport","date":"2019-01-19T10:30:53.948Z","updated":"2019-01-19T10:30:53.948Z","comments":true,"path":"2019/01/19/Java/questionBankExport/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Java/questionBankExport/","excerpt":"","text":"题库链接: https://pan.baidu.com/s/1QRMfkJWUWN6F-dP5GaQ8jQ &emsp;&emsp;提取码：eus0jd-gui反编译工具链接: https://pan.baidu.com/s/1v0a6asCluIgqeswpR515ww &emsp;&emsp;提取码：308t 该题库软件支持jdk1.8版本 下载完成之后，将jd-gui-1.4.0.jar放置在该软件目录下的jar/bin/中,打开cmd命令行窗口，再执行:java.exe -jar jd-gui-1.4.0.jar，即可打开反编译的软件 通过反编译可以查看Tiku.jar中的内容，发现对象流指向的输出流对象是Problem类,这样我们可以先将题库中的内容提取出来,然后转型为ArrayList,之后就可以通过循环将文件内容输入到文本中。这里为了保持目录的一致性，可以先用数组存储每一个章节题目的位置信息，按照章节来将题库导出，File类中有mkdir()方法，可以创建目录，使用write()方法可以写入内容,由于将题目写入txt文本中之后,格式并不太友好,我这里使用缓冲流，因为里面有newline()方法，可以添加空行。我将ArrayList中的内容遍历，如果是’\\n’则使用newline()添加空行，这样使得文本内容更易于查看. 将Tiku.jar文件导入eclipse中，将如下代码添加到eclipse文本窗口中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import java.io.BufferedWriter;import java.io.EOFException;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileWriter;import java.io.IOException;import java.io.ObjectInputStream;import java.io.Serializable;import java.util.ArrayList;import quesion.data.Problem;/** * @author Administrator * */public class GetData implements Serializable&#123; String readPath; //题库目录 String writePath; //导出目录 String chapter[]; //存储章节信息 String type[]; //存储题目类型 ArrayList&lt;Problem&gt; problems; //problems存储题库内容 File readFile; File writeFile; FileInputStream fis; ObjectInputStream ois; FileWriter fw; BufferedWriter bw; public GetData() &#123; readPath = &quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\java\\\\题库\\\\&quot;; writePath = &quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\data\\\\&quot;; chapter = new String[15]; for(int i = 0; i &lt; 15; i++) chapter[i] = &quot;第&quot; + (i + 1) + &quot;章\\\\&quot;; type = new String[4]; type[0] = &quot;读程题&quot;; type[1] = &quot;判断题&quot;; type[2] = &quot;挑错题&quot;; type[3] = &quot;选择题&quot;; &#125; public void importFile() &#123; File directory; for(int i = 0; i &lt; 15; i++) &#123; for(int j = 0; j &lt; 4; j++) &#123; readFile = new File(readPath + chapter[i] + type[j] + &quot;.data&quot;); //将每一个文件的地址提取出来 directory = new File(writePath + chapter[i]); if(!directory.exists()) //判断目录是否存在，不存在就创建 directory.mkdir(); writeFile = new File(writePath + chapter[i] + type[j] + &quot;.txt&quot;); //文件输出地址 if(readFile.exists()) &#123; //如果读取的文件存在 try &#123; fis = new FileInputStream(readFile); //文件输入流 ois = new ObjectInputStream(fis); //对象输入流 fw = new FileWriter(writeFile); bw = new BufferedWriter(fw); //缓冲流 problems = new ArrayList&lt;Problem&gt;(); problems = (ArrayList&lt;Problem&gt;)(ois.readObject()); //对象输入流使用readObject()方法读取一个对象到程序中 for(Problem p : problems) &#123; //循环遍历problems String s = p.content; //content是题库代码中的题目属性 int flag = 0; //这里实际题库中会出现第一个字符就是&apos;\\n&apos;,我这里使用flag标记，不在第一排输出空行 if(p.content != null) &#123; for(int m = 0; m &lt; s.length(); m++) if(s.charAt(m) == &apos;\\n&apos; &amp;&amp; flag != 0) &#123; bw.newLine(); //添加新的行数 &#125; else &#123; bw.write(s.charAt(m)); flag = 1; &#125; &#125; bw.newLine(); s = p.correctAnswer; //correctAnswer是题库代码中的答案属性 flag = 0; if(p.correctAnswer != null) &#123; for(int m = 0; m &lt; s.length(); m++) if(s.charAt(m) == &apos;\\n&apos; &amp;&amp; flag != 0) &#123; bw.newLine(); &#125; else &#123; bw.write(s.charAt(m)); flag = 1; &#125; &#125; bw.newLine(); &#125; ois.close(); //关闭各个流 fis.close(); bw.close(); &#125; catch (FileNotFoundException e) &#123; &#125; catch (IOException e) &#123; &#125; catch (ClassNotFoundException e) &#123; &#125; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; GetData data = new GetData(); data.importFile(); &#125;&#125;","categories":[],"tags":[]},{"title":"java中的消息对话框","slug":"Java/sendMessage","date":"2019-01-19T10:30:53.948Z","updated":"2019-01-19T10:30:53.948Z","comments":true,"path":"2019/01/19/Java/sendMessage/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Java/sendMessage/","excerpt":"","text":"12JOptionPane.showMessageDialog(this, \"当前位置有棋子\"); //弹出对话框,this表示当前对象int result = JOptionPane.showConfirmDialog(this, \"是否退出游戏\"); //弹出对话选择框,是返回0, 否返回1,取消返回2,可以使用int型变量保存,方便判断选择的是哪一个","categories":[],"tags":[]},{"title":"关于JFrame使用setBackground()设置背景色没反应的问题","slug":"Java/setBackground","date":"2019-01-19T10:30:53.948Z","updated":"2019-01-19T10:30:53.948Z","comments":true,"path":"2019/01/19/Java/setBackground/","link":"","permalink":"https://gydjsz.github.io/2019/01/19/Java/setBackground/","excerpt":"","text":"参考链接:&ensp;https://zhidao.baidu.com/question/263731760.html参考链接:&ensp;https://blog.csdn.net/qq_34970891/article/details/69665986 原因:JFrame当中会默认使用流式布局管理器(FlowLayout)将整个窗体进行覆盖操作，也就是说设置的颜色确实是存在的，只是被布局管理器给覆盖住了，所以无法看见。 1. 如果直接使用Frame,则修改背景色使用setBackColor(Color.black); 2. 使用JFrame修改背景色 方法一: 调用getContentPane()方法得到一个contentPane容器，然后将其设置为不可见12setBackground(Color.black);getContentPane().setVisible(true); 方法二: 在JFrame当中添加一个面板容器，使得面板容器对窗体形成一个覆盖后，直接设置面板的背景颜色就可以达到相当于对窗体背景颜色进行设置的效果12Container con = getContentPane();con.setBackground(Color.black);","categories":[],"tags":[]}]}